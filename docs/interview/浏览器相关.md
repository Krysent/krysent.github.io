## 概述从输入 URL 到页面呈现的全过程？
```js
URL 解析 → DNS 查询 → TCP 握手 → TLS 握手 → 发送请求 → 服务器响应 → 
解析 HTML → 构建 DOM → 解析 CSS → 构建 CSSOM → 执行 JS → 合并渲染树 → 
布局 → 绘制 → 合成 → 页面呈现
```
1.  URL 解析与输入处理
协议补全：浏览器自动补全协议（如 http:// 或 https://）。

安全检查：检查 URL 是否合法，是否触发黑名单（如恶意网站）。

HSTS 检查：若域名在 HSTS 预加载列表中，强制使用 HTTPS。

2. DNS 解析

本地缓存查询：依次检查浏览器缓存 → 系统（hosts 文件）→ 路由器缓存。

递归查询：若本地无缓存，向 DNS 服务器发起请求（如 8.8.8.8），直到找到域名对应的 IP。

3. 建立网络连接

TCP 三次握手：客户端与服务器通过三次握手建立 TCP 连接。

TLS 握手（HTTPS）：若使用 HTTPS，需额外进行 TLS 握手（协商加密算法、交换密钥等）。

4. 发送 HTTP 请求

构造请求报文：浏览器生成 HTTP 请求，包含请求行（方法、URL）、请求头（Cookie、UA 等）、请求体（POST 数据）。

发送请求：通过 TCP 连接发送到服务器。

5. 服务器处理请求

负载均衡：请求可能被反向代理（如 Nginx）转发到后端服务器集群。

处理请求：服务器解析请求，执行业务逻辑（如查询数据库）。

生成响应：返回 HTTP 响应（状态码、响应头、响应体如 HTML 文件）。

6. 浏览器接收响应

解析状态码：处理 3xx（重定向）、4xx/5xx（错误）等。

缓存策略：根据响应头（Cache-Control、ETag 等）决定是否缓存资源。

Content-Type 处理：根据 Content-Type（如 text/html）选择解析方式。

7. 解析与渲染

8. 加载后续资源

延迟加载：按需加载图片、字体等非关键资源（如 `<img loading="lazy">`）。

异步执行：通过` defer/async `延迟 JS 执行，避免阻塞渲染。

9. 最终呈现

触发事件：页面触发 `DOMContentLoaded（DOM 解析完成）`和 load`（所有资源加载完成）`事件。

持续更新：通过` AJAX/WebSocket `动态更新内容，触发重排/重绘。

关键点：
减少 DNS 查询：使用 DNS 预解析（`<link rel="dns-prefetch">`）。

复用连接：`HTTP/2 `多路复用、`Keep-Alive `保持 TCP 连接。

资源优化：压缩文件`（Gzip/Brotli）`、图片懒加载、CDN 加速。

渲染优化：避免强制同步布局、减少重排重绘、使用 requestAnimationFrame。

## 浏览器报错状态码304是什么意思？
当浏览器返回 HTTP 状态码 304 时，表示 资源未修改（Not Modified），这并非错误，而是服务器告知客户端可以直接使用本地缓存的副本，无需重新下载资源。

协商缓存（304 Not Modified）：需向服务器发起验证请求，确认缓存有效性。资源未修改，协商缓存验证通过。

## 聊一下浏览器缓存，强缓存和协商缓存的区别?
说说你知道的浏览器缓存，项目中是如何实践的（叠纸、百度、小米）

浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存主要分为强缓存（也称本地缓存）和协商缓存（也称弱缓存）。

+ 强缓存

  当请求资源的时，如果是之前请求过的并使用强缓存，那么在过期时间内将不会发送本次请求向服务器获取资源，而是直接从浏览器缓存中获取（不管资源是否改动）。过期了将重新从服务器获取，并再次强缓存。
+ 协商缓存

  当请求资源时，如果是之前请求过的并使用协商缓存，还是发送请求到服务器，服务器通过逻辑判断确认资源没有修改返回304状态码，那么本次的资源则是从缓存中获取；如果经过判断确认资源被修改过，则重新发送资源到客户端，并且客户端更新缓存。

## 浏览器的渲染机制原理是什么？

**浏览器的整个渲染过程**

1. 解析 HTML，构建 DOM 树
2. 解析 CSS，生成 CSS 规则树
3. 合并 DOM 树和 CSS 规则树，生成 render（渲染）树。
4. 布局 render 树（回流 / 重排），负责各元素尺寸、位置的计算。
5. 绘制 render 树（painting 重绘），绘制页面像素信息
6. 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite）显示在屏幕上。

**构建渲染树时，浏览器主要完成以下工作**

- 从 DOM 树的根节点开始遍历每个可见节点
- 对每个可见节点，找到 CSS 规则树中对应的规则，并应用它们
- 根据每个可见节点以及其对应的样式，组合生成渲染树

**不可见节点（也就是不会出现在渲染树中的节点）**

- 一些不会渲染输出的节点（如：script、meta、link 等）
- 一些通过 css 进行隐藏的节点（如：display: none）。
- 不过要注意：visiblity 和 opacity 隐藏的节点是会显示在渲染树上的。

**浏览器接收到 HTML 文件并转换为 DOM 树**

当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。

当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。

那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。

以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。

字节数据 => 字符串 => Token => Node => DOM

当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件。

**将 CSS 文件转换为 CSSOM 树**

其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的

字节数据 => 字符串 => Token => Node => CSSOM

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

如果你有点不理解为什么会消耗资源的话，我这里举个例子

```html
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```
对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平

**生成渲染树**

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。

**为什么操作dom会慢，或者使用框架的时候尽量不要操作dom？**

想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

如果插入几万个 DOM，如何实现页面不卡顿？

对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 requestAnimationFrame 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。

这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。如果你想了解更多的内容可以了解下这个 react-virtualized

**什么情况阻塞渲染**

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。

然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。

当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。

当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。

对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染

##关于重绘（repaint）和回流（reflow）
重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
- 回流是布局或者几何属性需要改变就称为回流

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

以下几个动作可能会导致性能问题：

1. 改变 window 大小
2. 改变字体
3. 添加或删除样式
4. 文字改变
5. 定位或者浮动
6. 盒模型

并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。

1. 当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
2. 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 requestAnimationFrame 回调
7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。

既然我们已经知道了重绘和回流会影响性能，那么接下来我们将会来学习如何减少重绘和回流的次数：

1. 使用 transform 替代 top 
```html
<div class="test"></div>
<style>
  .test {
    position: absolute;
    top: 10px;
    width: 100px;
    height: 100px;
    background: red;
  }
</style>
<script>
  setTimeout(() => {
    // 引起回流
    document.querySelector('.test').style.top = '100px'
  }, 1000)
</script>
```
2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
3. 不要把节点的属性值放在一个循环里当成循环里的变量
```js
for(let i = 0; i < 1000; i++) {
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector('.test').style.offsetTop)
}
```
4. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
5. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
6. CSS 选择符从右往左匹配查找，避免节点层级过多,可以直接使用id选择器或类选择器
7. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。
8. 设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层（`will-change`\`<video/>`\`<iframe />`）

在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面，也就是常说的关键渲染路径，这部分也是性能优化中的一块内容。

首先你可能会疑问，那怎么测量到底有没有加快渲染速度呢?

当发生 DOMContentLoaded 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系了。

提示如何加速：

1. 从文件大小考虑
2. 从 script 标签使用上来考虑
3. 从 CSS、HTML 的代码书写上来考虑
4. 从需要下载的内容是否需要在首屏使用上来考虑

## 浏览器跨域问题
浏览器为什么要阻止跨域请求？如何解决跨域？每次跨域请求都需要到达服务端吗？

**什么是跨域**

跨域是针对浏览器的“同源策略”提出的说法。之所以有“同源策略”这种模式是基于网络安全方面的考虑。所谓的同源策略关注三点：

1. 协议 (http:www.baidu.com & https.www.baidu.com http 协议不同，跨域) 

2. 域名 (https://www.aliyun.com & https://developer.aliyun.com 域名不同，跨域) 

3. 端口 (http://localhost:8080 & http://localhost:8000 端口号不同，跨域)

**哪些网络资源涉及到跨域**

“同源策略”对于跨域网络资源的设定非常的清晰。这些场景涉及到跨域禁止操作：

+ 无法获取非同源网页的 cookie、localstorage 和 indexedDB。
+ 无法访问非同源网页的 DOM （iframe）。
+无法向非同源地址发送 AJAX 请求 或 fetch 请求（可以发送，但浏览器拒绝接受响应）。

为什么要阻止跨域呢？上文我们说过是基于安全策略：比如一个恶意网站的页面通过 iframe 嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的 javascript 脚本就可以在用户登录银行的时候获取用户名和密码。

**如何解决跨域**
1. 通过 jsonp 跨域
2. document.domain + iframe 跨域
3. location.hash + iframe
4. window.name + iframe 跨域
5. postMessage 跨域
6. 跨域资源共享（CORS）
7. nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

## JSONP 的原理是什么？
尽管浏览器有同源策略，但是 `<script>` 标签的` src `属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求

实现原理:
1. 创建 callback 方法
2. 插入 script 标签
3. 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法
4. 前端执行服务端返回的方法调用
```js
function jsonp ({url, params, callback}) {
  return new Promise((resolve, reject) => {
	// 创建 script 标签
	let script = document.createElement('script')
	// 将函数挂在 window 上
	window[callback] = function (data) {
	  resolve(data)
	  // 代码执行后，删除 script 标签
	  document.body.removeChild(script)
	}
	// 回调函数加在请求地址上
	params = {...params, callback} // wb=b&callback=show
	let arrs = []
	for (let key in params) {
	  array.push(`${key}=${params[key]}`)
	}
	script.src = `${url}?${arrs.join('&')}`
	document.body.appendChild(script)
  })
}

//具体使用
function show(data) {
  console.log(data)
}
jsonp({
  url: 'http://localhost:3000/show',
  params:{
	// code 参数
  },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```