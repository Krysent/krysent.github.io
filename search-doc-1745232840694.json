{"searchDocs":[{"title":"性能优化方案面试题","type":0,"sectionRef":"#","url":"/docs/interview/性能优化方案面试题","content":"性能优化方案面试题","keywords":"","version":"Next"},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/interview/intro","content":"关于 最新的面试题整理","keywords":"","version":"Next"},{"title":"JS代码打印输出题集合","type":0,"sectionRef":"#","url":"/docs/interview/JS代码打印输出题集合","content":"JS代码打印输出题集合","keywords":"","version":"Next"},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Here are a few tips you might find useful. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"css精选面试题","type":0,"sectionRef":"#","url":"/docs/interview/CSS面试题","content":"","keywords":"","version":"Next"},{"title":"居中为什么尽量使⽤ transform（为什么不使⽤marginLeft/Top）​","type":1,"pageTitle":"css精选面试题","url":"/docs/interview/CSS面试题#居中为什么尽量使-transform为什么不使marginlefttop","content":" 在居中元素时，使用 transform 的主要原因是它可以提供更好的性能和更灵活的布局控制，相比于使用 marginLeft 和 marginTop。  以下是使用 transform 进行居中的几个优势：  性能优化：transform 属性可以触发 GPU 加速，这意味着浏览器可以使用硬件加速来处理元素的渲染，从而提高性能。相比之下，使用 marginLeft 和 marginTop 进行居中可能会导致页面的重排和重绘，性能较差。灵活的布局控制：transform 属性可以与其他布局属性（如 position、display 等）结合使用，提供更灵活的布局控制。例如，可以将元素设置为绝对定位（position: absolute）并使用 transform 属性进行居中，这样可以在不影响其他布局的情况下实现居中效果。元素尺寸不影响布局：使用 transform 进行居中时，元素的尺寸不会影响其在布局中的位置。这意味着可以轻松地调整元素的大小而不会破坏居中效果。相比之下，使用 marginLeft 和 marginTop 进行居中时，元素的尺寸会影响其在布局中的位置，可能需要进行额外的计算和调整  ","version":"Next","tagName":"h2"},{"title":"CSS3 动画的实现方式有哪些，动手写一下将一个 div 在 1s 内移动 300px?​","type":1,"pageTitle":"css精选面试题","url":"/docs/interview/CSS面试题#css3-动画的实现方式有哪些动手写一下将一个-div-在-1s-内移动-300px","content":" css3 实现动画主要有 3 种方式  transition 过渡动画transform 2D 和 3D 转换animation 自定义动画  /* transition属性动画结合transform变化属性，实现元素移动一段距离的动画 */ #transitonDiv:hover { transition: all 1s ease-in-out; -webkit-transition: all 1s ease-in-out; -moz-transition: all 1s ease-in-out; -o-transition: all 1s ease-in-out; transform: translateX(300px); -ms-transform: translateX(300px); -moz-transform: translateX(300px); -webkit-transform: translateX(300px); -o-transform: translateX(300px); } /* 通过animation属性，实现逐帧动画 */ #animationDiv:hover { animation: animName 1s ease-in-out; -webkit-animation: animName 1s ease-in-out; -moz-animation: animName 1s ease-in-out; -o-animation: animName 1s ease-in-out; } /* 定义关键帧 */ @keyframes animName { 0% { transform: translateX(0px); } 30% { transform: translateX(100px); } 60% { transform: translateX(200px); } 100% { transform: translateX(300px); } }   此外还可以 window.requestAnimationFrame() 实现：  const element = document.getElementById('e'); let start; function render(timestamp) { if (start === undefined) { start = timestamp; } const elapsed = timestamp - start; //这里使用`Math.min()`确保元素刚好停在300px的位置。 element.style.transform = 'translateX(' + Math.min(0.3 * elapsed, 300) + 'px)'; console.log(element.style.transform) if (elapsed &lt; 1000) { // 在1秒后停止动画 window.requestAnimationFrame(render); } } window.requestAnimationFrame(render);   ","version":"Next","tagName":"h2"},{"title":"所有 css3 的动画都能用 GPU 加速么？​","type":1,"pageTitle":"css精选面试题","url":"/docs/interview/CSS面试题#所有-css3-的动画都能用-gpu-加速么","content":" 在 css 中，只有 3D 转换、opacity 透明、filter 滤镜和添加了 will-change 属性的元素，浏览器才会开启硬件（GPU）加速。  不过如果我们想要 2D、过渡等动画也能开启硬件加速,我们可以通过给这些元素加上transform: translateZ(0); 或transform: translate3d(0,0,0);来诱导浏览器开启硬件加速，但是我们不能滥用。  也可能通过添加 will-change 来实现。 ","version":"Next","tagName":"h2"},{"title":"浏览器垃圾回收机制","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/垃圾回收机制","content":"","keywords":"","version":"Next"},{"title":"内存泄露​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存泄露","content":" 内存泄漏是指，应当被回收的对象没有被正常回收，变成常驻老生代的对象，导致内存占用越来越高。内存泄漏会导致应用程序速度变慢、高延时、崩溃等问题。  ","version":"Next","tagName":"h2"},{"title":"内存生命周期​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存生命周期","content":" 分配：按需要去分配一块内存使用：读写已经分配的内存释放回收：释放掉不再使用的内存  ","version":"Next","tagName":"h3"},{"title":"内存泄露原因​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存泄露原因","content":" 创建了全局变量并且没有手动回收事件监听、定时器、闭包没有及时销毁使用js对象做缓存，且不设置过期策略和大小的限制  ","version":"Next","tagName":"h3"},{"title":"垃圾回收​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#垃圾回收","content":" ","version":"Next","tagName":"h2"},{"title":"关于引用计数法​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#关于引用计数法","content":" Reference Counting 是常见的垃圾回收算法，其核心思路是：将资源（比如对象）的被引用次数保存起来，当被引用次数为零时释放。该方法的局限性：当出现循环引用时，互相引用的对象不会被回收。  ","version":"Next","tagName":"h3"},{"title":"V8引擎的垃圾回收​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#v8引擎的垃圾回收","content":" V8 中有两个垃圾收集器。主要的 GC 使用 Mark-Compact 垃圾回收算法，从整个堆中收集垃圾。小型 GC 使用 Scavenger 垃圾回收算法，收集新生代垃圾。 ","version":"Next","tagName":"h3"},{"title":"常见的手写js场景整理","type":0,"sectionRef":"#","url":"/docs/interview/JS手写题集合","content":"","keywords":"","version":"Next"},{"title":"手写防抖函数​","type":1,"pageTitle":"常见的手写js场景整理","url":"/docs/interview/JS手写题集合#手写防抖函数","content":" 简单版本实现：  function debounce(func, wait) { let timeout; return function () { let context = this; // 保存this指向 let args = arguments; // 拿到event对象 clearTimeout(timeout) timeout = setTimeout(function(){ func.apply(context, args) }, wait); } }   防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：  function debounce(func, wait, immediate) { let timeout; return function () { let context = this; let args = arguments; if (timeout) clearTimeout(timeout); // timeout 不为null if (immediate) { let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发 timeout = setTimeout(function () { timeout = null; }, wait) if (callNow) { func.apply(context, args) } } else { timeout = setTimeout(function () { func.apply(context, args) }, wait); } } }   ","version":"Next","tagName":"h2"},{"title":"手写节流函数​","type":1,"pageTitle":"常见的手写js场景整理","url":"/docs/interview/JS手写题集合#手写节流函数","content":" 完成节流可以使用时间戳与定时器的写法  使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行  function throttled1(fn, delay = 500) { let oldtime = Date.now() return function (...args) { let newtime = Date.now() if (newtime - oldtime &gt;= delay) { fn.apply(null, args) oldtime = Date.now() } } }   使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行  function throttled2(fn, delay = 500) { let timer = null return function (...args) { if (!timer) { timer = setTimeout(() =&gt; { fn.apply(this, args) timer = null }, delay); } } }   可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下  function throttled(fn, delay) { let timer = null let starttime = Date.now() return function () { let curTime = Date.now() // 当前时间 let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间 let context = this let args = arguments clearTimeout(timer) if (remaining &lt;= 0) { fn.apply(context, args) starttime = Date.now() } else { timer = setTimeout(fn, remaining); } } }   ","version":"Next","tagName":"h2"},{"title":"手写new​","type":1,"pageTitle":"常见的手写js场景整理","url":"/docs/interview/JS手写题集合#手写new","content":" ","version":"Next","tagName":"h2"},{"title":"手写bind函数​","type":1,"pageTitle":"常见的手写js场景整理","url":"/docs/interview/JS手写题集合#手写bind函数","content":" ","version":"Next","tagName":"h2"},{"title":"手写promise​","type":1,"pageTitle":"常见的手写js场景整理","url":"/docs/interview/JS手写题集合#手写promise","content":"","version":"Next","tagName":"h2"},{"title":"浏览器端存储","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器的存储","content":"","keywords":"","version":"Next"},{"title":"cookie​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#cookie","content":" 辨别用户身份而存在，主要用于维持用户的状态 加密的 浏览器发送请求时，会自动携带 cookie，将其发送到服务端 浏览器关闭后清除 有大小数量限制4kb 当单个域名下的 cookie 超出限制后，再设置 cookie，浏览器就会清除以前设置的 cookie cookie使用场景  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。个性化设置（如用户自定义设置、主题等）。浏览器行为跟踪（如跟踪分析用户行为等）。  ","version":"Next","tagName":"h2"},{"title":"webStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#webstorage","content":" 主要是分为本地存储和会话存储，主要区别就是存在时间区别。  ","version":"Next","tagName":"h2"},{"title":"localStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#localstorage","content":" 很重要，是不会自动跟随请求携带，需要自行获取添加持久化存储，永不过期，除非手动删除，不会随浏览器关闭就消失通常5m只能存在同域名下，跨域名不可以使用  ","version":"Next","tagName":"h3"},{"title":"sessionStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#sessionstorage","content":" 不常用临时存储，浏览器关闭数据就会过期被清空不会跟随请求发送至服务器  ","version":"Next","tagName":"h3"},{"title":"indexDB​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#indexdb","content":" 浏览器端的数据库，跟一般数据库类似，存储大小基本以本地磁盘大小为准  可以使用dexie.js工具库来操作 查看dexie.js官方文档用于大量数据在客户端的存储 ","version":"Next","tagName":"h2"},{"title":"webpack相关面试题","type":0,"sectionRef":"#","url":"/docs/interview/webpack相关","content":"","keywords":"","version":"Next"},{"title":"如何优化weback的构建或打包速度？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#如何优化weback的构建或打包速度","content":" ","version":"Next","tagName":"h2"},{"title":"加快构建打包速度的方法​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#加快构建打包速度的方法","content":" 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)  通过 exclude、include 配置来确保转译尽可能少的文件优化 resolve.modules 配置优化 resolve.mainFields 配置aliasnoParseextensions  在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中使用 happypack 开启多进程打包除了使用 Happypack 外，我们也可以使用 thread-loader 开启多进程打包 loader使用 HardSourceWebpackPlugin 为模块提供中间缓存，第二次构建可大量节约时间使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包使用 webpack-parallel-uglify-plugin 开启 JS 多进程压缩  ","version":"Next","tagName":"h3"},{"title":"减少打包文件体积的方法​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#减少打包文件体积的方法","content":" 引入 webpack-bundle-analyzer 分析打包后的文件，判断哪些包还可以拆分和优化  使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间使用 optimization.splitChunks 配置抽离公共代码使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）使用 url-loader 或 image-webpack-loader 对图片进行转化或者压缩处理优化 SourceMap，开发环境推荐： cheap-module-eval-source-map，生产环境推荐：cheap-module-source-map按需加载，项目中的路由懒加载webpack自身的优化：  tree-shaking，在生产环境下，会自动移除没有使用到的代码scope hosting 作用域提升，变量提升，可以减少一些变量声明babel 配置的优化，配置 @babel/plugin-transform-runtime，重复使用 Babel 注入的帮助程序，以节省代码大小的插件  ","version":"Next","tagName":"h3"},{"title":"webpack如果使用了hash命名，那是每次都会重写生成hash吗？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#webpack如果使用了hash命名那是每次都会重写生成hash吗","content":" 要看webpack的配置（文件指纹，通过 output 中的 filename 设置），有三种情况：  如果是 hash 的话，是和整个项目有关的，有一处文件发生更改则所有文件的hash值都会发生改变且它们共用一个 hash 值； 如果是 chunkhash 的话，只和 entry 的每个入口文件有关，也就是同一个 chunk 下的文件有所改动该 chunk 下的文件的 hash 值就会发生改变 如果是 contenthash 的话，和每个生成的文件有关，只有当要构建的文件内容发生改变时才会给该文件生成新的 hash 值，并不会影响其它文件。  module.exports = { entry: { app: './scr/app.js', search: './src/search.js' }, output: { filename: '[name][chunkhash:8].js', path:__dirname + '/dist' }, // 通过 MiniCssExtractPlugin 插件设置 css 文件指纹 plugins:[ new MiniCssExtractPlugin({ filename: `[name][contenthash:8].css` }) ], module:{ // 通过 rules 配置图片的文件指纹设置 // 设置file-loader的name，使用hash。 rules:[{ test:/\\.(png|svg|jpg|gif)$/, use:[{ loader:'file-loader', options:{ name:'img/[name][hash:8].[ext]' } }] }] } }   ","version":"Next","tagName":"h2"},{"title":"关于文件监听原理呢​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#关于文件监听原理呢","content":" 在发现源码发生变化时，自动重新构建出新的输出文件。  Webpack开启监听模式，有两种方式：  启动 webpack 命令时，带上 --watch 参数在配置 webpack.config.js 中设置 watch:true  缺点：每次需要手动刷新浏览器  原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。  module.export = { // 默认false,也就是不开启 watch: true, // 只有开启监听模式时，watchOptions才有意义 watchOptions: { // 默认为空，不监听的文件或者文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行，默认300ms aggregateTimeout:300, // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次 poll:1000 } }   ","version":"Next","tagName":"h2"},{"title":"说一下 Webpack 的热更新原理吧​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#说一下-webpack-的热更新原理吧","content":" Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块  HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS（webpack-dev-server） 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。  后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。  ","version":"Next","tagName":"h2"},{"title":"代码分割的本质是什么？有什么意义呢？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#代码分割的本质是什么有什么意义呢","content":" 代码分割的本质其实就是在源代码直接上线和打包成唯一脚本 main.bundle.js 这两种极端方案之间的一种更适合实际场景的中间状态。  源代码直接上线：虽然过程可控，但是http请求多，性能开销大。  打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。  ","version":"Next","tagName":"h2"},{"title":"webpack中的 loader 和 plugin 有什么区别？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#webpack中的-loader-和-plugin-有什么区别","content":" loader 它是一个转换器，只专注于转换文件这一个领域，完成压缩、打包、语言编译，它仅仅是为了打包。并且运行在打包之前。Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。  而 plugin 是一个扩展器，它丰富了 webpack 本身，为其进行一些其它功能的扩展。它不局限于打包，资源的加载，还有其它的功能。所以它是在整个编译周期都起作用。  ","version":"Next","tagName":"h2"},{"title":"会手写loader吗？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#会手写loader吗","content":" loader 从本质上来说其实就是一个函数（webpack里是一个node模块）。将相关类型的文件代码(code)给它，根据我们设置的规则，经过它的一系列加工处理后还给我们加工好的代码。  loader 编写原则：  单一原则: 每个 Loader 只做一件事； 链式调用: Webpack 会按顺序链式调用每个 Loader； 统一原则: 遵循 Webpack 制定的设计规则和结构，输入（UTF-8 格式编码）与输出均为字符串，各个 Loader 完全独立，即插即用； Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用。  加载本地 Loader 方法:  Npm link ResolveLoader 案例：把 JavaScript 代码中的注释语法去除的 loader:  将 // @require '../style/index.css' 转换成 require('../style/index.css');  function replace(source) { // 使用正则把 // @require '../style/index.css' 转换成 require('../style/index.css'); return source.replace(/(\\/\\/ *@require) +(('|&quot;).+('|&quot;)).*/, 'require($2);'); } module.exports = function (content) { return replace(content); };   ","version":"Next","tagName":"h2"},{"title":"聊一聊Babel原理吧​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#聊一聊babel原理吧","content":" 大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：  解析：将代码转换成 AST  词法分析：将代码(字符串)分割为token流，即语法单元成的数组语法分析：分析token流(上面生成的数组)并生成 AST转换：访问 AST 的节点进行变换操作生产新的 AST。Taro就是利用 babel 完成的小程序语法转换生成：以新的 AST 为基础生成代码  ","version":"Next","tagName":"h2"},{"title":"webpack-dev-server的原理是什么？​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#webpack-dev-server的原理是什么","content":" webpack-dev-server启动了一个使用 express 的 Http 服务器，这个服务器与客户端采用 websocket 通信协议，当原始文件发生改变，webpack-dev-server 会实时编译。  webpack-dev-server 伺服的是资源文件，不会对 index.html 的修改做出反应  webpack-dev-server 生成的文件在内存中，因此不会呈现于目录中，生成路径由 content-base 指定，不会输出到 output 目录中。  默认情况下: webpack-dev-server 会在 content-base 路径下寻找 index.html作为首页  webpack-dev-server 不是一个插件，而是一个web服务器，所以不要想当然地将其引入  ","version":"Next","tagName":"h2"},{"title":"说说对 Vite 的理解和 Vite 的实现原理​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#说说对-vite-的理解和-vite-的实现原理","content":" Vite 是一个基于 ES 模块的开发服务器和构建工具，专为现代前端开发而设计。它的目标是提供快速的冷启动、按需编译和热模块替换等功能，以提供更好的开发体验。  Vite 的实现原理主要基于两个关键点：ES 模块和开发服务器。  ES 模块：Vite 利用了浏览器原生支持的 ES 模块特性。在开发过程中，Vite 不会像传统的打包工具一样将所有代码打包成一个或多个捆绑文件。相反，它会将每个单独的模块作为一个独立的文件提供。这样做的好处是可以避免整体打包的开销，使得开发过程更快速。  开发服务器：Vite 使用自己的开发服务器来提供开发环境。当您启动 Vite 时，它会在后台运行一个服务器，拦截浏览器对模块的请求。当浏览器请求一个模块时，Vite 会根据模块的路径动态地构建和返回该模块的内容。这种按需编译的方式使得只有在需要时才会编译相关的模块，从而加快了开发过程。  在开发过程中，Vite 还使用了 HMR（热模块替换）技术，使得在修改代码后，只需要替换相应的模块，而不需要刷新整个页面。这样可以实现非常快速的代码更新和实时预览。  总结起来，Vite 的实现原理可以概括为：利用浏览器原生的 ES 模块特性，按需编译和提供模块，配合开发服务器和 HMR 技术，实现快速的冷启动、按需编译和热模块替换等功能，从而提供更好的开发体验  ","version":"Next","tagName":"h2"},{"title":"Webpack 和 vite 有什么区别​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#webpack-和-vite-有什么区别","content":" Webpack和Vite是两个常用的前端构建工具，它们在一些方面有一些区别，下面是它们的一些主要区别：  构建速度：Vite在开发模式下具有更快的冷启动和热模块替换（HMR）速度。这是因为Vite利用了浏览器原生的ES模块特性，按需编译和提供模块，而不是像Webpack那样进行完整的打包。这使得Vite在开发过程中能够更快地构建和更新模块，提供更快的开发体验。  开发服务器：Vite使用自己的开发服务器，在开发模式下提供实时预览和快速的HMR。而Webpack通常需要借助webpack-dev-server或webpack-dev-middleware等插件来提供类似的开发服务器功能。  配置：Webpack的配置文件相对复杂，需要手动配置各种loader、plugin和optimization等选项来处理不同类型的文件和优化构建过程。而Vite的配置相对简单，大部分情况下不需要额外配置，它会根据文件类型自动选择合适的插件和优化策略。  生态系统：Webpack是一个非常成熟和强大的构建工具，拥有庞大的生态系统和丰富的插件支持，可以处理各种复杂的构建需求。Vite相对较新，生态系统相对较小，但它的发展速度很快，并且在Vue.js等框架中得到了广泛的应用和支持。  生产模式：Webpack在生产模式下提供更全面的打包和优化功能，可以生成高度优化的静态文件。Vite在生产模式下也能进行打包和优化，但相对于Webpack而言，Vite更加专注于开发体验和快速构建，因此在一些复杂的构建需求上可能需要额外的配置和插件支持。  总的来说，Webpack是一个功能强大且成熟的构建工具，适用于处理各种复杂的构建需求。Vite则专注于提供快速的开发体验和现代前端框架的支持，特别适合用于快速原型开发和中小型项目。选择使用哪个工具取决于项目的具体需求和个人偏好  ","version":"Next","tagName":"h2"},{"title":"说一下 vite 相对与 webpack 的优化​","type":1,"pageTitle":"webpack相关面试题","url":"/docs/interview/webpack相关#说一下-vite-相对与-webpack-的优化","content":" Vite相对于Webpack在性能和开发体验上进行了一些优化，下面是一些Vite相对于Webpack的优化点：  快速的冷启动：Vite利用了浏览器原生的ES模块特性，按需编译和提供模块，避免了完整的打包过程。这使得Vite在启动项目时可以更快地构建和启动开发服务器，减少了冷启动的时间。  快速的热模块替换（HMR）：Vite通过浏览器原生的ES模块特性实现了更快速的HMR。它可以在开发过程中快速更新修改的模块，而无需重新加载整个应用程序。这提供了更快的开发体验，可以立即看到代码更改的效果。  按需编译：Vite只编译需要的模块，而不是像Webpack那样对整个项目进行完整的打包。这减少了不必要的编译时间，特别是在大型项目中，只有修改的模块才会重新编译，提高了开发效率。  原生ES模块支持：Vite直接使用浏览器原生的ES模块加载机制，而不需要进行模块转换和打包。这减少了构建过程中的处理和转换时间，提供了更快的构建速度。  静态资源优化：Vite在生产模式下对静态资源进行了优化，例如自动压缩代码、提供按需加载和预加载等功能。这有助于减小生成的静态文件的大小，提高应用程序的加载速度和性能。  需要注意的是，Vite并不是取代Webpack，而是在开发过程中提供了更快速的开发体验。在生产环境中，Vite会使用Rollup等工具进行完整的打包和优化，以生成适用于生产环境的静态文件。因此，在一些复杂的构建需求和生态系统支持方面，Webpack仍然是一个更全面和成熟的选择。 ","version":"Next","tagName":"h2"},{"title":"http1.1和http2.0","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/http1.1和http2.0","content":"","keywords":"","version":"Next"},{"title":"http1.1相比于http1.0改进​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http11相比于http10改进","content":" HTTP/1.1 相比于 HTTP/1.0 的改进和优化主要包含：持久连接、HTTP 管道化请求、分块编码传输、新增 host 头字段、缓存支持、更多状态码等。断点续传、并行下载  ","version":"Next","tagName":"h2"},{"title":"http1.1缺点​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http11缺点","content":" 队头阻塞虽然在 HTTP1.1 中增加了持久连接，能在一次 TCP 连接中发送和接收多个 HTTP 请求/响应，但是在一个管道中同一时刻只能处理一个请求，所以如果上一个请求未完成，后续的请求都会被阻塞。头部冗余HTTP 请求每次都会带上请求头，若此时 cookie 也携带大量数据时，就会使得请求头部变得臃肿。TCP 连接数限制浏览器对于同一个域名，只允许同时存在若干个 TCP 连接（根据浏览器内核有所差异），若超过浏览器最大连接数限制，后续请求就会被阻塞。  ","version":"Next","tagName":"h2"},{"title":"http2优化​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http2优化","content":" header的压缩允许服务端主动推送多路复用二进制分帧层 ","version":"Next","tagName":"h2"},{"title":"浏览器跨域","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器跨域","content":"","keywords":"","version":"Next"},{"title":"如何解决跨域问题？​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#如何解决跨域问题","content":" ","version":"Next","tagName":"h2"},{"title":"CORS​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#cors","content":" (Cross-Origin Resource Sharing) 最为常见的解决方案，在服务端进行配置，不用前端操作。CORS 将请求分为简单请求（Simple Requests）和需预检请求（Preflighted requests）方案依赖服务端/后端在响应头中添加 Access-Control-Allow-* 头，告知浏览器端通过此请求。  简单请求  不会触发预检请求的称为简单请求。当请求满足以下条件时就是一个简单请求： ● 请求方法：GET、HEAD、POST。 ● 请求头：Accept、Accept-Language、Content-Language、Content-Type。  ○ Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain。  需预检请求  当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个 OPTIONS 请求，通过服务端返回的 Access-Control-Allow-* 判定请求是否被允许。  CORS 引入了以下几个以 Access-Control-Allow-* 开头：  ● Access-Control-Allow-Origin 表示允许的来源  ● Access-Control-Allow-Methods 表示允许的请求方法  ● Access-Control-Allow-Headers 表示允许的请求头  ● Access-Control-Allow-Credentials 表示允许携带认证信息  当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。  ","version":"Next","tagName":"h3"},{"title":"反向代理​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#反向代理","content":" 服务端进行配置，nginx  ","version":"Next","tagName":"h3"},{"title":"JSONP​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#jsonp","content":" JSONP 的原理是利用了浏览器加载 JavaScript 资源文件时不受同源策略的限制而实现的 ","version":"Next","tagName":"h3"},{"title":"浏览器渲染原理","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器渲染原理","content":"","keywords":"","version":"Next"},{"title":"Parse解析阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#parse解析阶段","content":" 主要流程：  Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如 &lt;html&gt;, &lt;body&gt;）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。  解析html文档构建dom树（一个个的dom对象）加载次级的资源，比如img、外部的css文件、js文件、字体文件等。存在预解析器用来下载和加载css去扫描这些文件。 遇到js文件时可能会阻塞解析流程，要停止html解析去下载加载&lt;script&gt;标签的内容，可使用async和defer来优化  ","version":"Next","tagName":"h2"},{"title":"Style样式计算​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#style样式计算","content":" Recalculate Style 计算样式阶段  CSS 引擎处理样式的过程分为三个阶段：  收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。css引擎会遍历dom节点做匹配，将css样式解析出来加到对应的标签上。构建cssom树，与构建dom树并行构建，不会影响dom树的构建，但会阻塞js的执行，因为js可能会操作样式。在进入下一阶段之前，cssom树必须全部构建完毕。所以cssom会阻塞渲染过程。在大型网站中，会存在大量的 CSS 规则，如果为每个节点都保存一份样式值，会导致内存消耗过大。作为替代，CSS 引擎通常会创建共享的样式结构，计算样式对象一般有指针指向相同的共享结构  ","version":"Next","tagName":"h2"},{"title":"Layout构建排列​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#layout构建排列","content":" Layout排列阶段，创建Layout树（RenderObject渲染对象）  有了dom树和对应的样式计算之后，浏览器会将这些信息构建成一个layout树，构建所有可见的dom节点，以及每个节点的所有样式信息  layout树和dom树不一定是一一对应的，构建layout树主要是以下流程  从 DOM 树的根节点开始遍历每个可见节点。 ○ 某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。 ○ 某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。 ○ 为伪元素创建 LayoutObject。 ○ 为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。 dom树+cssom树 = renderTree  构建完之后，浏览器开始做布局计算，计算在浏览器中的位置和大小。计算盒模型的大小和位置；块元素、行类元素、浮动元素等；计算文字的大小位置、滚动区域等；  浏览器的布局计算工作包含以下内容：  根据 CSS 盒模型及视觉格式化模型，计算每个元素的各种生成盒的大小和位置。计算块级元素、行内元素、浮动元素、各种定位元素的大小和位置。计算文字，滚动区域的大小和位置。LayoutObject 有两种类型： ○ 传统的 LayoutObject 节点，会把布局运算的结果重新写回布局树中。 ○ LayoutNG（Chrome 76 开始启用） 节点的输出是不可变的，会保存在 NGLayoutResult 中，这是一个树状的结构，相比之前的 LayoutObject，少了很大回溯计算，提高了性能。  ","version":"Next","tagName":"h2"},{"title":"Paint绘制阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#paint绘制阶段","content":" Paint 阶段将 LayoutObject 树转换成供合成器使用的高效渲染格式 构建PaintLayer 绘制图层 （RenderLayer树）  构建完成的 LayoutObject 树还不能拿去显示，因为它不包含绘制的顺序（z-index）。同时，也为了考虑一些复杂的情况，如 3D 变换、页面滚动等，浏览器会对上一步的节点进行分层处理。这个处理过程被称为建立层叠上下文  浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。 构建 cc::Layer 与 display items  ","version":"Next","tagName":"h2"},{"title":"Composite合成阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#composite合成阶段","content":" 光栅化、draw，绘制生成的图层。利用gpu进行渲染绘图。 raster（光栅化）是将 display item 中的绘制操作转换为位图的过程。 当所有的 tiles 都完成光栅化后，会生成 draw quads（绘制四边形）。每个 draw quads 是包含一个在屏幕特定位置绘制 tile 的命令，该命令同时考虑了所有应用到 layer tree 的变换。每个四边形引用了内存中 tile 的光栅化输出。四边形被包裹在合成帧对象（compositor frame object）中，然后提交（submit）到浏览器进程。  合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。  指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。  变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因  合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 ","version":"Next","tagName":"h2"},{"title":"Jest 自动化测试","type":0,"sectionRef":"#","url":"/docs/notes/前端工程化/Jest自动化测试","content":"","keywords":"","version":"Next"},{"title":"Jest优点和基本环境搭建​","type":1,"pageTitle":"Jest 自动化测试","url":"/docs/notes/前端工程化/Jest自动化测试#jest优点和基本环境搭建","content":" 主流框架有：Jasmine、Mocha、Jest  优点  比较新、基础好、速度快、API简单、隔离性好、IDE整合（vscode）、多项目运行、可以导出覆盖率  环境搭建  nodenpmnpm initnpm i jest -D ","version":"Next","tagName":"h2"},{"title":"浏览器相关","type":0,"sectionRef":"#","url":"/docs/interview/浏览器相关","content":"","keywords":"","version":"Next"},{"title":"概述从输入 URL 到页面呈现的全过程？​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#概述从输入-url-到页面呈现的全过程","content":" URL 解析 → DNS 查询 → TCP 握手 → TLS 握手 → 发送请求 → 服务器响应 → 解析 HTML → 构建 DOM → 解析 CSS → 构建 CSSOM → 执行 JS → 合并渲染树 → 布局 → 绘制 → 合成 → 页面呈现   URL 解析与输入处理 协议补全：浏览器自动补全协议（如 http:// 或 https://）。  安全检查：检查 URL 是否合法，是否触发黑名单（如恶意网站）。  HSTS 检查：若域名在 HSTS 预加载列表中，强制使用 HTTPS。  DNS 解析  本地缓存查询：依次检查浏览器缓存 → 系统（hosts 文件）→ 路由器缓存。  递归查询：若本地无缓存，向 DNS 服务器发起请求（如 8.8.8.8），直到找到域名对应的 IP。  建立网络连接  TCP 三次握手：客户端与服务器通过三次握手建立 TCP 连接。  TLS 握手（HTTPS）：若使用 HTTPS，需额外进行 TLS 握手（协商加密算法、交换密钥等）。  发送 HTTP 请求  构造请求报文：浏览器生成 HTTP 请求，包含请求行（方法、URL）、请求头（Cookie、UA 等）、请求体（POST 数据）。  发送请求：通过 TCP 连接发送到服务器。  服务器处理请求  负载均衡：请求可能被反向代理（如 Nginx）转发到后端服务器集群。  处理请求：服务器解析请求，执行业务逻辑（如查询数据库）。  生成响应：返回 HTTP 响应（状态码、响应头、响应体如 HTML 文件）。  浏览器接收响应  解析状态码：处理 3xx（重定向）、4xx/5xx（错误）等。  缓存策略：根据响应头（Cache-Control、ETag 等）决定是否缓存资源。  Content-Type 处理：根据 Content-Type（如 text/html）选择解析方式。  解析与渲染 加载后续资源  延迟加载：按需加载图片、字体等非关键资源（如 &lt;img loading=&quot;lazy&quot;&gt;）。  异步执行：通过defer/async延迟 JS 执行，避免阻塞渲染。  最终呈现  触发事件：页面触发 DOMContentLoaded（DOM 解析完成）和 load（所有资源加载完成）事件。  持续更新：通过AJAX/WebSocket动态更新内容，触发重排/重绘。  关键点： 减少 DNS 查询：使用 DNS 预解析（&lt;link rel=&quot;dns-prefetch&quot;&gt;）。  复用连接：HTTP/2 多路复用、Keep-Alive 保持 TCP 连接。  资源优化：压缩文件（Gzip/Brotli）、图片懒加载、CDN 加速。  渲染优化：避免强制同步布局、减少重排重绘、使用 requestAnimationFrame。  ","version":"Next","tagName":"h2"},{"title":"浏览器报错状态码304是什么意思？​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#浏览器报错状态码304是什么意思","content":" 当浏览器返回 HTTP 状态码 304 时，表示 资源未修改（Not Modified），这并非错误，而是服务器告知客户端可以直接使用本地缓存的副本，无需重新下载资源。  协商缓存（304 Not Modified）：需向服务器发起验证请求，确认缓存有效性。资源未修改，协商缓存验证通过。  ","version":"Next","tagName":"h2"},{"title":"聊一下浏览器缓存，强缓存和协商缓存的区别?​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#聊一下浏览器缓存强缓存和协商缓存的区别","content":" 说说你知道的浏览器缓存，项目中是如何实践的（叠纸、百度、小米）  浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存主要分为强缓存（也称本地缓存）和协商缓存（也称弱缓存）。  强缓存 当请求资源的时，如果是之前请求过的并使用强缓存，那么在过期时间内将不会发送本次请求向服务器获取资源，而是直接从浏览器缓存中获取（不管资源是否改动）。过期了将重新从服务器获取，并再次强缓存。 协商缓存 当请求资源时，如果是之前请求过的并使用协商缓存，还是发送请求到服务器，服务器通过逻辑判断确认资源没有修改返回304状态码，那么本次的资源则是从缓存中获取；如果经过判断确认资源被修改过，则重新发送资源到客户端，并且客户端更新缓存。  ","version":"Next","tagName":"h2"},{"title":"浏览器的渲染机制原理是什么？​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#浏览器的渲染机制原理是什么","content":" 浏览器的整个渲染过程  解析 HTML，构建 DOM 树解析 CSS，生成 CSS 规则树合并 DOM 树和 CSS 规则树，生成 render（渲染）树。布局 render 树（回流 / 重排），负责各元素尺寸、位置的计算。绘制 render 树（painting 重绘），绘制页面像素信息浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite）显示在屏幕上。  构建渲染树时，浏览器主要完成以下工作  从 DOM 树的根节点开始遍历每个可见节点对每个可见节点，找到 CSS 规则树中对应的规则，并应用它们根据每个可见节点以及其对应的样式，组合生成渲染树  不可见节点（也就是不会出现在渲染树中的节点）  一些不会渲染输出的节点（如：script、meta、link 等）一些通过 css 进行隐藏的节点（如：display: none）。不过要注意：visiblity 和 opacity 隐藏的节点是会显示在渲染树上的。  浏览器接收到 HTML 文件并转换为 DOM 树  当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。  当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。  那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。  当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。  以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。  字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM  当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件。  将 CSS 文件转换为 CSSOM 树  其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的  字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSOM  在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。  如果你有点不理解为什么会消耗资源的话，我这里举个例子  &lt;div&gt; &lt;a&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;style&gt; span { color: red; } div &gt; a &gt; span { color: red; } &lt;/style&gt;   对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平  生成渲染树  当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。  在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。  当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。  为什么操作dom会慢，或者使用框架的时候尽量不要操作dom？  想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？  因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。  如果插入几万个 DOM，如何实现页面不卡顿？  对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 requestAnimationFrame 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。  这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。  从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。如果你想了解更多的内容可以了解下这个 react-virtualized  什么情况阻塞渲染  首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。  然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。  当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。  当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。  对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染  ##关于重绘（repaint）和回流（reflow） 重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。  重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘回流是布局或者几何属性需要改变就称为回流  回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。  以下几个动作可能会导致性能问题：  改变 window 大小改变字体添加或删除样式文字改变定位或者浮动盒模型  并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。  当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。判断是否触发了 media query更新动画并且发送事件判断是否有全屏操作事件执行 requestAnimationFrame 回调执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。  既然我们已经知道了重绘和回流会影响性能，那么接下来我们将会来学习如何减少重绘和回流的次数：  使用 transform 替代 top  &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;style&gt; .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } &lt;/style&gt; &lt;script&gt; setTimeout(() =&gt; { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) &lt;/script&gt;   使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局不要把节点的属性值放在一个循环里当成循环里的变量  for(let i = 0; i &lt; 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) }   不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrameCSS 选择符从右往左匹配查找，避免节点层级过多,可以直接使用id选择器或类选择器将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层（will-change`\\`）  在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面，也就是常说的关键渲染路径，这部分也是性能优化中的一块内容。  首先你可能会疑问，那怎么测量到底有没有加快渲染速度呢?  当发生 DOMContentLoaded 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系了。  提示如何加速：  从文件大小考虑从 script 标签使用上来考虑从 CSS、HTML 的代码书写上来考虑从需要下载的内容是否需要在首屏使用上来考虑  ","version":"Next","tagName":"h2"},{"title":"浏览器跨域问题​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#浏览器跨域问题","content":" 浏览器为什么要阻止跨域请求？如何解决跨域？每次跨域请求都需要到达服务端吗？  什么是跨域  跨域是针对浏览器的“同源策略”提出的说法。之所以有“同源策略”这种模式是基于网络安全方面的考虑。所谓的同源策略关注三点：  协议 (http:www.baidu.com &amp; https.www.baidu.com http 协议不同，跨域) 域名 (https://www.aliyun.com &amp; https://developer.aliyun.com 域名不同，跨域) 端口 (http://localhost:8080 &amp; http://localhost:8000 端口号不同，跨域)  哪些网络资源涉及到跨域  “同源策略”对于跨域网络资源的设定非常的清晰。这些场景涉及到跨域禁止操作：  无法获取非同源网页的 cookie、localstorage 和 indexedDB。无法访问非同源网页的 DOM （iframe）。 +无法向非同源地址发送 AJAX 请求 或 fetch 请求（可以发送，但浏览器拒绝接受响应）。  为什么要阻止跨域呢？上文我们说过是基于安全策略：比如一个恶意网站的页面通过 iframe 嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的 javascript 脚本就可以在用户登录银行的时候获取用户名和密码。  如何解决跨域  通过 jsonp 跨域document.domain + iframe 跨域location.hash + iframewindow.name + iframe 跨域postMessage 跨域跨域资源共享（CORS）nginx 代理跨域nodejs 中间件代理跨域WebSocket 协议跨域  ","version":"Next","tagName":"h2"},{"title":"JSONP 的原理是什么？​","type":1,"pageTitle":"浏览器相关","url":"/docs/interview/浏览器相关#jsonp-的原理是什么","content":" 尽管浏览器有同源策略，但是 &lt;script&gt; 标签的src属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求  实现原理:  创建 callback 方法插入 script 标签后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法前端执行服务端返回的方法调用  function jsonp ({url, params, callback}) { return new Promise((resolve, reject) =&gt; { // 创建 script 标签 let script = document.createElement('script') // 将函数挂在 window 上 window[callback] = function (data) { resolve(data) // 代码执行后，删除 script 标签 document.body.removeChild(script) } // 回调函数加在请求地址上 params = {...params, callback} // wb=b&amp;callback=show let arrs = [] for (let key in params) { array.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&amp;')}` document.body.appendChild(script) }) } //具体使用 function show(data) { console.log(data) } jsonp({ url: 'http://localhost:3000/show', params:{ // code 参数 }, callback: 'show' }).then(data =&gt; { console.log(data) })  ","version":"Next","tagName":"h2"},{"title":"算法入门","type":0,"sectionRef":"#","url":"/docs/notes/算法/算法入门","content":"","keywords":"","version":"Next"},{"title":"什么是算法​","type":1,"pageTitle":"算法入门","url":"/docs/notes/算法/算法入门#什么是算法","content":" 在我们的生活中也处处存在着算法(algorithm)，算法是专注于解决问题的过程和方法。既然提到了算法是解决问题的方法，哪方法也是有好有坏的，算法是在特定问题下解决问题的方法，证明一个算法的好坏，就要看它的时间复杂度和空间复杂度。  时间复杂度：代码运行完要多少时间  空间复杂度：代码运算占用内存的大小  可以拿空间复杂度换时间复杂度，只要空间复杂度不太离谱就行  ","version":"Next","tagName":"h2"},{"title":"","type":1,"pageTitle":"算法入门","url":"/docs/notes/算法/算法入门##","content":"","version":"Next","tagName":"h2"},{"title":"前端设计模式","type":0,"sectionRef":"#","url":"/docs/notes/设计模式/A设计原则","content":"","keywords":"","version":"Next"},{"title":"设计原则​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#设计原则","content":" 单一职责原则：功能要单一，不能什么功能都往类里面写开放封闭原则：对外扩展开放，对修改进行封闭，可以进行功能扩展，但是不能修改或减少功能里是替换原则依赖倒置原则：非常重要。上层功能不应该依赖下层的实现接口分离原则  ","version":"Next","tagName":"h2"},{"title":"设计模式考量的因素​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#设计模式考量的因素","content":" 有利于代码的复用有利于代码的稳定可拓展有利于代码的可读性的提升  前人给出的一套编写代码的方法论  ","version":"Next","tagName":"h2"},{"title":"掌握程度​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#掌握程度","content":" 上层建筑式的知识，比较抽象，不仅仅是知道概念！  什么是设计模式？ =&gt; 开发过程中有使用设计模式的概念清楚概念本身 =&gt; 去除空洞的概念。了解设计模式的基本分类、常见的设计模式类型适用场景不同的场景下关联到对应的设计模式 =&gt; 不能滥用设计模式，不要硬用设计模式过度设计。在模式和需求关系之间要做取舍 ","version":"Next","tagName":"h2"},{"title":"React面试题","type":0,"sectionRef":"#","url":"/docs/interview/React面试题","content":"","keywords":"","version":"Next"},{"title":"react hooks与class组件的区别在于什么？​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react-hooks与class组件的区别在于什么","content":" Hook 增加了函数式组件中 state 的使用，在之前函数式组件是无法拥有自己的状态，只能通过 props 以及 context 来渲染自己的 UI，而在业务逻辑中，有些场景必须要使用到 state，那么我们就只能将函数式组件定义为 class 组件。而现在通过 Hook，我们可以轻松的在函数式组件中维护我们的状态，不需要更改为 class 组件。  类组件的不足:  状态逻辑难以复用缺少复用机制渲染属性和高阶组件会导致层级冗余趋向复杂难以维护生命周期函数混杂不相干逻辑相干逻辑分散在不同生命周期函数中this 指向困扰内联函数过度创建新句柄类成员函数不能保证 this  函数式组件（hooks）的优势：  优化类组件的三大问题函数组件无 this 问题自定义 Hook 方便复用状态逻辑副作用的关注点分离  ","version":"Next","tagName":"h2"},{"title":"setState到底是异步还是同步?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#setstate到底是异步还是同步","content":" setState并不是单纯的异步或同步，这其实与调用时的环境相关  setState只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新  ","version":"Next","tagName":"h2"},{"title":"为什么不能条件使用 react hooks?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#为什么不能条件使用-react-hooks","content":" 确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。  ","version":"Next","tagName":"h2"},{"title":"React组件通信如何实现?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react组件通信如何实现","content":" 父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信 跨层级通信: Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,\b对于跨越多层的全局数据通过Context通信再适合不过 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入 event 模块进行通信 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态  ","version":"Next","tagName":"h2"},{"title":"你用过那些hooks？常用的hooks有哪些？​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#你用过那些hooks常用的hooks有哪些","content":" useState: useState 是最常用的 Hook 之一，它允许您在函数组件中使用状态。它返回一个状态值和一个更新状态的函数。您可以使用数组解构来获取这两个值。例如：const [count, setCount] = useState(0); useEffect: useEffect 允许您在组件渲染后执行副作用操作，比如订阅数据、处理 DOM 操作等。它接收一个回调函数和一个依赖数组，用于指定在哪些依赖项发生变化时触发副作用。例如：useEffect(() =&gt; { // 副作用操作 }, [dependency]); useContext: useContext 允许您在函数组件中访问 React 的上下文（context）。它接收一个上下文对象（通过 React.createContext 创建），并返回当前上下文的值。例如：const value = useContext(MyContext); useReducer: useReducer 是 useState 的替代方案，用于管理复杂的状态逻辑。它接收一个 reducer 函数和初始状态，并返回当前状态和一个 dispatch 函数用于触发状态更新。例如：const [state, dispatch] = useReducer(reducer, initialState); useRef: useRef 返回一个可变的 ref 对象，可以在多次渲染之间保持稳定。它通常用于获取 DOM 元素的引用或保存任意可变值。例如：const refContainer = useRef(initialValue); useCallback: useCallback 用于优化函数的性能，它返回一个记忆化的函数。当依赖项发生变化时，它会返回一个新的函数引用，否则会返回之前缓存的函数引用。例如：const memoizedCallback = useCallback(() =&gt; { // 函数体 }, [dependency]); useMemo: useMemo 用于优化计算的性能，它返回一个记忆化的值。当依赖项发生变化时，它会重新计算值，否则会返回之前缓存的值。例如：const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);  ","version":"Next","tagName":"h2"},{"title":"说说你对HOC(高阶组件)的了解​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#说说你对hoc高阶组件的了解","content":" 高阶组件不是组件，是增强函数，可以输入一个元组件，返回出一个新的增强组件； 高阶组件的主要作用有:  代码重用，逻辑和引导抽象渲染劫持状态抽象和控制Props 控制  用法:  属性代理 (Props Proxy): 返回出一个组件，它基于被包裹组件进行 功能增强；  //默认参数: 可以为组件包裹一层默认参数； function proxyHoc(Comp) { return class extends React.Component { render() { const newProps = { name: 'tayde', age: 1, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } //提取状态: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件: function withOnChange(Comp) { return class extends React.Component { constructor(props) { super(props) this.state = { name: '', } } onChangeName = () =&gt; { this.setState({ name: 'dongdong', }) } render() { const newProps = { value: this.state.name, onChange: this.onChangeName, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } // 使用姿势如下，这样就能非常快速的将一个 Input 组件转化成受控组件。 const NameInput = props =&gt; (&lt;input name=&quot;name&quot; {...props} /&gt;) export default withOnChange(NameInput)   包裹组件: 可以为被包裹元素进行一层包装  function withMask(Comp) { return class extends React.Component { render() { return ( &lt;div&gt; &lt;Comp {...this.props} /&gt; &lt;div style={{ width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, .6)', }} &lt;/div&gt; ) } } }   反向继承：返回出一个组件，继承于被包裹组件，常用于以下操作:  function IIHoc(Comp) { return class extends Comp { render() { return super.render(); } }; }   渲染劫持 (Render Highjacking)，例如条件渲染  function withLoading(Comp) { return class extends Comp { render() { if(this.props.isLoading) { return &lt;Loading /&gt; } else { return super.render() } } }; }   操作状态 (Operate State): 可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用  高阶组件的应用场景：  权限控制，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染  function withAdminAuth(WrappedComponent) { return class extends React.Component { constructor(props){ super(props) this.state = { isAdmin: false, } } async componentWillMount() { const currentRole = await getCurrentUserRole(); this.setState({ isAdmin: currentRole === 'Admin', }); } render() { if (this.state.isAdmin) { return &lt;Comp {...this.props} /&gt;; } else { return (&lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;/div&gt;); } } }; }   性能监控，包裹组件的生命周期，进行统一埋点:  function withTiming(Comp) { return class extends Comp { constructor(props) { super(props); this.start = Date.now(); this.end = 0; } componentDidMount() { super.componentDidMount &amp;&amp; super.componentDidMount(); this.end = Date.now(); console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`); } render() { return super.render(); } }; }   代码复用，可以将重复的逻辑进行抽象。  ","version":"Next","tagName":"h2"},{"title":"redux的数据流工作流程​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#redux的数据流工作流程","content":" 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。  然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State  State一旦有变化，Store就会调用监听函数，来更新View。  ","version":"Next","tagName":"h2"},{"title":"React 中 useeffect 和 uselayouteffect 区别​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react-中-useeffect-和-uselayouteffect-区别","content":" 在 React 中，useEffect 和 useLayoutEffect 都是用于处理组件的副作用（side effects）的钩子函数，它们之间的主要区别在于触发时机和执行顺序。  useEffect：  useEffect 是在组件渲染完成后异步执行的钩子函数。它不会阻塞组件的渲染过程，即它会在浏览器完成绘制后执行。通常用于处理需要异步执行的副作用，比如数据获取、订阅事件、定时器等。useEffect 的回调函数在组件每次渲染时都会执行，除非指定依赖项（dependency），否则会在每次渲染后都触发。  useLayoutEffect：  useLayoutEffect 是在组件渲染完成后同步执行的钩子函数。它会在浏览器执行绘制之前执行，即在浏览器更新屏幕之前执行。通常用于处理需要同步执行的副作用，比如 DOM 操作、测量元素尺寸等。useLayoutEffect 的回调函数在组件每次渲染时都会执行，类似于 useEffect，但它会在浏览器更新屏幕之前执行。  总结区别：  useEffect 是在浏览器完成绘制后异步执行，而 useLayoutEffect 是在浏览器更新屏幕之前同步执行。useEffect 不会阻塞组件的渲染过程，而useLayoutEffect可能会导致阻塞，因为它会在浏览器更新屏幕之前执行。一般情况下，应优先使用 useEffect，除非需要在浏览器更新屏幕之前同步执行一些操作，才考虑使用 useLayoutEffect。 需要注意的是，过度使用useLayoutEffect可能会导致性能问题，因为它会阻塞组件的渲染过程。因此，在大多数情况下，推荐使用useEffect 来处理副作用。只有在需要确保某些操作在浏览器更新屏幕之前同步执行时，才使用 useLayoutEffect。  ","version":"Next","tagName":"h2"},{"title":"react的 setstate 过程​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react的-setstate-过程","content":" 在 React 中，setState 是用于更新组件状态的方法。当调用 setState 时，React 会进行以下一般性的更新过程：  合并更新：React 将传入的更新对象（可以是一个新的状态值或一个更新函数）与当前状态进行合并。它不会立即执行更新，而是将更新放入待处理的更新队列中。  批量更新：React 会将多个连续的 setState 调用合并为一个批量更新操作，以提高性能。在批量更新期间，React 不会立即更新组件，而是将所有更新推迟到后续的阶段。  准备更新：在进行实际更新之前，React 会执行一些准备工作。它会检查是否处于批量更新模式，以确定是否需要合并更新。如果在 React 事件处理程序、生命周期方法或异步代码中调用了 setState，React 会自动启动批量更新模式。  触发重新渲染：在准备更新阶段后，React 会触发组件的重新渲染过程。它会比较前后两次渲染的虚拟 DOM 树，找出需要更新的部分，并进行相应的 DOM 操作。  执行生命周期方法：在重新渲染过程中，React 会按照生命周期的顺序调用相应的方法，如 componentDidUpdate。  需要注意的是，由于 setState 是异步的，React 可能会对多个 setState 调用进行批量处理，以提高性能  ","version":"Next","tagName":"h2"},{"title":"react diff 和 fiber 算法的区别是什么​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react-diff-和-fiber-算法的区别是什么","content":" React 的 Diff 算法和 Fiber 算法是 React 在不同版本中使用的两种不同的算法。  Diff 算法：  Diff 算法是 React 早期版本使用的一种协调算法，也被称为 Reconciliation（协调）算法。Diff 算法的主要思想是通过比较前后两次渲染的虚拟 DOM 树，找出需要更新的部分，并进行相应的 DOM 操作。Diff 算法是一种递归算法，会遍历整个虚拟 DOM 树，进行全量比较，然后进行更新。Diff 算法的缺点是当组件层级较深或组件数量较多时，比较和更新的成本会较高，可能会导致性能问题。  Fiber 算法：  Fiber 算法是 React 16 版本引入的一种新的协调算法，旨在提高 React 的渲染性能和用户响应度。Fiber 算法通过引入 Fiber 数据结构，将渲染过程分解为可中断的单元，使得 React 可以在渲染过程中优先处理高优先级的任务。Fiber 算法使用了一种增量渲染的方式，将渲染过程分为多个阶段，每个阶段可以根据优先级进行调度和中断。Fiber 算法通过优先级调度、时间切片和任务分片等技术，使得 React 能够更好地控制渲染过程，提高用户体验。Fiber 算法还支持并发模式，可以在多个线程上进行渲染，进一步提升性能。错误处理:在Fiber中,一次渲染过程中的错误不会致命。React可以捕获错误,暂停一次更新,在不破坏整个应用的情况下显示错误信息。  总结： Diff 算法是 React 早期版本使用的一种全量比较的算法，而 Fiber 算法是 React 16 版本引入的一种增量渲染的算法。Fiber 算法通过引入 Fiber 数据结构和优先级调度等机制，提高了 React 的渲染性能和用户响应度。Fiber 算法还支持并发模式，可以在多个线程上进行渲染。相比之下，Fiber 算法在性能和用户体验方面有明显的优势。  ","version":"Next","tagName":"h2"},{"title":"什么场景下需要使用 immutable​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#什么场景下需要使用-immutable","content":" Immutable 数据是指一旦创建就不能被修改的数据。在以下场景下，使用 Immutable 数据可以带来一些好处：  状态管理：在状态管理库（如 Redux，Redux要求State必须是immutable的，可以利用immutable优化性能。）中，使用 Immutable 数据可以确保状态的不可变性。这样可以避免状态被直接修改，提高状态的可预测性和可维护性。  函数式编程：Immutable 数据是函数式编程的重要概念之一。函数式编程鼓励使用纯函数和不可变数据，以避免副作用和共享状态。使用 Immutable 数据可以更轻松地实现函数式编程的思想。  性能优化：由于 Immutable 数据不可变，可以使用结构共享和持久化数据结构来优化性能。通过共享相同的数据结构，可以减少内存占用和提高数据操作的效率。  并发和多线程：在并发和多线程环境下，使用 Immutable 数据可以避免竞态条件和数据冲突。由于数据不可变，不需要担心数据被同时修改的问题，从而简化了并发编程的复杂性。  缓存和缓存一致性：Immutable 数据可以作为缓存键或缓存值使用。由于数据不可变，可以在缓存中安全地存储和共享，而不必担心数据被修改导致的缓存一致性问题。  需要注意的是，使用 Immutable 数据也会带来一些开销，因为每次更新数据都需要创建新的对象。在某些场景下，如果频繁地进行大量的数据更新操作，可能会导致性能下降。因此，在选择是否使用 Immutable 数据时，需要权衡其带来的好处和性能开销，并根据具体情况进行决策。  ","version":"Next","tagName":"h2"},{"title":"react性能优化的方案手段有哪些？​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react性能优化的方案手段有哪些","content":" react 性能优化 这里只说 react 单独的进行的性能优化：  keyshouldComponentUpdatepureComponent关于箭头函数，先声明好事件监听函数后，然后再拿到其引用传给组件:useCallback(大计算量的函数来)useMemoReact.Memo不可变数据 ImmutablereselectReact.lazy 按需加载  查看更多详细方案  如果一定要做性能优化，核心还是在减少频繁计算和渲染上，在实现策略上主要有三种方式：利用key维持组件结构稳定性、优化数据比对过程和按需加载。其中优化数据比对过程可以根据具体使用的场景，分别使用缓存数据或组件、改用Immutable不可变数据等方式进行。最后，也一定记得要采用测试工具进行前后性能对比，来保障优化工作的有效性。 ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/notes/前端工程化/Webpack学习笔记","content":"","keywords":"","version":"Next"},{"title":"核心工作过程​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#核心工作过程","content":" 在项目中会散落很多文件.js.html.css.less.png.json.jpg 等，webpack cli 启动打包流程，载入核心模块，创建compiler对象，开始进行编译。通过打包入库 index.js 开始解析，每个资源模块需要的依赖模块，形成项目中所有文件间的一个依赖个关系树。有了关系树之后开始递归遍历这个依赖树，然后找到每个模块需要的加载器去加载，加载到结果放到 bundle.js 里面，实现整个项目的打包。其中 loader 机制起到很重要的作用，有了 loader 起到所有资源的加载。    ","version":"Next","tagName":"h2"},{"title":"Loader​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#loader","content":" ","version":"Next","tagName":"h2"},{"title":"Loader 工作原理​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#loader-工作原理","content":" js 代码，将输入的信息转化成新的 js 代码，类似于一个管道。      ","version":"Next","tagName":"h3"},{"title":"手写一个 Loader​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#手写一个-loader","content":" //markdown-loader.js module.exports = source =&gt; { //loader返回结果一定要是js代码，loader是直接将转换的结果塞入bundle.js包中 const html = marked(source); return `module.exports = ${JSON.stringify(html)}`; };   //.... module: { rules: [ { test: /.md$/, use: [&quot;html-loader&quot;, &quot;./markdown-load&quot;] //可以直接使用相对路径来引用编写好的loader } ]; }   use 数组有多个 loader 时候，loader 执行顺序是从后往前，从右往左依次执行。放在后面的 loader 优先级高先执行。  ","version":"Next","tagName":"h3"},{"title":"Plugin​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#plugin","content":" 插件机制，增强 webpack 的自动化能力，loader 实现资源模块的加载和打包，plugin 解决除了资源加载以外的其他自动化工作。例如 清除 dist 目录、拷贝静态文件到静态目录、压缩代码，实现了大多数前端工程化工作。  ","version":"Next","tagName":"h2"},{"title":"使用方法​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#使用方法","content":" const {CleanWebpackPlugin} from 'clean-webpack-plugin' const HtmlWepackPlugin from 'html-webpack-plugin' const CopyWebpackPlugin from 'copy-webpack-plugin' //... plugins:[{ new CleanWebpackPlugin() , //使用 new HtmlWepackPlugin({ title:&quot;页面名称1&quot;， meta:{ viewport:&quot;width=device-width&quot; }, template: resolvePath('../public/index.html'), }), new CopyWebpackPlugin(['public']) //拷贝public下的所有内容 }]   ","version":"Next","tagName":"h3"},{"title":"常用插件​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#常用插件","content":" 仔细过插件的官方说明和文档，了解 api 参数用法，不需要所有的都认识，用的时候再  clean-webpack-plugin : 自动清理 dist 目录插件，可以清空覆盖上一次 dist 内容，方便已经清除的内容积累html-webpack-plugin：通过 webpack 自动生成 bundle.js 的 html 修改 html 的标题、meta 等信息在 src 中新建 index.html 模版，比如一般的 react、vue 项目中就有入口 html，可以使用&lt;%= htmlWebpackPlugin.options.title %&gt;来访问 config 中的插件配置 copy-webpack-plugin ： 用来拷贝需要的静态文件，比如 favicon，直接将静态资源复制到 dist 中  ","version":"Next","tagName":"h3"},{"title":"手写一个 Plugin​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#手写一个-plugin","content":" plugin 通过钩子机制来实现，在 plugin 工作中会有很多环节，每个节点都挂了很多的钩子，可以参考官方文档，自己定义插件往这些钩子上挂  plugin 是一个函数或者包含一个 apply 的方法  class MyPlugin{ apply(compiler){ console.log('myplugin启动') compiler.hooks.emit('MyPlugin',compilation=&gt;{ //compilation 此次打包的上下文 for (let name in compilation.assets){ console.log(name) if(name.endswith('.js')) { const contents =compilation.assetslnamel.source()const withoutComments = contents.replace(/\\/\\*\\*+\\*\\//g,'') compilation.assets[name]={ source:()=withoutComments, size:() withoutComments.length} } } }) } }     const {CleanWebpackPlugin} from 'clean-webpack-plugin' //... plugins:[{ new MyPlugin() , //使用 }]   ","version":"Next","tagName":"h3"},{"title":"开发体验​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#开发体验","content":"   这种方式过于原始，会降低开发效率，设想：理想开发环境，能使用 http server 运行，可以类似生产环境区运行，能自己编译自动刷新，自动构建，及时显示结果，大大减少开发重复，支持 source Map ，出现问题时能直接进入文件进行调试。  ","version":"Next","tagName":"h2"},{"title":"如何增强 webpack 开发体验？​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#如何增强-webpack-开发体验","content":" ","version":"Next","tagName":"h2"},{"title":"watch 工作模式​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#watch-工作模式","content":" 监听文件变化，自动重新打包进行构建。  使用 webpack 命令时，添加yarn webpack --watch,开启监视模式，每次修改文件自动打包，专注编码  ","version":"Next","tagName":"h3"},{"title":"Webpack Dev Server(推荐)​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#webpack-dev-server推荐","content":" 官方推出，结合了 watch 模式，一边编码 自动编译 自动刷新浏览器的功能，集成在一起，使用很简单。  不会生成 dist 模式，只是把打包结果暂时存放内存当中，devserver 从内存中进行读取，减少磁盘读写操作，加快效率- yarn add webpack-dev-server默认只会 serve 打包输出文件  ","version":"Next","tagName":"h3"},{"title":"BrowserSync 自动刷新浏览器更新内容（不推荐）​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#browsersync-自动刷新浏览器更新内容不推荐","content":" 实现自动刷新浏览器进行更新，原理是，dist 内容被 proxy 监听了，直接去刷新浏览器。缺点是太麻烦了，开发效率降低，webpack 会不断的写入 dist 进入磁盘，一直去监听变化也会消耗性能  ","version":"Next","tagName":"h3"},{"title":"热更新​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#热更新","content":" HMR 模块热更新，运行过程中的及时变化，不会重新刷新浏览器，应用运行状态不受影响。  webpack-dev-server --hot  初始配置方法：   //webpack.config.js //... const webpack = require('webpack') devServer:{ hot:true }, plugins:[ new webpack.HotModuleReplacementPlugin() ]   以上基本配置只能影响样式的热更新但是不能影响到 js 文件。  HMR 解惑：webpack 中的 hmr 不是开箱即用，需要进行其他的手动配置，手动处理模块热替换的内容。但一般的 cli 是帮忙进行处理了，框架下的开发，每种文件都是有规律的。脚手架创建的项目内部都继承了 HMR  ","version":"Next","tagName":"h3"},{"title":"source map​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#source-map","content":" source map是编译后代码和原始代码的一个映射关系。在生产环境，sourcemap不能发布到线上，通常做法是上传到异常监控服务，用于解析线上的错误信息  ","version":"Next","tagName":"h3"},{"title":"生产环境优化​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#生产环境优化","content":" ","version":"Next","tagName":"h2"},{"title":"mode（模式）通过为不同的工作环境创建不同的配置​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#mode模式通过为不同的工作环境创建不同的配置","content":" ","version":"Next","tagName":"h3"},{"title":"Tree Shaking​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#tree-shaking","content":" TreeShaking 不是指某个配置选项，是一组功能搭配使用之后的效果。  production 模式下自动启用   //webpack.config.js //... optimization:{ usedExports:true, //会把没用到的包都不打 去除 minimize:true //压缩输出结果 }   Tree Shaking&amp;Babel的关系：  Tree Shaking 前提是ES modules, 由webpack打包的代码必须是ESM ，为了转换es的新特性，使用babel loader转换es6-&gt;js； 最新版本的babel-loader不会导致tree-shaking失效，  合并模块  optimization:{ usedExports:true, //会把没用到的包都不打 去除 minimize:true, concatenateModules:true //尽可能多的把模块打包到同一个函数 }   sideEffects 副作用，开发npm包时候，一般用于npm包标记是否有副作用  生产模式下默认开启，会判断package.json下是否开启了sideEffect  optimization:{ sideEffect:true, //是否存在福泽园 // usedExports:true, //会把没用到的包都不打 去除 // minimize:true, // concatenateModules:true //尽可能多的把模块打包到同一个函数 }    &quot;sideEffects&quot;:false   ","version":"Next","tagName":"h3"},{"title":"Code Splitting（代码分割 ）​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#code-splitting代码分割-","content":" 项目所有代码都打包到一起，如果应用很复杂 模块很多，bundle体积就很大。并不是每个模块都需要在启动时进来就加载的。  把打包结果，按一定规则分离到多个bundle中，根据应用需要按需加载  分包的好处：  提高首屏性能提高缓存效率  两种分包方式：  多入口打包（Multi Entry）：根据业务配置不同的打包入口，此时会输出多个打包结果。 多用于传统的多页应用程序， 一个页面对应一个打包入口。对于公共的部分就提取到公共的结果中  //webpack.config.js .... entry:{ &quot;index&quot;:'./src/index.js', //多人口采用对象的形式，使用 key 为入口文件名，value是路径 &quot;alarm&quot;:'./src/alarm.js' }   但是  采用es module的动态导入，实现模块按需加载。此时也会把动态导入的内容，分到多个bundle中。比如在引入路由的时候使用import就可以将每一个视图所依赖的模块进行分包 使用import('./xxx.js') 将运行时的代码单独分包，但由于运行的代码体积较小，所以优化效果不明显  ###hash文件名（文件指纹） 输出文件名。可以出现缓存现象。生产模式下给文件名hash值，避免文件更新出现缓存的问题。  hash: 项目级别的。只要项目更新，所有hash值都会重新编写改变。且所有的文件都公用同一个hashchunkhash:chunk级别，只要是同一路的打包，chunk都是相同contenthash: 根据文件的内容生成，具有唯一性，只要文件改变就重新生成，这是解决缓存问题最好选择。  fileName:'[name]-[hash].bundle.js' fileName:'[name]-[chunkhash].bundle.js' fileName:'[name]-[contenthash].bundle.js'   ","version":"Next","tagName":"h3"},{"title":"并行处理打包优化​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#并行处理打包优化","content":" happyPack：多进程方式运行资源加载loader逻辑，5.0慢慢去除thread-loader：webpack官方出品，同样以多进程进行处理，后续会优化parallel-webpack：运用于多入口项目terserWebpackPlugin：支持多进程方式代码压缩、uglify功能 ","version":"Next","tagName":"h3"},{"title":"性能优化进阶","type":0,"sectionRef":"#","url":"/docs/notes/性能优化/性能优化总结","content":"","keywords":"","version":"Next"},{"title":"Navigation Timing API​","type":1,"pageTitle":"性能优化进阶","url":"/docs/notes/性能优化/性能优化总结#navigation-timing-api","content":" 这个api是挂在window上的api，通常是用来获取页面的一些节点完成的时间  unloadEventStart/End : 前一个页面unload的时间戳  引出问题 - 无前置页面怎么办？ - 则值为0 - 前置页面域名不同怎么办？ - 值也为0   redirectStart / End ： 第一个页面级的重定向发生的事件/ 最后一个页面重定向完成的事件 （注意：是页面重定向不是http请求） fetchStart / End ： 浏览器用于准备使用网络抓取文档的事件 domainLookupStart / End : 重新建立连接的时间点的事件  （注意：只是开始准备建立连接，和建立完成的时间点，并没有发送） - 如果是长连接怎么办？ - 如果是长连接，意思就是fetchStart 和 domainLookup的阶段重叠，domainLookup的准备阶段就是在fetchStart内 - 值就是等于fetchStart   connectStart/End ： 连接的开始和结束。（TCP建立握手的开始和完成） secureConnectionStart : HTTPS建立的时间，对ssl中间层的操作过程，加密验证操作 requestStart / End ： 发送请求的真实时间  - requestStart过程如果是缓存的怎么办？ - 包含了本地缓存的读取时间，很快   responseStart / End ： 回包的真实时间  - 同时包含了本地缓存的读取时间   domLoading : 开始解析渲染dom树的时间点  这个时间点会抛出： readystatechange 事件   domInteractive ： 完成dom树的解析时间点  这个时间点会抛出： readystatechange 事件   domComplete ： 整个dom完成了渲染  这个时间点也会抛出： readystatechange 事件   loadEventStart / End ： load事件触发以及load回调完成  相关代码  //比如使用timing api 来计算页面的加载时间 let perfData = window.performance.timing; let pageLoadTime = perfData.loadEventEnd - perfData.navigationStart window.trace('当前页面加载耗时：',pageLoadTime,'ms')   ","version":"Next","tagName":"h2"},{"title":"Core Web Vitals 网页性能核心指标​","type":1,"pageTitle":"性能优化进阶","url":"/docs/notes/性能优化/性能优化总结#core-web-vitals-网页性能核心指标","content":" 现在是获取到了对应的时间戳，知道了每个阶段的时间范围长短，业界推出了cwv作为衡量标准。  google推出=&gt; 可衡量的，反应真实用户的体验： 加载、交互、视觉的稳定性  LCP - Largest Contentful Paint ： 最大内容渲染，最大内容绘制。 衡量装在性能  前2.5s内要进行最大内容的渲染 a. 最大内容包括： &lt;img&gt;元素&lt;video&gt;视频元素&lt;svg&gt; logo、icon等元素通过url加载的backgroundImage图片包含了文本整体节点的块级元素 b. LCP值低下的原因： 服务器响应慢存在阻断渲染的js。js线程和渲染线程互斥的，会阻碍资源加载慢客户端渲染的机器性能低 c. 如何针对性的优化？ 服务器的优化：采用离线的html缓存（强缓存、协商缓存）尽量不要阻断页面渲染，可以拆分script，或脚本后置（webassembly）对资源做优化，jpg webp 降低资源大小，加快请求速度利用工程化的方式：html进行动态组装、压缩、首屏优化、worker的方式、服务端渲染  FID - First Input Delay: 衡量交互的性能  页面首次输入的延迟应该小于100ms。页面刚渲染完，到我能点击输入框并且能输入文字的这段时间要小于100ms，要不然喊卡 a. 减少后置任务对交互行为的阻塞。 延迟不需要紧急处理的js逻辑很多微任务的存在，减少不必要的polyfill b. 分解耗时的任务 任何阻塞主线程超过50ms的任务都叫长任务，尽量不让主线程出现长任务把长任务拆分成各种较小的异步任务 c. 使用worker来计算  CLS - Cumulative Layout Shift : 衡量视觉的稳定性，cls页面应当小于0.1  布局移动的可能发生在元素的前一帧到下一针的改变位置，防止出现抖动的情况，防止布局飘逸的发生 a. 不要去使用无尺寸的元素 给元素默认宽高，默认宽高与最终的宽高保持一致减少重排 b. 减少页面内容的插入 减少中途的dom节点插入，会导致重排 c. 字体的控制 关注字体的长宽大小  ","version":"Next","tagName":"h2"},{"title":"CWV工具：core web vitals anotations​","type":1,"pageTitle":"性能优化进阶","url":"/docs/notes/性能优化/性能优化总结#cwv工具core-web-vitals-anotations","content":" 谷歌提供的浏览器插件，可以直接显示具体的数值是否达标。 ","version":"Next","tagName":"h2"},{"title":"CSS基础点整理","type":0,"sectionRef":"#","url":"/docs/notes/HTML&CSS/css基础","content":"","keywords":"","version":"Next"},{"title":"盒子模型​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#盒子模型","content":" 所有html元素可以看成一个盒子，它包括：边框 margin，边框 border，填充 padding，和 实际内容 content  ","version":"Next","tagName":"h2"},{"title":"标准盒子模型（W3C模型）​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#标准盒子模型w3c模型","content":" box-sizing: content-box; 盒子的大小会因为设置的内外边距和边框而变化，即：外扩；  标准盒模型宽高 = 内容区域（content）宽高  ","version":"Next","tagName":"h3"},{"title":"怪异盒子模型（IE盒模型）​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#怪异盒子模型ie盒模型","content":" box-sizing: box-border;盒子的实际大小是设置的大小，不会因为内外边距和边框的大小而变化，即：内缩；  怪异盒模型宽高 = border + padding + 内容区宽高（content）  ","version":"Next","tagName":"h3"},{"title":"margin和padding​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#margin和padding","content":" 负值问题  margin可以有负值，left、top如果是负值向反方向移动，right和bottom负值不会有影响padding不能有负值  百分比问题如果设置值为百分比，则是按照父元素的宽度来定  margin纵向重叠问题margin纵向塌陷，分为兄弟盒子之间塌陷问题和父子盒子之间塌陷问题  兄弟盒子之间塌陷问题 元素垂直排列时，第一个元素的下外边距与第二个元素的上外边距会发生合并，合并后的间距就是两者中最大的那个值。 解决办法： 任何一个元素加上 display:inline-block;把外边距只加在其中一个元素上任意一个元素外边距换成对应的 padding 父子盒子之间的穿透问题 当一个元素包含在另一个元素中时,如果父元素没有设置内边距或边框把外边距分隔开，它们的上或下外边距也会发生合并 解决办法： 给父子元素中任一个加上position: absolute;给父元素加上overflow: hidden;给父子元素中任一个加上float: left;给父子元素中任一个加上 display: inline-block;给父元素添加 border 边框给父元素加上 display:table;将子元素的 margin 改成 pading  ","version":"Next","tagName":"h2"},{"title":"Flex布局​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#flex布局","content":" flex 布局又称为弹性布局。  ● 当我们给一个容器元素设置 display:flex; 时，这个容器就变成了 flex 容器，容器中所有直接子元素就成了容器成员（flex 项目）。  ● flex 容器默认存在两根轴：水平的主轴和垂直的交叉轴，flex 布局主要是围绕这两根轴来进行布局的。  ● 所以 flex 布局相对于 grid 网格布局来说，他更适合一维布局（单行或单列布局）  要详细弄懂 flex 布局，我们就要了解 Flex 容器的属性和 Flex 项目的属性。  flex布局知识点掘金笔记整理  ","version":"Next","tagName":"h2"},{"title":"BFC​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc","content":" BFC 全称为块级格式化上下文 (Block Formatting Context) ,可以说BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。在页面上的一个隔离的独立容器，是一个独立的渲染区域。  ","version":"Next","tagName":"h2"},{"title":"BFC特点​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc特点","content":" 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流） 处于同一个BFC中的元素相互影响，可能会发生外边距重叠 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到BFC上  ","version":"Next","tagName":"h3"},{"title":"如何产生BFC？​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#如何产生bfc","content":" 有以下条件可以创建 BFC： ● 方法一：float 的值不是 none  ○ 该方法可以实现效果，但没有意义，不可能随便给盒子设置浮  ● 方法二：display 的值是 inline-block、flex 或 inline-flex  ○ 该方法可以实现效果，但没有意义，不可能随便改变盒子为行内块  ● 方法三：position 的值不是 static 或者 relative  ○ 该方法可以实现效果，但不靠谱  ● 方法四：overflow 的值不为 visible  ○ overflow：hidden； 该方法可以实现效果，是非常好用的让盒子形成 BFC 的方法，但不能满足所有的场景  ","version":"Next","tagName":"h3"},{"title":"BFC的作用？​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc的作用","content":" 解决外边距margin重叠问题：通过给两个元素设置 overflow 属性，从而触发 BFC，解决外部边距重叠问题。盒子margin塌陷问题：当我们需要在一个父元素中需要写一些列表项进行包裹时，然而，使用 float 就会导致对应元素脱离文档流，父元素不能包裹住子元素。可以通过使用overflow来清除浮动。设置overflow:hidden，触发了bfc  ","version":"Next","tagName":"h3"},{"title":"清除浮动的方案​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#清除浮动的方案","content":" 给浮动元素的::after伪类设置clear:both（强烈推荐） 给浮动元素的父元素创建BFC，设置overflow:hidden 给浮动元素后的父元素设置clear:both（不推荐）  ","version":"Next","tagName":"h3"},{"title":"垂直居中的方案​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#垂直居中的方案","content":" 方法\t实现代码\t注意事项行内元素水平垂直居中\tline-height: 35px;``text-align: center;\t这个垂直居中只针对单行文本有效，需保证 line-height 值与容器高度一致 绝对定位 + margin\tposition: absolute;``top: 50%;``margin-top: -元素自身高度一半;``left: 50%;``margin-left: -元素自身宽度一半;\t需要明确指定子元素的宽高 绝对定位 + margin: auto\tposition: absolute;``margin: auto;\t必须指定子元素宽高；未指定宽高时子元素会占满父容器 绝对定位 + translate\tposition: absolute;``left: 50%;``top: 50%;``transform: translate(-50%, -50%);\t无需指定子元素宽高（推荐）translate 百分比基于元素自身宽高动态计算 flex 布局\t父元素添加：display: flex;``justify-content: center;``align-items: center;\t父容器内所有子元素均居中 flex + margin: auto\t父元素：display: flex;子元素：margin: auto;\t可指定单个子元素居中 table-cell\t父元素添加：display: table-cell;``text-align: center;``vertical-align: middle;\t避免同时使用 float 或 position: absolute``margin 在 table-cell 布局中无效  ","version":"Next","tagName":"h2"},{"title":"grid布局知识​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#grid布局知识","content":" CSS 网格布局（CSS Grid Layout）是最强大的 CSS 布局方案。  Grid 布局提供了带有行和列的基于网格的布局系统，它使网页设计变得更加容易，而无需使用浮动和定位。  它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。  基础概念  名称\t描述container （容器）\t采用网格布局的区域称为&quot;容器&quot; item （项目）\t容器内部采用网格定位的子元素 称为&quot;项目&quot; row （行）\t容器里面的水平区域称为 &quot;行&quot; column（列）\t垂直区域称为&quot;列&quot; cell（单元格）\t行和列的交叉区域，称为&quot;单元格&quot; grid line（网格线）\t划分网格的线，称为&quot;网格线&quot; 。水平网格线划分出行，垂直网格线划分出列。注：只有容器的直接子元素会参与网格布局  Grid 布局的属性分成两类：  一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。  名称\t描述display: grid;\t指定一个容器采用网格布局，容器元素都是块级元素（默认情况下） display: inline-grid;\t该元素内部采用网格布局，该容器元素是内联块元素 grid-template-rows\t定义每一行的行高：① 固定数字② % ：容器宽高的百分比（不包括内边距和边框）③ fr：分配剩余可用空间④ auto：先于 fr 计算，获取必要的最小空间⑤ repeat()：简化重复的值⑥ minmax()：取值&gt;=最小值，并且&lt;=最大值 grid-template-columns\t定义每一列的列宽：① 固定数值② % ：容器宽高的百分比（不包括内边距和边框）③ fr：分配剩余可用空间④ auto：先于 fr 计算，获取必要的最小空间⑤ repeat()：简化重复的值⑥ minmax()：取值&gt;=最小值，并且&lt;=最大值 grid-auto-flow\t定义项目的排列顺序：① row：默认值)，先填满第一-行， 再放入第二行；② column：先填满第一列， 再放入第二列③ row dense：在稍后出现较小的项目时，先尽可能的填满第-行，再填满第二行④ column dense：在稍后出现较小的项目时，先尽可能的填满第一列，再填满第二列 grid-auto-rows\t定义浏览器自动创建的多余网格的行高 grid-auto-columns\t定义浏览器自动创建的多余网格的列宽 row-gap\t设置行间距 column-gap\t设置列间距 gap\t是 row-gap 和 column-gap 的简写形式 grid-template-areas\t定义区域 align-items\t设置项目的垂直位置（上中下）① stretch (默认值) ：拉伸，占满单元格的整个高② start：对齐单元格的起始边缘③ end：对齐单元格的结束边缘④ center ：单元格内部居中 justify-items\t设置项目的水平位置（左中右）① stretch (默认值)：拉伸，占满单元格的整个宽② start：对齐单元格的起始边缘③ end：④ 对齐单元格的结束边缘⑤ center：单元格内部居中 place-items\t是 align-items 和 justify-items 的合并简写形式 align-content\t设置整个内容区域的垂直位置（上中下）① stretch (默认值)：项目大小没有指定时，拉伸占据整个网格容器② start：对齐容器的起始位置③ end：对齐容器的结束位置④ center：容器内部居中⑤ space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍⑥ space-between：项目与项目之间的间隔相等，项目与容器边框之间没有间隔⑦ space-evenly：项目与项目之间的间隔相等，项目与容器边框之间也是同样长度的间隔 justify-content\t设置整个内容区域的水平位置（左中右）① stretch (默认值)：项目大小没有指定时，拉伸占据整个网格容器② start：对齐容器的起始位置③ end：对齐容器的结束位置④ center：容器内部居中⑤ space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍;space-between： 项目与项目之间的间隔相等，项目与容器边框之间没有间隔;space-evenly：目与项目之间的间隔相等，项目与容器边框之间也是同样长度的间隔 place-content\t是 align-content 和 justify-content 的合并简写形式 grid-template\t是 grid-template-columns、grid-template-rows 和 grid-template-areas 这三个属性的合并简写形式（既不易写也不易读，不建议使用） grid\tgrid 是 grid-template-rows、grid-template-columns、 grid-template-areas、grid-auto-rows、 grid-auto-columns、grid-auto-flow 这六个属性的合并简写形式（既不易写也不易读，不建议使用）  grid布局知识  ","version":"Next","tagName":"h2"},{"title":"常用布局方案应用场景​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#常用布局方案应用场景","content":" 1、流体布局 宽度随屏幕大小变化，高度不变；  2、rem 和 vw 布局 等比例缩放  3、响应式布局 一次开发，多端使用（多用于展示性网站）  4、flex 布局 轴线布局（一维布局）  5、Grid 网格布局 行列布局（二维布局） ","version":"Next","tagName":"h2"},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/notes/intro","content":"关于 Hi，我是易云，也可以叫我的英文名krysent。一位默默无闻，但热爱技术、热爱生活的95后前端开发。 在这里记录我的日常学习笔记以及项目中的一些思考总结 我的好友 杨 说过一句话很不错，想分享一下 ： “任何东西都是长期的过程，付出时间精力去学习了，才会有回报” 我想说，任何成功不是一蹴而就，都是靠每一份耕耘和不断的自我内驱。要像海绵一样不断的去汲取知识内容，成为自己的一部分。","keywords":"","version":"Next"},{"title":"HTML以及H5新特性","type":0,"sectionRef":"#","url":"/docs/notes/HTML&CSS/Html以及Html5","content":"","keywords":"","version":"Next"},{"title":"HTML​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#html","content":" ","version":"Next","tagName":"h2"},{"title":"标签元素类型​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#标签元素类型","content":" 常见元素类型分为块级和行级  块级元素：  总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列宽度缺少时是它的容器的100%，除非设置一个宽度高度、行高以及外边距和内边距都是可以设置的块级元素可以容纳其它行级元素和块级元素  行内元素：  和其它元素都会在一行显示高、行高以及外边距和内边距可以设置宽度就是文字或者图片的宽度，不能改变行级元素只能容纳文本或者其它行内元素  注意点  行内元素设置宽度width无效行内元素设置height无效，但是可以通过line-height来设置设置margin只有左右有效，上下无效设置padding只有左右有效，上下无效  ","version":"Next","tagName":"h3"},{"title":"scrpit标签的async和defer属性​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#scrpit标签的async和defer属性","content":" 共同点：  异步加载：脚本的下载过程与HTML解析并行进行，不会阻塞页面渲染。仅适用于外部脚本：需要与src属性一起使用（内联脚本无效）。  特性\tasync\tdefer执行时机\t脚本下载完成后立即执行，可能中断HTML解析。\t脚本下载完成后，等待HTML解析完成再执行（在DOMContentLoaded事件之前）。 执行顺序\t不保证顺序（先下载完成的先执行）。\t严格按文档顺序执行。 适用场景\t完全独立、无依赖的脚本（如统计代码）。\t需要依赖DOM或其他脚本的场景。  info 普通脚本: [下载] → [执行] → [继续解析HTML] async脚本: [下载⏳] → [立即执行❗]（可能中断解析） defer脚本: [下载⏳] → [等待HTML解析完成] → [按顺序执行📑]  ","version":"Next","tagName":"h3"},{"title":"href和src区别​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#href和src区别","content":" src是source，外部资源的引用位置。项目内部文件的引用，如 js 脚本，img 图片和 iframe 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 href是网络资源的链接，在服务里的网络资源地址的下载，比如&lt;link&gt;标签里的href就是去下载css样式资源。并行下载资源并且不会停止对当前文档的处理。  ","version":"Next","tagName":"h3"},{"title":"HTML5新特性​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#html5新特性","content":" HTML5主要是关于图像、位置、存储、多任务等功能的增加：  语义化标签，如：article、footer、header、nav等视频video、音频audio画布canvas表单控件，calemdar、date、time、email地理本地离线存储，localStorage长期存储数据，浏览器关闭后数据不丢失，sessionStorage的数据在浏览器关闭后自动删除拖拽释放  ","version":"Next","tagName":"h2"},{"title":"H5语义化​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#h5语义化","content":" 作用：使用英文的语义化标签，方便开发人员的阅读和理解  比如之前是&lt;div&gt;``&lt;span&gt; , h5添加了语义化的&lt;form&gt;``&lt;nav&gt;``&lt;section&gt;``&lt;header&gt;``&lt;footer&gt;等明确其内容的标签 ","version":"Next","tagName":"h3"},{"title":"JavaScript进阶面试题","type":0,"sectionRef":"#","url":"/docs/interview/JS进阶面试题","content":"","keywords":"","version":"Next"},{"title":"实现图片懒加载的思路​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#实现图片懒加载的思路","content":" 判断图片所在位置是否在可视区域内，图片移到可视区域内进行加载，提供三种判断方法：  offsetTop &lt; clientHeight + scrollTopelement.getBoundingClientRect().top &lt; clientHeightIntersectionObserver  方案一:clientHeight、scrollTop 和 offsetTop  首先给图片一个占位资源:   &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://www.xxx.com/target.jpg&quot; /&gt;   接着，通过监听 scroll 事件来判断图片是否到达视口:  let img = document.getElementsByTagName(&quot;img&quot;); let num = img.length; let count = 0;//计数器，从第一张图片开始计 lazyload();//首次加载别忘了显示图片 window.addEventListener('scroll', lazyload); function lazyload() { let viewHeight = document.documentElement.clientHeight;//视口高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度 for(let i = count; i &lt;num; i++) { // 元素现在已经出现在视口中 if(img[i].offsetTop &lt; scrollHeight + viewHeight) { if(img[i].getAttribute(&quot;src&quot;) !== &quot;default.jpg&quot;) continue; img[i].src = img[i].getAttribute(&quot;data-src&quot;); count ++; } } }   当然，最好对 scroll 事件做节流处理，以免频繁触发:  // throttle函数我们上节已经实现 window.addEventListener('scroll', throttle(lazyload, 200));   方案二：getBoundingClientRect  现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。  上述的 lazyload 函数改成下面这样:  function lazyload() { for(let i = count; i &lt;num; i++) { // 元素现在已经出现在视口中 if(img[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight) { if(img[i].getAttribute(&quot;src&quot;) !== &quot;default.jpg&quot;) continue; img[i].src = img[i].getAttribute(&quot;data-src&quot;); count ++; } } }   方案三: IntersectionObserver  这是浏览器内置的一个API，实现了监听window的scroll事件、判断是否在视口中以及节流三大功能。  let img = document.getElementsByTagName(&quot;img&quot;); const observer = new IntersectionObserver(changes =&gt; { //changes 是被观察的元素集合 for(let i = 0, len = changes.length; i &lt; len; i++) { let change = changes[i]; // 通过这个属性判断是否在视口中 if(change.isIntersecting) { const imgElement = change.target; imgElement.src = imgElement.getAttribute(&quot;data-src&quot;); observer.unobserve(imgElement); } } }) Array.from(img).forEach(item =&gt; observer.observe(item));   这样就很方便地实现了图片懒加载，当然这个IntersectionObserver也可以用作其他资源的预加载，功能非常强大。  ","version":"Next","tagName":"h2"},{"title":"以下代码输出结果？涉及异步问题​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#以下代码输出结果涉及异步问题","content":" async function async1() { console.log('async1 start'); await async2(); console.log('async1 end'); } async function async2() { new Promise(function(resolve) { console.log('promise1'); resolve(); console.log(&quot;promiseResolve&quot;) }).then(function() { setTimeout(function() { console.log('setTimeout1'); }) console.log('promise2'); }); } console.log('script start'); setTimeout(function() { console.log('setTimeout2'); }, 0) async1(); process.nextTick(() =&gt; { console.log(&quot;nextTick&quot;); }) new Promise(function(resolve) { console.log('promise3'); resolve(); setTimeout(() =&gt; { console.log('setTimeout3') }) }).then(function() { console.log('promise4'); }) .then(() =&gt; console.log('promise5')) .then(() =&gt; console.log('promise6')) console.log('script end'); /* script start async1 start promise1 promiseResolve promise3 nextTick // nextTick有自己的队列，优先于其它微任务先执行 promise2 script end async1 end promise4 promise5 promise6 setTimeout2 setTimeout3 setTimeout1 */   ","version":"Next","tagName":"h2"},{"title":"说说回流（重排）和重绘​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说说回流重排和重绘","content":" 浏览器渲染机制  浏览器采用流式布局模型（Flow Based Layout）  浏览器会把HTML解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就产生了渲染树（Render Tree）。  有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，合成布局树，最后把节点绘制到页面上。  由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。 注意：上面说的是首先会生成 Render Tree，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成 Render Tree 的过程了。而布局树的信息已经非常完善，完全拥有 Render Tree 的功能。  重绘  由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。  回流  回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流  浏览器优化  现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。  offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。   减少重绘与回流  CSS:  使用 transform 替代 top使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。避免使用 CSS 表达式，可能会引发回流。将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。CSS3 硬件加速（GPU加速），使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。  JavaScript:  避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。  ","version":"Next","tagName":"h2"},{"title":"在移动端中怎样初始化根元素的字体大小？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#在移动端中怎样初始化根元素的字体大小","content":" 一个简易版的初始化根元素字体大小。页面开头处引入下面这段代码，用于动态计算 font-size：(假设你需要的1rem = 20px)  (function () { var html = document.documentElement; function onWindowResize() { html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px'; } window.addEventListener('resize', onWindowResize); onWindowResize(); })();   document.documentElement：获取 document 的根元html.getBoundingClientRect().width：获取 html 的宽度(窗口的宽度)监听 window 的 resize 事件  一般还需要配合一个 meta 头：  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;   ","version":"Next","tagName":"h2"},{"title":"如何实现深拷贝？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#如何实现深拷贝","content":" 深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj))  JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷：  对象的属性值是函数时，无法拷贝。原型链上的属性无法拷贝不能正确的处理 Date 类型的数据不能处理 RegExp会忽略 symbol会忽略 undefined  实现一个 deepClone 函数:  如果是基本数据类型，直接返回如果是 RegExp 或者 Date 类型，返回对应类型如果是复杂数据类型，递归。考虑循环引用的问题  手写实现：  // 递归拷贝 function deepClone(obj, hash = new WeakMap()) { if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== 'object') { // 如果不是复杂数据类型，直接返回 return obj } if(hash.has(obj)) { // 如果已经处理过相同的对象，直接获取（解决循环引用） return hash.get(obj) } /** * 如果 obj 是数组，那么 obj.constructor 是 [Function: Array] * 如果 obj 是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let ikey in obj) { // 递归 if (obj.hasOwnProperty(key)) { // 是否是自身的属性 t[key] = deepClone(obj[key], hash) } } }   ","version":"Next","tagName":"h2"},{"title":"深拷贝怎么解决循环引用问题​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#深拷贝怎么解决循环引用问题","content":" 看个例子：  function deepCopy(obj){ const res = Array.isArray(obj) ? [] : {}; for(let key in obj){ if(typeof obj[key] === 'object'){ res[key] = deepCopy(obj[key]); }else{ res[key] = obj[key]; } } return res } var obj = { a:1, b:2, c:[1,2,3], d:{aa:1,bb:2}, }; obj.e = obj; console.log('obj',obj); // 不会报错 const objCopy = deepCopy(obj); console.log(objCopy); //Uncaught RangeError: Maximum call stack size exceeded   从例子可以看到，当存在循环引用的时候，deepCopy会报错，栈溢出。  obj对象存在循环引用时，打印它时是不会栈溢出  深拷贝obj时，才会导致栈溢出  循环应用问题解决  即：目标对象存在循环应用时报错处理  大家都知道，对象的 key 是不能是对象的。  {{a:1}:2} // Uncaught SyntaxError: Unexpected token ':'   参考解决方式一：使用weekmap:解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系 这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型， 我们可以选择 WeakMap 这种数据结构：  检查 WeakMap 中有无克隆过的对象有，直接返回没有，将当前对象作为key，克隆对象作为value进行存储继续克隆  function isObject(obj) { return (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; obj !== null } function cloneDeep(source, hash = new WeakMap()) { if (!isObject(source)) return source; if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表 var target = Array.isArray(source) ? [] : {}; hash.set(source, target); // 新增代码，哈希表设值 for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (isObject(source[key])) { target[key] = cloneDeep(source[key], hash); // 新增代码，传入哈希表 } else { target[key] = source[key]; } } } return target; }   参考解决方式二：  const o = { a: 1, b: 2 }; o.c = o; function isPrimitive(val) { return Object(val) !== val; } const set = new Set(); function clone(obj) { const copied = {}; for (const [key, value] of Object.entries(obj)) { if (isPrimitive(value)) { copied[key] = value; } else { if (set.has(value)) { copied[key] = { ...value }; } else { set.add(value); copied[key] = clone(value); } } } return copied; }   ","version":"Next","tagName":"h2"},{"title":"聊一下promise？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#聊一下promise","content":" es6+引入的解决异步问题的方案，Promise是一个构造函数，可以通过new来创建一个实例的promise对象。  Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的 then 方法和 catch、finally 方法会返回一个新的 Promise 所以可以允许我们链式调用，解决了传统的回调地狱问题。  Promise的状态一经改变就不能再改变  关于 then 以及 catch 方法：  Promise的状态一经改变就不能再改变。.then和.catch都会返回一个新的Promise。catch不管被连接到哪里，都能捕获上层未捕捉过的错误。在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  finally方法：  .finally()方法不管Promise对象最后的状态如何都会执行.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  最后可以说一下all以及race方法：  Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。  缺点是： Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  ","version":"Next","tagName":"h2"},{"title":"说一下promise.all 和 promise.race?​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下promiseall-和-promiserace","content":" promise.all  const p = Promise.all([p1, p2, p3]);   Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。  Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。  p的状态是由p1,p2,p3 决定的，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。  （3）接受一个 Promise 数组，当所有 Promise 成功时返回结果数组；若任意一个失败，立即以该失败原因拒绝。  （4）即使某个 Promise 失败，其他 Promise 仍会继续执行，但结果会被忽略。  ","version":"Next","tagName":"h2"},{"title":"说一下 href 和 src 的区别（字节）?​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下-href-和-src-的区别字节","content":" href 用于建立当前页面与引用资源之间的关系，而 src 会替换当前元素。  遇到 href，页面会并行加载后续内容，而 src 则需要浏览器加载完毕 src 的内容才会继续往下走。  src 是 source 的缩写，指向外部资源的位置  指向的内容将会嵌入到文档中当前标签所在位置或下载并应用到文档内；如 js 脚本，img 图片和 iframe 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 href 是 Hypertext Reference 的缩写，指向网络资源所在位置  建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式  ","version":"Next","tagName":"h2"},{"title":"说一下图片不同格式的区别？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下图片不同格式的区别","content":" 格式\t优点\t缺点\t适用场景gif\t支持动画、透明，无兼容性问题\t仅布尔透明\t色彩简单的 logo、icon、动图 jpg\t色彩丰富，文件小\t有损压缩，反复保存图片质量下降明显\t色彩丰富的图片/渐变图像，照片，复杂 banner png\t无损压缩，支持透明，简单图片尺寸小，高保真\t① 不支持动画，色彩丰富的图片尺寸大；② 对自然照片和复杂色块的图片压缩率不高\tlogo/icon/透明图，适用于 web 所有场景 webp\t文件小，支持有损和无损压缩，支持动画、透明\t浏览器兼容性相对而言不好\t支持 webp 格式的 app 和 webview，产品图片（如：京东） SVG\t① 可伸缩性，矢量图片随意放大缩小，不影响质量；显示效果好，不存在锯齿等情况② 体积小，Svg 平均比 GIF、 JPEG、 PNG 小得多，甚至在极高的分辨率下也是如此；③ 支持动画，更灵活、质量效果好；④ 与 DOM 无缝衔接，Svg 可以直接使用 HTML、 CSS 和 JavaScript （例如动画）来操作\t① 不适合高复杂度的图形，SVG 复杂度高会减慢渲染速度；② 不适合游戏类等高互动动画 图表（echarts），\t图标，logo ","version":"Next","tagName":"h2"},{"title":"JavaScript高级知识点整理","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/JavaScrpit高级","content":"","keywords":"","version":"Next"},{"title":"js的异步及事件循环​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#js的异步及事件循环","content":" ","version":"Next","tagName":"h2"},{"title":"浏览器进程模型​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#浏览器进程模型","content":" 什么是进程？  程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程  每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方的同意。  什么是线程？  有了进程之后，可以运行程序代码了。运行代码的环境叫线程，所以一个进程至少要有一个线程，所以在进程开启之后会自动创建一个线程来运行代码，该线程叫主线程。  如果程序要同时执行多个代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。  浏览器的进程和线程  浏览器是一个多进程和多线程的应用程序。  浏览器内部工作及其复杂，为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。  ","version":"Next","tagName":"h3"},{"title":"渲染主线程是如何工作？​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#渲染主线程是如何工作","content":" 渲染线是最重要的一个线程，用来显示页面。渲染主线程是浏览器里最繁忙的线程，需要他处理的任务包括但不限于以下： ● 解析html  ● 解析css  ● 计算样式  ● 布局  ● 处理图层  ● 每秒把页面绘制60次  ● 执行全局的js代码  ● 执行事件处理函数  ● 执行计时器的回调函数  ● 。。。  一个线程要处理这么多的事情，问题来了，要如何调度任务呢？比如  我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗? 我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗? 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢?  为了解决以上的问题。浏览器想到解决方案，利用排队的规则。  ","version":"Next","tagName":"h3"},{"title":"任务队列​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#任务队列","content":" 在W3C里叫做 event loop，谷歌浏览器里叫做message queue 消息队列（循环）  在最开始时候，渲染主线程会进入一个无限循环；每一次循环会检查消息队列里是否有任务存在，如果有，就取出第一个任务执行，执行完一个后进入下一个循环，如果没有，则进入休眠状态；其他所有的线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。再添加新任务时候，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。  以上整个过程称为“消息循环”。也叫事件循环  事件循环概括：  事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列未尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。  ","version":"Next","tagName":"h3"},{"title":"js的异步​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#js的异步","content":" 代码在执行过程里，会遇到一些无法立即处理的任务，比如：  ● 计时完成后需要执行的任务 settimeout，setInterval  ● 网络通信完成后需要执行的任务 ajax fetch  ● 用户操作后需要执行的任务 addeventlistener  如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死：  使用异步的方式：渲染主线程永不阻塞。  ","version":"Next","tagName":"h3"},{"title":"如何理解JS的异步​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#如何理解js的异步","content":" JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现。  所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。  ","version":"Next","tagName":"h3"},{"title":"任务有优先级吗？​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#任务有优先级吗","content":" 任务没有优先级，都是在消息队列中按照先进先出。但消息队列是有优先级的。目前chrome的实现里，至少包含了以下队列：  ● 延时队列：用于存放计时器到达后的任务，优先级 【中】  ● 交互队列：用于存放用户操作后参数的事件处理任务，优先级【高】  ● 微队列：用户存放需要最快执行的任务，优先级【最高】  添加任务到微队列的方式主要是使用Promise，MutationObserver  ","version":"Next","tagName":"h3"},{"title":"垃圾回收机制​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#垃圾回收机制","content":" ","version":"Next","tagName":"h2"},{"title":"防抖、节流​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#防抖节流","content":" 本质上是优化高频率执行代码的一种手段  如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能  为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率  定义  节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻:  想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应  假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制  电梯第一个人进来后，15秒后准时运送一次，这是节流  电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖.  相同点：  都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率。节省计算资源 不同点：  函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次  例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次  应用场景: 防抖在连续的事件，只需触发一次回调的场景有：  搜索框搜索输入。只需用户最后一次输入完，再发送请求手机号、邮箱验证输入检测窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。  节流在间隔一段时间执行一次回调的场景有：  滚动加载，加载更多或滚到底部监听搜索框，搜索联想功能  ","version":"Next","tagName":"h2"},{"title":"Promise​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#promise","content":" ","version":"Next","tagName":"h2"},{"title":"Ajax、Fetch和Axios​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#ajaxfetch和axios","content":" ","version":"Next","tagName":"h2"},{"title":"Ajax​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#ajax","content":" Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”  Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。  Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。其中 XMLHttpRequest 模块就是实现 Ajax 的一种很好的方式，这也是很多面试官喜欢让面试者手撕的代码之一。ajax != xmlhttprequest  我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。  ","version":"Next","tagName":"h3"},{"title":"Fetch​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#fetch","content":" fetch是在es6出现的，基于es6提出的promise来实现，是xmlhttprequest的替代品，不是ajax的替代品。是用来跟xmlhttprequest进行比较。fetch是一个api。  使用 promise，不使用回调函数。采用模块化设计，比如 rep、res 等对象分散开来，比较友好。通过数据流对象处理数据，可以提高网站性能。解决了xmlhttprequest出现的回掉地狱的情况  ","version":"Next","tagName":"h3"},{"title":"Axios​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#axios","content":" Axios 是一个基于 promise 封装的网络请求库，它是基于 XHR 进行二次封装。  从浏览器中创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求数据和响应数据取消请求自动转换 JSON 数据客户端支持防御 XSRF  ","version":"Next","tagName":"h3"},{"title":"三者对比​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#三者对比","content":" Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。其实三者都属于ajax技术  网络请求\t特点Ajax\t一种技术统称，主要利用XHR实现网络请求 Fetch\t具体API，基于promise，实现网络请求 Axios\t一个封装库，基于XHR封装，较为推荐使用 ","version":"Next","tagName":"h3"},{"title":"ES6+","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/ES6+","content":"","keywords":"","version":"Next"},{"title":"ES6+新特性内容整理​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#es6新特性内容整理","content":" ","version":"Next","tagName":"h2"},{"title":"let和const​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#let和const","content":" ","version":"Next","tagName":"h2"},{"title":"关于let​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#关于let","content":" let 是 ES6 引入的一种变量声明方式，主要用于解决 var 声明变量时的一些问题。let 的本质特性包括：  块级作用域  let 声明的变量只在其所在的代码块内有效，这与 var 不同。var 声明的变量是函数作用域或全局作用域。  { let x = 10; var y = 20; } console.log(x); // 报错：ReferenceError: x is not defined console.log(y); // 输出: 20   不允许重复声明  在同一作用域内，使用 let 声明同一个变量会导致错误，而 var 允许重复声明。  let a = 1; // let a = 2; // 报错：Identifier 'a' has already been declared var b = 1; var b = 2; // 合法，b 的值会被更新为 2   提升（Hoisting）  let 声明的变量会被提升到所在作用域的顶部，但在声明之前是不可用的。这种现象称为“暂时性死区”（Temporal Dead Zone, TDZ）。  console.log(c); // 报错：ReferenceError: Cannot access 'c' before initialization let c = 3;   用于循环中的作用域 在循环中使用 let 声明的变量，每次迭代都会创建一个新的作用域，这在处理异步操作时非常有用。  for (let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; { console.log(i); // 输出: 0, 1, 2 }, 1000); } //使用 var 声明的变量会导致所有的回调函数共享同一个 i，输出结果为 3 三次。 for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; { console.log(i); // 输出: 3, 3, 3 }, 1000); }   ","version":"Next","tagName":"h3"},{"title":"关于const​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#关于const","content":" const 的本质是 ES6 引入的一个关键字，用于声明常量。它的本质特性主要体现在以下几个方面：  固定的引用 const 声明的变量指向的内存地址是固定的，这意味着你不能重新赋值给该变量。换句话说，const 确保变量的引用不变，但并不意味着引用的数据本身不可变。  const a = 10; // a = 20; // 报错：Assignment to constant variable.   复合类型的可变性 对于复合类型（如对象和数组），const 变量指向的是一个内存地址，而这个地址保存的是一个指向实际数据的引用。因此，虽然 const 保证了这个引用（指针）不会改变，但它指向的数据结构本身是可以修改的。  const obj = { name: 'Alice' }; obj.name = 'Bob'; // 这是合法的，obj 的内容被修改 console.log(obj); // 输出: { name: 'Bob' } // obj = { name: 'Charlie' }; // 报错：Assignment to constant variable.   块级作用域（同let） 不允许重复声明（在同一作用域） 提升（同let）  let 和 const 的引入使得 JavaScript 的变量管理更加严谨，避免了 var 的一些常见问题，提升了代码的可读性和可维护性。建议在编写现代 JavaScript 时优先使用 let 和 const，以确保更好的代码质量。  ","version":"Next","tagName":"h3"},{"title":"解构​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#解构","content":" ","version":"Next","tagName":"h2"},{"title":"新增的数组方法​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#新增的数组方法","content":" ","version":"Next","tagName":"h2"},{"title":"Class关键字​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#class关键字","content":" ","version":"Next","tagName":"h2"},{"title":"Promise相关​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#promise相关","content":" 可见阮一峰es6教程  promise.all  const p = Promise.all([p1, p2, p3]);   Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。  Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。  p的状态是由p1,p2,p3 决定的，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。  （3）接受一个 Promise 数组，当所有 Promise 成功时返回结果数组；若任意一个失败，立即以该失败原因拒绝。  （4）即使某个 Promise 失败，其他 Promise 仍会继续执行，但结果会被忽略。  es6+引入的解决异步问题的方案，Promise是一个构造函数，可以通过new来创建一个实例的promise对象。  Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的 then 方法和 catch、finally 方法会返回一个新的 Promise 所以可以允许我们链式调用，解决了传统的回调地狱问题。  Promise的状态一经改变就不能再改变  关于 then 以及 catch 方法：  Promise的状态一经改变就不能再改变。.then和.catch都会返回一个新的Promise。catch不管被连接到哪里，都能捕获上层未捕捉过的错误。在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  finally方法：  .finally()方法不管Promise对象最后的状态如何都会执行.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  最后可以说一下all以及race方法：  Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。  缺点是： Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  ","version":"Next","tagName":"h2"},{"title":"迭代器 generater​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#迭代器-generater","content":"","version":"Next","tagName":"h2"},{"title":"装饰器","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/typescript-装饰器","content":"","keywords":"","version":"Next"},{"title":"简介​","type":1,"pageTitle":"装饰器","url":"/docs/notes/JavaScript/typescript-装饰器#简介","content":" 装饰器本质是一种特殊的函数，它可以对:类、属性、方法、参数进行扩展，同时能让代码更简洁。装饰器自 2015 年在 ECMAScript-6 中被提出到现在，已将近10年。截止目前，装饰器依然是实验性特性需要开发者手动调整配置，来开启装饰器支持。装饰器有五种： 类装饰器属性装饰器方法装饰器访问器装饰器参数装饰器 备注:虽然 Typescript5.0中可以直接使用类装饰器.但为了确保其他装饰器可用，现阶段使用时 仍建议使用 experimentalDecorators置来开启装饰器文持，而且不排除在来的版本中，官方会进一步调整装饰器的相关语法!  ","version":"Next","tagName":"h2"},{"title":"类装饰器​","type":1,"pageTitle":"装饰器","url":"/docs/notes/JavaScript/typescript-装饰器#类装饰器","content":" 类装饰器是一个应用在类声明上的函数，可以为类添加额外的功能，可或添加额外的逻辑。  //定义一个装饰器 function demo(target) { console.log(target); //target 就是被装饰的类 Person } //使用装饰器 @demo class Person { name:string, age:number, constructor(){ } }   关于返回值：  类装饰器有返回值:若类装饰器返回一个新的类，那这个新类将替换掉被装饰的类。  类装饰器无返回值:若类装饰器无返回值或返回 undefined ，那被装饰的类不会被替换。 ","version":"Next","tagName":"h2"},{"title":"Nginx 学习笔记","type":0,"sectionRef":"#","url":"/docs/notes/Nginx学习/Nginx学习笔记","content":"","keywords":"","version":"Next"},{"title":"背景​","type":1,"pageTitle":"Nginx 学习笔记","url":"/docs/notes/Nginx学习/Nginx学习笔记#背景","content":" Nginx(“engine x&quot;)一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3/SMTP/IMAP代理服务器】，是由伊戈尔·赛索耶(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好的保障。  ","version":"Next","tagName":"h2"},{"title":"名词解释​","type":1,"pageTitle":"Nginx 学习笔记","url":"/docs/notes/Nginx学习/Nginx学习笔记#名词解释","content":" web服务器： 网页服务器，web server。http ： 超文本传输协议。客户端和服务端请求和应答的标准。pop3、smtp、imap： POP3(Post Offic Protocol 3)邮局协议的第三个版本SMTP(Simple Mail Transfer Protocol)简单邮件传输协议,IMAP(Internet Mail Access Protocol)交互式邮件存取协议通过上述名词的解释，我们可以了解到Nginx也可以作为电子邮件代理服务器 反向代理正向代理  ","version":"Next","tagName":"h2"},{"title":"Nginx优点​","type":1,"pageTitle":"Nginx 学习笔记","url":"/docs/notes/Nginx学习/Nginx学习笔记#nginx优点","content":" 速度更快，并发更高配置简单、扩展性强高可靠性热部署成本低、bsd许可证  ","version":"Next","tagName":"h2"},{"title":"常用基本功能​","type":1,"pageTitle":"Nginx 学习笔记","url":"/docs/notes/Nginx学习/Nginx学习笔记#常用基本功能","content":" 静态资源部署rewrite 地址重写 正则表达式 反向代理的配置负载均衡 轮询、加权轮询、ip_hash、url_hash、fair web缓存环境部署用户认证模块...  Nginx核心组成：  ngnix二进制可执行文件ngnix.config 配置文件error.log 错误的日志记录access.log 访问日志记录  ","version":"Next","tagName":"h2"},{"title":"Nginx 环境准备​","type":1,"pageTitle":"Nginx 学习笔记","url":"/docs/notes/Nginx学习/Nginx学习笔记#nginx-环境准备","content":" nginx官方下载网址：http://nginx.org/en/download.html  VMware WorkStationCentos7MobaXterm网络 ","version":"Next","tagName":"h2"},{"title":"React发展","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React发展","content":"React发展","keywords":"","version":"Next"},{"title":"React Hooks","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React Hooks","content":"React Hooks","keywords":"","version":"Next"},{"title":"常见模式","type":0,"sectionRef":"#","url":"/docs/notes/设计模式/常见设计模式","content":"","keywords":"","version":"Next"},{"title":"1.工厂模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#1工厂模式","content":" 工厂模式（Factory Pattern）：将对象的创建和使用分离，由工厂类负责创建对象并返回。在前端开发中，可以使用工厂模式来动态创建组件。  前端中的工厂模式是一种创建对象的设计模式，它可以让我们封装创建对象的细节，我们使用工厂方法而不是直接调用 new 关键字来创建对象，使得代码更加清晰、简洁和易于维护。在前端开发中，工厂模式通常用于创建多个相似但稍有不同的对象，比如创建一系列具有相同样式和行为的按钮或者表单。  在实现工厂模式时，通常需要创建一个工厂函数（或者叫做工厂类），该函数可以接受一些参数，并根据这些参数来创建对象。例如，我们可以创建一个ButtonFactory函数，它接受一个type参数，用于指定按钮的类型，然后根据type参数创建不同类型的按钮对象。示例代码如下：   function ButtonFactory(type) { switch (type) { case 'primary': return new PrimaryButton(); case 'secondary': return new SecondaryButton(); case 'link': return new LinkButton(); default: throw new Error('Unknown button type: ' + type); } } function PrimaryButton() { this.type = 'primary'; this.text = 'Click me!'; this.onClick = function() { console.log('Primary button clicked!'); }; } function SecondaryButton() { this.type = 'secondary'; this.text = 'Click me too!'; this.onClick = function() { console.log('Secondary button clicked!'); }; } function LinkButton() { this.type = 'link'; this.text = 'Click me as well!'; this.onClick = function() { console.log('Link button clicked!'); }; }   在上面的示例中，ButtonFactory函数接受一个type参数，根据这个参数来创建不同类型的按钮对象。例如，如果type为'primary'，则返回一个PrimaryButton对象，该对象具有type、text和onClick属性，表示一个主要按钮。其他类型的按钮也类似。  使用工厂模式可以让我们将对象创建的过程与具体的业务逻辑分离开来，从而提高代码的可重用性和可维护性。  // 或者可以使用ts 类的方式来创建组件 class Button { type:'primary'| 'secondary'|'link' } class PrimaryButton extends Button{ type:'primary' activeStyle:string } class SecondaryButton extends Button{ type:'secondary' hoverStyle:string } class LinkButton extends Button{ type:'link' href:string }   ","version":"Next","tagName":"h2"},{"title":"2.单例模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#2单例模式","content":" 前端中用的较多（状态管理）  单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问它的全局访问点。在前端开发中，可以使用单例模式来管理全局状态和资源。  在JavaScript中，单例模式可以通过多种方式实现，以下是一些常见的实现方式：  使用对象字面量可以轻松地创建单例对象，例如：  const singleton = { property1: &quot;value1&quot;, property2: &quot;value2&quot;, method1: function () { }, method2: function () { }, };   在JavaScript中，每个构造函数都可以用于创建单例对象，例如：  function Singleton() { if (typeof Singleton.instance === &quot;object&quot;) { return Singleton.instance; } this.property1 = &quot;value1&quot;; this.property2 = &quot;value2&quot;; Singleton.instance = this; } const instance1 = new Singleton(); const instance2 = new Singleton(); console.log(instance1 === instance2);   上述代码中，使用了一个构造函数来创建单例对象。在构造函数中，首先判断是否存在单例实例，如果存在则直接返回该实例，否则创建单例对象并将其保存在 Singleton.instance 属性中。由于JavaScript中每个构造函数本身就是一个单例，因此不需要额外的代码来保证单例。  使用模块模式可以创建一个只有单个实例的对象，例如：  const Singleton = (function () { let instance; function init() { const object = new Object(&quot;I am the instance&quot;); return object; } return { getInstance: function () { if (!instance) { instance = init(); } return instance; }, }; })(); const instance1 = Singleton.getInstance(); const instance2 = Singleton.getInstance(); console.log(instance1 === instance2);   上述代码中，使用了一个立即执行函数来创建单例对象。在该函数中，定义了一个私有变量 instance 用于存储单例实例，而 init 函数则是用于创建单例实例的方法。最后，返回一个对象，该对象包含一个 getInstance 方法，该方法用于获取单例实例。  通过上述方式实现的单例模式，可以确保在程序运行期间，某个类只有一个实例，并且该实例可以在任何地方访问。  ","version":"Next","tagName":"h2"},{"title":"3.发布订阅模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#3发布订阅模式","content":" 前端中用的较多（event, dom event）发布-订阅模式（Publish-Subscribe Pattern）：也叫消息队列模式，它是一种将发布者和订阅者解耦的设计模式。在前端开发中，可以使用发布-订阅模式来实现组件之间的通信。  JavaScript中的发布/订阅模式（Pub/Sub）是一种常用的设计模式。它允许在应用程序中定义对象之间的一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会被通知和更新。  在发布/订阅模式中，有两种类型的对象：发布者和订阅者。发布者是事件的发出者，它通常维护一个事件列表，并且可以向列表中添加或删除事件。当某个事件发生时，它会将这个事件通知给所有订阅者。订阅者则是事件的接收者，它们订阅感兴趣的事件，并且在事件发生时接收通知。。  发布订阅模式可以帮助我们实现松耦合的设计，让对象之间的依赖关系变得更加灵活。它在前端开发中的应用非常广泛，例如 Vue.js 中的事件总线、Redux 中的 store 等。  以下是一个简单的实现发布/订阅模式的示例代码：   var publisher = { events: {}, addEvent: function(event, callback) { if (!this.events[event]) { this.events[event] = []; } this.events[event].push(callback); }, removeEvent: function(event, callback) { if (this.events[event]) { for (var i = 0; i &lt; this.events[event].length; i++) { if (this.events[event][i] === callback) { this.events[event].splice(i, 1); break; } } } }, publishEvent: function(event, data) { if (this.events[event]) { for (var i = 0; i &lt; this.events[event].length; i++) { this.events[event][i](data); } } } }; var subscriber = { handleEvent: function(data) { console.log(data); } }; publisher.addEvent('event1', subscriber.handleEvent); publisher.publishEvent('event1', 'Hello, world!'); publisher.removeEvent('event1', subscriber.handleEvent);   在这个例子中，发布者对象维护了一个事件列表（events），并且提供了添加、删除和发布事件的方法。订阅者对象则提供了一个处理事件的回调函数（handleEvent），它可以被添加到发布者对象的事件列表中。当发布者发布一个事件时，所有订阅了这个事件的订阅者都会收到通知，并执行相应的处理函数。  ","version":"Next","tagName":"h2"},{"title":"4. 观察者模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#4-观察者模式","content":" 前端中用的较多（Rx.js）观察者模式（Observer Pattern）：当对象间存在一对多的关系时，使用观察者模式。当被观察的对象发生变化时，其所有的观察者都会收到通知并进行相应的操作。在JavaScript中，可以使用回调函数或事件监听来实现观察者模式。  在前端开发中，观察者模式常被用来实现组件间的数据传递和事件处理。比如，当一个组件的状态发生改变时，可以通过观察者模式来通知其他组件更新自身的状态或视图。  在观察者模式中，通常会定义两种角色：  以下是一个简单的实现示例：  class Subject { constructor() { this.observers = [] } addObserver(observer) { this.observers.push(observer) } removeObserver(observer) { this.observers = this.observers.filter(obs =&gt; obs !== observer) } notify(data) { this.observers.forEach(obs =&gt; obs.update(data)) } } class Observer { update(data) { console.log(`Received data: ${data}`) } } const subject = new Subject() const observer1 = new Observer() const observer2 = new Observer() subject.addObserver(observer1) subject.addObserver(observer2) subject.notify('Hello, world!') subject.removeObserver(observer1) subject.notify('Goodbye, world!')   在上面的示例中，我们定义了一个 Subject 类和一个 Observer 类。Subject 类有三个方法，addObserver 用于添加观察者，removeObserver 用于移除观察者，notify 用于通知所有观察者。  Observer 类只有一个方法 update，用于接收主题传递的数据。我们创建了两个 Observer 实例并将它们添加到了 Subject 实例中，然后调用了 notify 方法来通知它们更新数据。  在实际开发中，我们通常会使用现成的库或框架来实现观察者模式，比如 React 中的状态管理库 Redux 和事件处理库 EventEmitter。  ","version":"Next","tagName":"h2"},{"title":"5. 装饰器模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#5-装饰器模式","content":" 前端中用的较多（Nest.js, Angular） 装饰者模式（Decorator Pattern）：动态地给一个对象添加额外的职责。在前端开发中，可以使用装饰者模式来动态修改组件的行为和样式。  JavaScript 中的装饰者模式可以通过以下几种方式实现：  const obj = { foo() { console.log('foo'); } } function barDecorator(obj) { obj.bar = function() { console.log('bar'); } return obj; } const decoratedObj = barDecorator(obj); decoratedObj.foo(); decoratedObj.bar();   在上面的示例中，我们首先定义了一个原始对象 obj，它包含一个方法 foo。然后，我们定义了一个装饰函数 barDecorator，它接收一个对象作为参数，用于为这个对象添加一个新的方法 bar。最后，我们使用 barDecorator 函数来扩展原始对象 obj，并得到了一个新的对象 decoratedObj，它包含了原始对象的方法 foo 和新的方法 bar。  function Foo() {} Foo.prototype.foo = function() { console.log('foo'); } function barDecorator(clazz) { clazz.prototype.bar = function() { console.log('bar'); } } barDecorator(Foo); const obj = new Foo(); obj.foo(); obj.bar();   在上面的示例中，我们首先定义了一个原始对象 Foo，它是一个构造函数，用于创建一个对象。然后，我们在原型上定义了一个方法 foo。接着，我们定义了一个装饰函数 barDecorator，它接收一个构造函数作为参数，用于在原型上添加一个新的方法 bar。最后，我们使用 barDecorator 函数来扩展原始对象的原型，然后创建一个新的对象 obj，并使用扩展后的方法 foo 和 bar。  需要注意的是，装饰者模式可以嵌套使用，也就是说，我们可以通过多个装饰函数来依次为一个组件添加多个不同的功能。同时，装饰者模式也可以用于对已有的组件进行扩展，使得我们可以在不改变原有代码的情况下，给组件添加新的行为和样式。 ","version":"Next","tagName":"h2"},{"title":"React源码","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React源码","content":"React源码","keywords":"","version":"Next"},{"title":"react和vue的区别","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React和Vue区别","content":"","keywords":"","version":"Next"},{"title":"设计差异​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#设计差异","content":" 维度\treact\tvue核心定位\t专注 UI 层的声明式渲染库\t渐进式框架（提供完整解决方案） 设计目标\t强调灵活性和组合性（Learn Once, Write Anywhere）\t强调开发体验和易用性（渐进增强） 技术栈扩展\t需要自主选择路由、状态管理方案（如 Redux、MobX）\t官方提供路由（Vue Router）、状态管理（Pinia/Vuex）  ","version":"Next","tagName":"h2"},{"title":"语法对比​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#语法对比","content":" react使用jsx  // 组件逻辑与模板混合编写 function Button({ onClick }) { return ( &lt;button className=&quot;primary-btn&quot; onClick={onClick}&gt; Click Me &lt;/button&gt; ); }   特点：  用 JavaScript 表达 UI（All in JS） 支持完整的 JavaScript 表达式 需要手动绑定事件（如 onClick={handleClick}）  vue使用单文件组件  &lt;template&gt; &lt;button class=&quot;primary-btn&quot; @click=&quot;handleClick&quot;&gt; {{ buttonText }} &lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; const buttonText = 'Click Me'; const handleClick = () =&gt; { /* ... */ }; &lt;/script&gt; &lt;style scoped&gt; .primary-btn { /* 样式 */ } &lt;/style&gt;   特点：  模板、逻辑、样式分离但集中管理 指令系统简化 DOM 操作（如 v-if, v-for） 自动事件绑定（@click 语法糖）  ","version":"Next","tagName":"h2"},{"title":"数据响应​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#数据响应","content":" React 为单项数据流。基于不可变数据，通过setState、useState来触发重新渲染，需要开发者显示调用apiVue 是双向数据绑定。基于Proxy（Vue2是Object.defineProperty）的数据劫持更新。数据自动触发更新不需要手动去更改。  代码对比：  // React：需要手动触发更新 const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); // Vue：数据修改自动响应 const count = ref(0); const increment = () =&gt; count.value++;   ","version":"Next","tagName":"h2"},{"title":"组件的实现​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#组件的实现","content":" React是函数式组件+hooks（v16.9+），之前是使用class类组件的形式。万物皆组件。  特点：  逻辑复用依赖 Hooks（useState/useEffect） 强调纯函数和副作用分离  function UserList() { const [users, setUsers] = useState([]); useEffect(() =&gt; { fetchUsers().then(data =&gt; setUsers(data)); }, []); return ( &lt;ul&gt; {users.map(user =&gt; &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)} &lt;/ul&gt; ); }   Vue是组合式Api  &lt;script setup&gt; import { ref, onMounted } from 'vue'; const users = ref([]); const fetchData = async () =&gt; { users.value = await fetchUsers(); }; onMounted(fetchData); &lt;/script&gt; &lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt;{{ user.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;   特点：  逻辑组合更灵活（类似 React Hooks） 自动追踪依赖，无需手动声明依赖数组  ","version":"Next","tagName":"h2"},{"title":"性能优化策略​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#性能优化策略","content":" React优化手段：memo函数的记忆组件，结合useMemo、useCallback缓存内容。场景：避免不必要的子组件被渲染Vue优化手段：&lt;KeepAlive/&gt;组件自动缓存，computed组件重新计算。依赖追踪粒度到属性级别  ","version":"Next","tagName":"h2"},{"title":"生态链​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#生态链","content":" React: ReactRouter、Redux、ReactNative、Vue:Cli、Vite、Uniapp  ","version":"Next","tagName":"h2"},{"title":"开发场景​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#开发场景","content":" 选择 React： ✅ 大型复杂应用 ✅ 需要高度定制化架构 ✅ 团队有较强 JavaScript 基础  选择 Vue： ✅ 快速开发中小型项目 ✅ 开发者偏好简洁的模板语法 ✅ 需要开箱即用的完整解决方案  ","version":"Next","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#总结","content":" 两者本质都是优秀的 UI 解决方案，React 更注重灵活性和工程化，Vue 更注重开发体验和渐进性。建议根据团队技术栈、项目规模和长期维护需求做选择。 ","version":"Next","tagName":"h2"},{"title":"大文件上传","type":0,"sectionRef":"#","url":"/docs/project_issue/实战场景/大文件上传","content":"","keywords":"","version":"Next"},{"title":"前端如何将大文件进行分片处理？​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#前端如何将大文件进行分片处理","content":"   ","version":"Next","tagName":"h2"},{"title":"1、对File对象进行切片 slice ，得到一个个 Blob类型的文件​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#1对file对象进行切片-slice-得到一个个-blob类型的文件","content":"     使用Blob对象内置的slice方法进行切片    创建createFileChunks函数，将file流给进去，chunkSize为每一份的文件大小（单位是字节），输出切好的每一份文件result。File文件流或者Blob只是保存了文件的基本信息（如名字、大小、地址信息等），并不是文件本身，所以切片的时候不会很慢    File 对象:它表示一组文件，我们使用&lt;input type=&quot;file&quot;&gt;选择文件时，这些文件被存储在 File 对象中。  Blob对象:Blob对象表示二进制数据，常用来表示大型数据对象(如图片音频等)。File对象是Blob对象的一个子类，它继承了Blob对象的所有属性和方法。  formData对象:前端先将文件存储在formData对象中，才能传给后端。  ","version":"Next","tagName":"h3"},{"title":"2、将切好的一个个chunks逐一上传​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#2将切好的一个个chunks逐一上传","content":"   上传的时候，将分片进行逐一上传，如果上传过程中中断了（如网络中断、页面关闭等），之前上传过的分片就不用再上传了，则接着从上次传递完的那个分片开始继续上传，这个叫做切片的文件秒传    原理：    重新上传的时，询问服务器之前上传的阶段是在哪里？上传了哪些编号的分片，还需要上传哪些分片，具体已经上传完成的是哪些切片，还要从第几个开始继续上传？ 服务器需要告知这些信息。  此时需要用一个代表文件分片的Id，可以使用hash值来标识每一份切片。  使用hash来标记，hash是一种算法，可以把任何数据来换算成标记的字符串，（不可逆，只能将数据记录成一段字符串），利用hash值来代表文件切片的整个数据，进行id的记录。因此服务端可以使用切片的hash值来记录当前文件有没有上传过。  常见的hash算法有 md5 ，推荐库为【spark-md5】 ","version":"Next","tagName":"h3"},{"title":"低代码平台物料体系与编排引擎设计重难点","type":0,"sectionRef":"#","url":"/docs/project_issue/低代码平台项目/难点亮点问题","content":"","keywords":"","version":"Next"},{"title":"低代码平台的物料（组件）是怎么管理的，远程物料是如何加载？请详细说明核心流程和方案​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#低代码平台的物料组件是怎么管理的远程物料是如何加载请详细说明核心流程和方案","content":" 插件化设计  webpack、eslint、vue、babel、vite都有插件化身影  ","version":"Next","tagName":"h2"},{"title":"前置知识：插件化设计​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#前置知识插件化设计","content":"  { plugins:[ vue(), splitChunk(), react() ] }   插件化基座插件化协议插件生命周期插件开发 Plugin  ","version":"Next","tagName":"h3"},{"title":"具体模块化定义​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#具体模块化定义","content":" 物料取名：Button、Image、Text、Container  核心系统（BlockSuit类）来更改  ButtonPlugin=&gt; ButtonBlockImagePlugin=&gt; ImageBlockTextPlugin=&gt; TextBlock  物料最重要的两个东西是什么？  数据协议 ： json 数据 表示物料的内容物料渲染引擎 ： 组件视图  数据协议​  案例：  //定义一个按钮插件物料的协议 const ButtonBlock = { type:'button', id:'bt1', props:{ text:'xxxx', }, style:{ color:'#ccc', fontSize:16, backgroundColor:'#000' }, events:{} //定义事件协议 } //定义一个文本插件物料的协议 const TextBlock = { type:'text', id:'t1', props:{ text:'xxxx', }, style:{ color:'#red', fontSize:16, backgroundColor:'#000' }, events:{} //定义事件协议 }   渲染引擎​  组件，用来将json 数据渲染成页面  统一设计一个Renderer，通过策略模式负责数据转化加工、数据到组件的传递、组件渲染  &lt;div&gt; &lt;templete :is={...Block}&gt; ....物料渲染内容 &lt;/templete&gt; &lt;/div&gt;  ","version":"Next","tagName":"h3"},{"title":"webpack性能优化","type":0,"sectionRef":"#","url":"/docs/notes/性能优化/wepack优化","content":"","keywords":"","version":"Next"},{"title":"如何加快构建（打包）速度？​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#如何加快构建打包速度","content":" 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions) 通过 exclude、include 配置来确保转译尽可能少的文件优化 resolve.modules 配置优化 resolve.mainFields 配置aliasnoParseextensions 在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中使用 happypack 开启多进程打包除了使用 Happypack 外，我们也可以使用 thread-loader 开启多进程打包 loader使用 HardSourceWebpackPlugin 为模块提供中间缓存，第二次构建可大量节约时间使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包使用 webpack-parallel-uglify-plugin 开启 JS 多进程压缩  ","version":"Next","tagName":"h2"},{"title":"如何减少打包的体积呢？​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#如何减少打包的体积呢","content":" 引入 webpack-bundle-analyzer 分析打包后的文件，判断哪些包还可以拆分和优化  使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间使用 optimization.splitChunks 配置抽离公共代码使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）使用 url-loader 或 image-webpack-loader 对图片进行转化或者压缩处理优化 SourceMap，开发环境推荐： cheap-module-eval-source-map，生产环境推荐： cheap-module-source-map按需加载，项目中的路由懒加载  webpack自身的优化：  tree-shaking，在生产环境下，会自动移除没有使用到的代码scope hosting 作用域提升，变量提升，可以减少一些变量声明babel 配置的优化，配置 @babel/plugin-transform-runtime，重复使用 Babel 注入的帮助程序，以节省代码大小的插件  ","version":"Next","tagName":"h2"},{"title":"加快构建或打包速度的方法​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#加快构建或打包速度的方法","content":" ","version":"Next","tagName":"h2"},{"title":"使用 speed-measure-webpack-plugin 插件测量打包速度​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#使用-speed-measure-webpack-plugin-插件测量打包速度","content":" 使用 speed-measure-webpack-plugin 插件可以测量各个插件和 loader 所花费的时间，量化打包速度，对比前后的信息，判断优化效果。  使用方式很简单，可以直接用其来包裹 Webpack 的配置:  //webpack.config.js const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;); const smp = new SpeedMeasurePlugin(); const config = { //...webpack配置，不用在写 module.exports } module.exports = smp.wrap(config);   ","version":"Next","tagName":"h3"},{"title":"缩小文件的搜索范围​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#缩小文件的搜索范围","content":" (配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)  exclude/include  在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。  exclude 指定要排除的文件，include 指定要包含的文件。exclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组，尽量避免 exclude，更倾向于使用 include。  例如在配置 babel-loader 时，可以这样：  const path = require('path'); module.exports = { module: { rules: [ { // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 use: ['babel-loader?cacheDirectory'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), }, ] }, };   优化 resolve.modules 配置  使用 resolve 配置 webpack 去哪些目录下寻找第三方模块  当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：  const path = require('path'); module.exports = { //... resolve: { // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], } }   优化 resolve.mainFields 配置  resolve.mainFields 用于配置第三方模块使用哪个入口文件  为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 或 index 字段去描述入口文件的位置，可以这样配置 Webpack：  module.exports = { resolve: { // 采用 main 或 index 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['main', 'index'], }, }; //这个配置一般很较少用，要注意所有第三方模块的入口文件。   resolve.alias  resolve.alias 配置项以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径。  例如使用以下配置：  // Webpack alias 配置 resolve:{ alias:{ components: './src/components/' } }   当你通过 import Button from 'components/button' 导入时，实际上被 alias 等价替换成了 import Button from './src/components/button'。  默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作:  module.exports = { resolve: { // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件， // 减少耗时的递归解析操作 alias: { 'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js'), // react15 // 'react': path.resolve(__dirname, './node_modules/react/umd/react.production.min.js'), // react16 } }, };   除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。  但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 lodash，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。  alias 还支持 $ 符号来缩小范围到只命中以关键字结尾的导入语句：  resolve:{ alias:{ 'react$': '/path/to/react.min.js' } } //react$ 只会命中以 react 结尾的导入语句，即只会把 import 'react' 关键字替换成 import '/path/to/react.min.js'。   noParse  如果一些第三方模块没有 AMD/CommonJS 规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。  在上面的 优化 resolve.alias 配置 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：  const path = require('path'); module.exports = { module: { // 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理 // noParse 属性的值是一个正则表达式或者是一个 function noParse: [/react\\.min\\.js$/] // /jquery|lodash/ }, };   resolve.extensionswebpack 会根据 extensions 定义的后缀查找文件(频率较高的文件类型优先写在前面)， 默认是extensions: ['.js', '.json']`  也就是说当遇到require('./data')这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。  如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：  后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中 频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把require('./data')写成 require('./data.json')  Webpack 配置如下：  module.exports = { resolve: { // 尽可能的减少后缀尝试的可能性 extensions: ['js'], }, };   ","version":"Next","tagName":"h3"},{"title":"使用 cache-loader，将结果缓存中磁盘中​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#使用-cache-loader将结果缓存中磁盘中","content":" 在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 node_modueles/.cache/cache-loader 目录下。它所做的事情很简单，就是 babel-loader 开启 cache 后做的事情，将 loader 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。  安装 npm i cache-loader -Dcache-loader 的配置很简单，放在其他 loader 之前即可。修改Webpack 的配置如下:  module.exports = { module: { // 例如 babel-loader 耗时比较长，给它配置 cache-loader 放在 loader 之前 rules: [ { test: /\\.jsx?$/, use: ['cache-loader','babel-loader'] } ] } }   如果只打算给 babel-loader 配置 cache 的话，也可以不使用 cache-loader，给 babel-loader 增加选项 cacheDirectory。  cacheDirectory：默认值为 false。当设置为 true 时，指定的目录将用来缓存 loader 的执行结果。之后的 Webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。使用默认缓存目录：node_modules/.cache/babel-loader 。   loader: 'babel-loader?cacheDirectory=true'   ","version":"Next","tagName":"h3"},{"title":"使用 happypack 开启多进程打包​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#使用-happypack-开启多进程打包","content":" 受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，解析转换以及代码的压缩中的时间很长，这样就会导致构建时间变长。  HappyPack 的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间:  安装 happypack npm i happypack -D修改配置文件：  const Happypack = require('happypack'); module.exports = { module: { rules: [ { test: /\\.js[x]?$/, use: 'Happypack/loader?id=js', include: [path.resolve(__dirname, 'src')] }, { test: /\\.css$/, use: 'Happypack/loader?id=css', include: [ path.resolve(__dirname, 'src'), path.resolve(__dirname, 'node_modules', 'bootstrap', 'dist') ] } ] }, plugins: [ new Happypack({ id: 'js', // 和rule中的 id=js 对应 // 将之前 rule 中的 loader 删除，在此配置 use: ['babel-loader'] //必须是数组 }), new Happypack({ id: 'css',// 和rule中的 id=css 对应 use: ['style-loader', 'css-loader','postcss-loader'], }) ] }   ","version":"Next","tagName":"h3"},{"title":"thread-loader​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#thread-loader","content":" 除了使用 Happypack 外，我们也可以使用 thread-loader ，把 thread-loader 放置在其它 loader 之前，那么放置在这个 loader 之后的 loader 就会在一个单独的 worker 池中运行。  在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：  这些 loader 不能产生新的文件。这些 loader 不能使用定制的 loader API（也就是说，通过插件）。这些 loader 无法获取 webpack 的选项设置  npm i thread-loader -D  module.exports = { module: { // 配置 thread-loader 放在所有 loader 之前（包括 cache-loader） rules: [ { test: /\\.jsx?$/, use: ['thread-loader', 'cache-loader', 'babel-loader'] } ] } }   ","version":"Next","tagName":"h3"},{"title":"使用 hard-source-webpack-plugin 为模块提供中间缓存​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#使用-hard-source-webpack-plugin-为模块提供中间缓存","content":" HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。  配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。  安装依赖: npm i hard-source-webpack-plugin -Doptions  //webpack.config.js var HardSourceWebpackPlugin = require('hard-source-webpack-plugin'); module.exports = { plugins: [ new HardSourceWebpackPlugin() ] }   需要注意的是 hard-source-webpack-plugin 存在一些坑，如果遇到某些配置不生效了，例如热更新失效，或者某些配置不生效等，可以查看HardSourceWebpackPlugin文档 ，文档中列出了一些你可能会遇到的问题以及如何解决  ","version":"Next","tagName":"h3"},{"title":"使用 IgnorePlugin 忽略第三方包指定目录​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#使用-ignoreplugin-忽略第三方包指定目录","content":" IgnorePlugin 是 webpack 的内置插件，作用是忽略第三方包指定目录。例如: moment (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnorePlugin 在打包时忽略本地化内容  //webpack.config.js module.exports = { plugins: [ // 忽略 moment 下的 ./locale 目录 new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ] }   忽略 moment 下的 ./locale 目录后，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:  import moment from 'moment'; import 'moment/locale/zh-cn';// 手动引入自己需要的语言包   index.js 中只引入 moment，打包出来的 bundle.js 大小和配置了 IgnorePlugin，单独引入 moment/locale/zh-cn，构建出来的包大小为大概差距有 200k 左右。  ","version":"Next","tagName":"h3"},{"title":"关于使用 webpack-parallel-uglify-plugin 增强代码压缩​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#关于使用-webpack-parallel-uglify-plugin-增强代码压缩","content":" 在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。  但是在 webpack4.x 内置默认使用 TerserWebpackPlugin，在 mode 设置为 production 就会默认开启 TerserWebpackPlugin，所以可以不用配置 webpack-parallel-uglify-plugin  ","version":"Next","tagName":"h3"},{"title":"减少打包文件体积​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#减少打包文件体积","content":" ","version":"Next","tagName":"h2"},{"title":"引入 webpack-bundle-analyzer 分析打包后的文件​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#引入-webpack-bundle-analyzer-分析打包后的文件","content":" 借助 webpack-bundle-analyzer 可以分析打包后的文件，判断哪些包体积过大，是否可以拆分和优化  安装依赖 npm i webpack-bundle-analyzer -D   const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = { plugins: [ new BundleAnalyzerPlugin({ analyzerHost: '127.0.0.1', // 默认这两个配置都可以不配 analyzerPort: 8889 // 默认 8888 }), ] }   接下来在 package.json 里配置启动命令 (不配置也可以，npm run build 打包时，会默认打开：localhose:8888  //package.json &quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot; // 复制代码 windows 请安装 npm i -D cross-env &quot;analyz&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot; // 复制代码接下来 npm run analyz 浏览器会自动打开文件依赖图的网页   使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN  如果我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 Externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 Externals 的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 CDN 的方式，去引用它们.  官方案例:  &lt;script src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;&gt;&lt;/script&gt;   module.exports = { //... externals: { jquery: 'jQuery' } }; // 这里需要注意，’:’ 号后面对应的文件名必须和项目里面 import 引入的文件昵称相同，例如： import Vue from 'vue' 就是上面对应的 'vue': 'Vue'。 // 这里特别注意一下 element-ui 的昵称必须是: ‘ELEMENT’, 如果使用其它昵称将报错。具体看 element-ui 源码导出方式你就懂了~   // 项目中也可以正常 import import $ from 'jquery'; $('.my-element').animate(/* ... */);   在项目中经常把各种库文件使用 CDN 加载，然后通过 html-webpack-plugin 插入到模板页面中。  使用 DllPlugin（动态链接库）将 bundles 拆分  有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 bundles。  使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码和不会频繁更新的库先打包成静态资源，避免反复编译浪费时间。例如我们将 react 和 react-dom 单独打包成一个动态链接库：   const webpack = require('webpack'); const path = require('path'); module.exports = { entry: { react: ['react', 'react-dom'] }, mode: 'production', output: { filename: '[name].dll.[hash:6].js', path: path.resolve(__dirname, 'dist', 'dll'), library: '[name]_dll' // 暴露给外部使用 // libraryTarget 指定如何暴露内容，缺省时就是 var }, plugins: [ new webpack.DllPlugin({ // name 和 library一致 name: '[name]_dll', path: path.resolve(__dirname, 'dist', 'dll', 'manifest.json') //manifest.json 的生成路径 }) ] }   使用 optimization.splitChunks 配置抽离公共代码  抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。  抽离公共代码是 webpack 内置的，在 optimization.splitChunks 中配置：   module.exports = { optimization: { splitChunks: {// 分割代码块 cacheGroups: { vendor: { // 第三方依赖 priority: 1, // 设置权重，首先抽离第三方模块 name: 'vendor', test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 3 //最少引入了3次 }, //缓存组 common: { // 公共模块 chunks: 'initial', name: 'common', minSize: 10, // 大小超过10个字节 minChunks: 2 // 最少引入了2次 } } } } }   使用 url-loader 和 image-webpack-loader 对图片进行转化和压缩处理 如果本地图片比较多的话，采用 image-webpack-loader 压缩后，再对比较小的图片根据 url-loader 来进转化为 base64 格式，可以有效减少打包文件的体积和图片的 http 请求数量。  // 配置（注意 loader 从上到下，先右后左执行）： module.exports = { module: { rules: [ { test: /\\.(png|gif|jpe?g|svg)$/i, exclude:[path.resolve(process.cwd(), 'src/assets/css')], use: [ { loader: 'url-loader', options: { limit: 1024, name: '[hash:8].[ext]', useRelativePath: false, outputPath: function(fileName){ return 'assets/images/'+fileName } } }, { loader:'image-webpack-loader' } ] } ] } }   优化 source map  什么是 source map？  我们打包，将开发环境中的源代码经过压缩，去空格，babel 编译转化，最终可以得到适用于生产环境的代码。但这样处理后的代码和源代码之间存在很大的差异，难以阅读且无法 debug。  如果压缩等处理过的生产环境中的代码出现 bug，那么调试的时候只能定位到压缩处理后的代码的位置，无法定位到开发环境中源码位置。source map 就是为解决上述的代码定位问题。方便开发人员 debug，定位错误。  开发环境推荐使用：cheap-module-eval-source-map  生产环境推荐使用：cheap-module-source-map  在不同环境中如何选择 source map 的类型  首先在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系。因此，不管是开发还是生产环境都会增加 cheap 属性来忽略模块打包后的列信息关联  不管是生产环境还是开发环境，我们都需要定位 debug 到最原始的资源，比如定位错误到 jsx，ts 的原始代码，而不是经编译后的 js 代码。所以不可以忽略掉 module 属性  需要生成 .map 文件，所以得有 source-map 属性 . 可见文档webpack-devtool  按需加载  通过路由懒加载  ","version":"Next","tagName":"h3"},{"title":"关于webpack 5 的优化​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#关于webpack-5-的优化","content":" ","version":"Next","tagName":"h2"},{"title":"剔除npm包里面针对Node.js模块自动引用的Polyfills​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#剔除npm包里面针对nodejs模块自动引用的polyfills","content":" Webpack 4.x 编译引入 npm 包，有些 npm 包里面包含针对 nodejs 的 polyfills，polyfill 会加到最终的 bundle 中，实际前端浏览器是不需要的，5.x 后的版本会自动剔除  Webpack 5.x 版本编译中，会出现 polyfill 添加提示，如果不需要 node polyfille,按照提示 alias 设置为 false 即可   // webpack.config.js resolve: { // 1.不需要 node polyfilss alias: { crypto: false }, // 2.若需要，可以手动添加 polyfills // fallback: { // &quot;crypto&quot;: require.resolve('crypto-browserify') // } }   ","version":"Next","tagName":"h3"},{"title":"长期缓存优化​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#长期缓存优化","content":" Webpack 4.x 是根据代码的结构生成 chunkhash，现在 5.x 根据完全内容生成 chunkhash，比如改了内容的注释或者变量则不会引起 chunkhash 的变化，让浏览器继续使用缓存：  Webpack 5.x 针对 moduleId 和 chunkId 的计算方式进行了优化，增加确定性的 moduleId 和 chunkId 的生成策略。moduleId 根据上下文模块路径，chunkId 根据 chunk 内容计算，最后为 moduleId 和 chunkId 生成 3 ~ 4 位的数字 id，实现长期缓存，生产环境下默认开启。  ","version":"Next","tagName":"h3"},{"title":"持久缓存优化​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#持久缓存优化","content":" 在 Webpack 4.x 我们一般采用 cache-loader 或者 babel-loader 自带的 cacheDirectory 来进行缓存操作，在 Webpack 5.x 中缓存默认是 memory，你可以修改设置写入硬盘：  module.exports = { cache: { // 1. 将缓存类型设置为文件系统 type: 'filesystem', // 默认是memory // 2. 将缓存文件夹命名为 .temp_cache, // 默认路径是 node_modules/.cache/webpack cacheDirectory: path.resolve(__dirname, '.temp_cache') } }   第一次构建是一次全量构建，它会利用磁盘模块缓存(以空间换时间)，使得后续的构建从中获利  续构建具体流程是：读取磁盘缓存 -&gt; 校验模块 -&gt; 解封模块内容。  ","version":"Next","tagName":"h3"},{"title":"更好的Tree Shacking(构建优化)​","type":1,"pageTitle":"webpack性能优化","url":"/docs/notes/性能优化/wepack优化#更好的tree-shacking构建优化","content":"","version":"Next","tagName":"h3"},{"title":"Echarts 大数据优化方案","type":0,"sectionRef":"#","url":"/docs/project_issue/实战场景/Echarts大数据优化","content":"","keywords":"","version":"Next"},{"title":"数据分段加载（dataZoom）​","type":1,"pageTitle":"Echarts 大数据优化方案","url":"/docs/project_issue/实战场景/Echarts大数据优化#数据分段加载datazoom","content":" echarts内置的配置  dataZoom:[{ type:'slider', xAxisIndex:[0], start:0,//数据窗口范围起始百分比 end:2,//数据窗口范围结束百分比 minSpan:0,//窗口大小最小值 maxSpan:20 //窗口大小最大值 }]   ","version":"Next","tagName":"h2"},{"title":"降采样策略（Sampling）​","type":1,"pageTitle":"Echarts 大数据优化方案","url":"/docs/project_issue/实战场景/Echarts大数据优化#降采样策略sampling","content":" series:[{ ..., sampling:'lttb' ,//最大程度保证采样后线条的趋势，形状和极值 }]  ","version":"Next","tagName":"h2"},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/project_issue/intro","content":"关于 在这里整理记录项目中出现的疑难场景及解决方案","keywords":"","version":"Next"},{"title":"各种 css 样式场景问题积累","type":0,"sectionRef":"#","url":"/docs/project_issue/实战css样式问题积累/各种样式场景","content":"","keywords":"","version":"Next"},{"title":"如何实现一个卡片样式的翻转​","type":1,"pageTitle":"各种 css 样式场景问题积累","url":"/docs/project_issue/实战css样式问题积累/各种样式场景#如何实现一个卡片样式的翻转","content":" .card { top: 50%; background: 口#6fe381; line-height: 0; transform: rotateX(180deg); transform-origin: center top; // transform 翻转的轴设置 backface-visibility: hidden; // 卡片的背面不透明 transition: 0.5s; z-index: 10; }   主要是使用 transform: rotateX(180deg);\\ transform-origin: center top;\\ backface-visibility: hidden;  ","version":"Next","tagName":"h2"},{"title":"css滤镜 filter​","type":1,"pageTitle":"各种 css 样式场景问题积累","url":"/docs/project_issue/实战css样式问题积累/各种样式场景#css滤镜-filter","content":" filter是滤镜效果，会针对对应的div内所有的图形像素点做算法  给每个像素点使用阴影  filter：drop-shadow(5px 5px 4px rgb(0,0,0)) 类似box-shadow  高斯模糊，模拟模糊  filter:blur(10px) 设置模糊半径  磨砂效果 backdrop-filter:blur(10px)   设置对比度  filter：contrast(11) 值越大，对比度越大，颜色对比差异越明显  设置灰度  filter:grayscale(1) 设置灰度值，1 为灰色。 比如遇到清明纪念日场景，需要网页变成灰色  设置色相环，改变色相  filter:hue-rotate(120deg) 改变色相 ","version":"Next","tagName":"h2"},{"title":"Vue3","type":0,"sectionRef":"#","url":"/docs/notes/Vue/Vue3笔记","content":"","keywords":"","version":"Next"},{"title":"编码规范​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#编码规范","content":" js+ts组合式apisetup语法糖  ","version":"Next","tagName":"h2"},{"title":"核心语法​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#核心语法","content":" ","version":"Next","tagName":"h2"},{"title":"组合式API​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#组合式api","content":" vue2是options api ，配置的 vue3是composition api ，组合式  把vue2的data、methods、watch结合升级，把同一个数据的监听、方法综合到一起  ","version":"Next","tagName":"h3"},{"title":"setup​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#setup","content":" setup 是 Vue3 中一个新的配置项，值是一个函数，它是Composition API“表演的舞台”，组件中所用到的数据、方法、计算属性、监视.….等等，均配置在 setup 中。  特点：  setup函数  export default { setup(){ // vue3中弱化this let a=1 function clickHandle(){ console.log(1) } } }   ","version":"Next","tagName":"h3"},{"title":"setup返回值​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#setup返回值","content":" ","version":"Next","tagName":"h3"},{"title":"setup 和 vue2 options api​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#setup-和-vue2-options-api","content":" 可以共存。在vue2 options api中可以使用 this 来获取setup中定义的变量，但setup中不能获取data()的数据。  引入setup语法糖，可以直接写在&lt;script&gt;标签上写setup，不用export了  &lt;script lang='ts' setup&gt; let a=1 function clickHandle(){ ... } &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"ref创建基本响应式数据​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#ref创建基本响应式数据","content":" 通过ref来创建响应式数据  &lt;script setup&gt; import {ref} from 'vue' let name = ref('张三') // ref方法来创建响应式的数据，并赋默认值 let age = ref(2) let address = ref('北京市') &lt;/script&gt;   返回值是一个 RefImpl的实例对象，简称ref对象，ref对象的.value属性是响应的。ref定义的变量不是响应的，ref对象的value才是响应的  修改数据的时候是修改 xxx.value 的值，但在模版中使用时不需要.value，直接使用ref定义的变量即可  ref也可以用来定义对象类型的响应式数据。  ref定义对象的时候，也是使用proxy来封装   &lt;script setup&gt; import {ref} from 'vue' let car = ref({ carName:'奔驰', price:'230000', type:'轿车' }) function edit(){ car.value.carName = '宝马' } &lt;/script&gt; &lt;template&gt; {{car.value.carName}} //先.value 获取 &lt;/template&gt;   ","version":"Next","tagName":"h3"},{"title":"reactive创建对象响应式数据​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#reactive创建对象响应式数据","content":" 使用reactive 定义对象类型的响应式数据，生成proxy代理的对象。且只能定义对象类型。  &lt;script setup&gt; import {reactive} from 'vue' let car = reactive({ carName:'奔驰', price:'230000', type:'轿车' }) &lt;/script&gt;   reactive 定义的数据，取值是直接去获取对象的值，不需要使用.value ，修改也是直接去修改。  ","version":"Next","tagName":"h3"},{"title":"ref对比reactive​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#ref对比reactive","content":" 宏观角度：  ref定义：基本数据类型、对象数据类型reactive只用来定义对象数据类型  区别：  ref创建的数据必须使用.value 来获取值.(可以用插件【vue-office】)reactive重新分配一个新对象，会失去响应式，可以使用（Object.assign）去整体替换  let car = reactive({ carName:'奔驰', price:'230000', type:'轿车' }) function edit(){ car = {carName:&quot;宝马&quot;} //对reactive定义的对象重新赋值新的对象，会导致car不再具有响应式 car = reactive({carName:&quot;宝马&quot;} ) //这样也不行，页面不更新 //只能使用下面这种方式 Object.assign(car,{carName:'宝马'}) } //ref定义的对象可以直接.value去修改   使用原则：  若需要一个基本类型的响应式数据，必须用ref如果要一个对象类型的数据，并且层级不复杂，ref,reactive都可以如果要一个层级深的对象类型数据，建议reactive  ","version":"Next","tagName":"h3"},{"title":"toRefs和toRef​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#torefs和toref","content":" let person = reactive({ name:'xxx', age:12 }) let {name,age} = toRefs(person) //把person都结构 // 可以直接改name了 name.value = 'aaaa' name.value = 123 let n = toRef(person,'age') //toRef 是对属性单独结构 n.value = 4   ","version":"Next","tagName":"h3"},{"title":"computed 计算属性​","type":1,"pageTitle":"Vue3","url":"/docs/notes/Vue/Vue3笔记#computed-计算属性","content":"","version":"Next","tagName":"h3"},{"title":"JavaScript基础整理","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/JavaScrpit基础","content":"","keywords":"","version":"Next"},{"title":"数据类型、变量和变量提升​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数据类型变量和变量提升","content":" ","version":"Next","tagName":"h2"},{"title":"数据类型​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数据类型","content":" 在 JavaScript 中，我们可以分成两种类型：  基本类型复杂类型 两种类型的区别是：存储位置不同  基本类型主要为以下6种：  Number  // 数值最常⻅的整数类型格式则为⼗进制，还可以设置⼋进制（零开头）、⼗六进制（0x开头） let intNum = 55 // 10进制的55 let num1 = 070 // 8进制的56 let hexNum1 = 0xA //16进制的10 // 浮点类型则在数值汇总必须包含⼩数点，还可通过科学计数法表示 let floatNum1 = 1.1; let floatNum2 = 0.1; let floatNum3 = .1; // 有效，但不推荐 let floatNum = 3.125e7; // 等于 31250000 // 在数值类型中，存在⼀个特殊数值 NaN ，意为“不是数值”，⽤于表示本来要返回数值的操作失败了 // （⽽不是抛出错误） console.log(0/0); // NaN console.log(-0/+0); // NaN   String  字符串可以使⽤双引号（&quot;）、单引号（'）或反引号（`）标示  let firstName = &quot;John&quot;; let lastName = 'Jacob'; let lastName = `Jingleheimerschmidt`   字符串是不可变的，意思是⼀旦创建，它们的值就不能变了  let lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; // 先销毁再创建   Boolean  Boolean （布尔值）类型有两个字⾯值： true 和 false  通过 Boolean 可以将其他类型的数据转化成布尔值  数据类型\t转换为 true 的值\t转换为 false 的值String\t⾮空字符串\t&quot;&quot; Number\t⾮零数值（包括⽆穷值）\t0 、 NaN Object\t任意对象\tnull Undefined\tN/A （不存在）\tundefined  Undefined  Undefined 类型只有⼀个值，就是特殊值 undefined 。当使⽤ var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值  let message; console.log(message == undefined); // true // 包含 undefined 值的变量跟未定义变量是有区别的 let message; // 这个变量被声明了，只是值为 undefined console.log(message); // &quot;undefined&quot; console.log(age); // 没有声明过这个变量，报错   null  Null 类型同样只有⼀个值，即特殊值 null.  只要变量要保存对象，⽽当时⼜没有那个对象可保存，就可⽤ null 来填充该变量  逻辑上讲， null 值表示⼀个空对象指针，这也是给 typeof 传⼀个 null 会返回 &quot;object&quot; 的原因  let car = null; console.log(typeof car); // &quot;object&quot; 所以使用typeof判断null值会出问题   undefined 值是由 null 值派⽣⽽来  console.log(null == undefined); // true   symbol es6+新增  Symbol （符号）是原始值，且符号实例是唯⼀、不可变的。符号的⽤途是确保对象属性使⽤唯⼀标识 符，不会发⽣属性冲突的危险  let genericSymbol = Symbol(); let otherGenericSymbol = Symbol(); console.log(genericSymbol == otherGenericSymbol); // false let fooSymbol = Symbol('foo'); let otherFooSymbol = Symbol('foo'); console.log(fooSymbol == otherFooSymbol); // false   BigInt es6+新增最大安全数字Number.MAX_SAFE_INTEGER =9007199254740991。必须是整数，不能是小数！  var obj=456n;此时obj就是最大数数据类型，而不是数字数据类型了 console.log(Symbol() == Symbol()); //false console.log(Symbol('AA') == Symbol('AA')); //false let n = Symbol('AA'); let m = n; console.log(n == m); //true   复杂数据类型，又成引用数据类型  ObjectArrayFunction  引用类型，栈内存中存储的是引用地址，堆内存中存储的是实际的值  ","version":"Next","tagName":"h3"},{"title":"变量提升​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#变量提升","content":" 提到变量提升，首先要引入一个“预编译的概念”。  预编译是JavaScript中一个重要的概念，经常出现在面试中。JavaScript中的&quot;var&quot;变量提升和预编译是紧密相关的概念，它们在理解JavaScript中变量声明和作用域的工作方式时非常重要。今天我们来深入聊聊预编译，让大家理解预编译和变量提升的底层逻辑。本文会使用简单的例子以及通俗易懂的语言，小白没压力。  关于变量提升，先看代码：   var a = 123 console.log(a); // 很明显，答案输出123.让我们对这串代码改动一下。 console.log(x); // 输出undefined var x = 5;   按正常逻辑来说，这串代码应该会报错，但是我们可以发现实际上输出的是undefined,这是因为使用var声明变量会出现变量提升的效果，就相当于：   var a console.log(a); a = 5 // 这就是变量提升   注意：  使用var时， 会现将var定义变量提升到作用域的顶部，供使用然后再赋值。  console.log(a) var a= 1 console.log(a) // undefined,1 //相当于： var a ; console.log(a); a =1 ; console.log(a) //先将变量做提升 声明   关于var的作用域范围。只有函数作用域能影响var，{}块级不能影响.  //函数会影响var的作用域 function f (){ var a= 1 } console.log(a) // error: a is not defined //括号不能影响var的作用域 if(true){ var a= 1 } console.log(a) // 1 //或者 直接使用括号的情况 { var a = 1; } console.log(a) //1   所以当遇到for循环+var、let的情况时：  for(var i = 0 ;i &lt; 3 ; i++){ console.log(i) setTimeout(()=&gt;{ console.log(i) },3000) } //以上情况等价于 var i ; for(i = 0;i&lt;3;i++){ console.log(i) setTimeout(()=&gt;{ console.log(i) },1000) } //结果：0 1 2 3 3 3 //解析： var提升到外部，三次循环都是公用的同一个i，计时器1s之后执行函数去打印，此时i经过循环已经变成3，所以三次计时器中的console.log都是取得循环三次后的i值3 //换成使用let定义的话，则不会变量提升，每次循环都是单独的let值，123   在JavaScript中，变量声明（使用var关键字）会被&quot;提升&quot;到其作用域的顶部，这意味着在变量声明之前使用变量是合法的，尽管在代码中实际声明变量的位置之前。这是因为JavaScript引擎在执行代码之前会将变量声明提升到作用域的顶部。  又比如：  function example() { console.log(x); // 输出 undefined var x X = 5 console.log(x); // 输出 5 } example(); //以上代码相当于： function example() { var x console.log(x); // 输出 undefined x = 5; console.log(x); // 输出 5 } example();   那为什么会变量提升呢？  JavaScript的编译过程通常分为两个主要步骤：预编译（Compilation）和执行（Execution）。预编译是指JavaScript引擎在实际执行代码之前，对代码进行一些处理，包括变量提升和函数声明。在预编译阶段，JavaScript引擎会扫描代码，找到所有变量声明和函数声明，并将它们提升到适当的作用域。  预编译发生在函数执行之前 预编译发生在全局区  预编译发生在函数执行之前  创建AO对象 （Action Object） 找形参和变量声明，将变量声明和形参作为AO的属性名，值为undefined 将形参和实参值统一 在函数体内找函数声明，将函数名作为AO对象的属性名，值赋予函数体  就拿上述为例：  function example(x) { console.log(x); //输出 2 var x x = 5 console.log(x); //输出 5 } example(2); //1.首先我们先创建一个AO对象 AO:{ //2.开始找变量声明和形参 x : undefined //3.将形参和实参值统一 x :undefined ==&gt; x : 2 //4.由于函数体内没有函数声明，跳过该步骤 }   我们已经完成一次预编译了，现在函数开始执行，由上到下，当函数执行到第一个 console.log(x) 时，它将从AO对象中寻找x的值，输出为2.函数继续向下执行，变量声明，跳过，当发现赋值语句 x = 5时，将AO对象中x的值改变为5. 函数继续向下执行到 第二个console.log(x) 时，输出为 5.  接下来我们一起来看看一道有点难度的题  function foo(a, b) { console.log(a); //输出 1 c = 0 var c; a = 3 // a : undefined ==&gt; 3 函数执行时 b = 2 // b : undefined ==&gt; 2 console.log(b); // 输出 2 function b() { } function d() { } console.log(b); // 输出 2 } foo(1) //那是怎么预编译呢？ AO：{ a : undefined ==&gt; a : 1 //统一值 b : undefined ==&gt; b : function b(){} c : undefined ==&gt; d : function d(){} //函数声明，属性名为函数名，值赋予函数体 } //当编译完成后再去执行函数，这样我们就很容易得出答案啦。   预编译发生在全局区  ①创建GO对象 （Global Object）  ②找变量声明，将变量声明作为GO的属性名，值为undefined  ③在全局找函数声明，将函数名作为GO对象的属性名，值赋予函数体  我们直接上例子看看是怎么个事  var a = 100 function fn() { console.log(a); } //解析 GO：{//找变量声明 a : undefined //找函数声明 fn : function fn() } fn()   但我们可以发现，函数预编译和全局预编译在一段代码中通常一起发生，比如上图，当预编译全局完成时，开始执行，当执行完 a = 100后，准备执行函数fn(),这时预编译发生在函数执行时。  再来一个例子，他们结合在一起时：  a = 100 function fn() { console.log(a); // 输出 100 b = 200 var b // 输出 200 console.log(b) } fn() var global //预编译完成之后 ，我们发现这样GO对象和AO对象都会存在： GO: { a : undefined fn : function fn() } AO: { b : undefined }   AO里面没有a，为什么当console.log(a)时会输出呢？而我们发现，GO函数里有a,是不是用了GO里面的a呢？这里我们就要引出调用栈的概念了  上面所说的AO、GO对象其实是属于执行上下文的一部分，便于我们理解  调用栈用于跟踪函数的调用顺序和执行上下文的管理。每当函数被调用，一个新的执行上下文会被推入调用栈，表示该函数的执行。  全局预编译和函数预编译的结果在执行上下文中存储，然后被推入调用栈。调用栈的顶部始终包含当前正在执行的函数的上下文。  全局执行上下文分为变量环境和词法环境，而我们用var声明的变量存在变量环境中。我们都知道栈是先进后出，为什么这里全局执行上下文在栈底部呢，也就是比fn执行上下文先进来，因为在调用栈中，全局预编译通常会在函数预编译之前完成，因此全局预编译的结果位于调用栈的底部，而函数的预编译结果则根据函数调用的顺序依次位于调用栈中。  当函数执行时，需要输出a，但是在fn执行上下文里面并没有找到a这个东西，如果变量在当前函数的执行上下文找不到，JavaScript引擎会在全局执行上下文中寻找变量  详细可参考文章var为什么会变量提升？一盏茶的功夫让你彻底熟悉预编译  ","version":"Next","tagName":"h3"},{"title":"作用域、作用域链、执行上下文​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#作用域作用域链执行上下文","content":" 作用域  作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)  作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)  作用域分为：  全局作用域函数作用域块级作用域  作用域链  作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。  JS执行上下文栈(后面简称执行栈)  执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：  首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。  ","version":"Next","tagName":"h2"},{"title":"闭包​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#闭包","content":" 闭包的核心是函数能够记住并访问其词法作用域（lexical scope），即使该函数在其词法作用域之外执行。  function outer() { let count = 0; return function inner() { // inner函数持有对count的引用，形成闭包 return ++count; }; } const counter = outer(); counter(); // 1 counter(); // 2   ","version":"Next","tagName":"h2"},{"title":"原型和原型链​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#原型和原型链","content":" ","version":"Next","tagName":"h2"},{"title":"深拷贝和浅拷贝​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#深拷贝和浅拷贝","content":" ","version":"Next","tagName":"h2"},{"title":"对象​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#对象","content":" ","version":"Next","tagName":"h2"},{"title":"数组​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数组","content":" ","version":"Next","tagName":"h2"},{"title":"字符串​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#字符串","content":" ","version":"Next","tagName":"h2"},{"title":"dom操作​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#dom操作","content":" ","version":"Next","tagName":"h2"},{"title":"bom​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#bom","content":"","version":"Next","tagName":"h2"},{"title":"JavaScript基础面试题","type":0,"sectionRef":"#","url":"/docs/interview/JS基础面试题","content":"","keywords":"","version":"Next"},{"title":"document load 和 document ready 的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#document-load-和-document-ready-的区别","content":" Document.onload 是在结构和样式加载完才执⾏ js。 window.onload：不仅仅要在结构和样式加载完，还要执⾏完所有的样式、图片这些资源文件，全部 加载完才会触发window.onload事件。 Document.ready 原⽣种没有这个⽅法，jquery 中有$().ready(function)。  ","version":"Next","tagName":"h2"},{"title":"undefined 的三种情况​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#undefined-的三种情况","content":" ⼀个变量定义了却没有被赋值。⼀个对象上不存在的属性或者⽅法。⼀个数组中没有被赋值的元素。  ","version":"Next","tagName":"h2"},{"title":"生成随机数的写法​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#生成随机数的写法","content":" Math.round(Math.random()*差值)+最小的值   ","version":"Next","tagName":"h2"},{"title":"link 与 import 的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#link-与-import-的区别","content":" link 不仅仅可以加载css，import 只能加载css。link 同时加载，import 先载入页面内容。link 无兼容问题。link ⽀持使⽤Javascript控制DOM去改变样式；⽽@import不⽀持。  ","version":"Next","tagName":"h2"},{"title":"null和undefined的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#null和undefined的区别","content":" null 表示一个&quot;无&quot;的对象，也就是该处不应该有值；而 undefined 表示未定义。 在转换为数字时结果不同，Number(null) 为 0，而 undefined 为 NaN。  使用场景上：  null： 作为函数的参数，表示该函数的参数不是对象作为对象原型链的终点undefined: 变量被声明了，但没有赋值时，就等于 undefined 调用函数时，应该提供的参数没有提供，该参数等于 undefined对象没有赋值属性，该属性的值为 undefined函数没有返回值时，默认返回 undefined  ","version":"Next","tagName":"h2"},{"title":"js数组去重？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#js数组去重","content":" filter 过滤去重[...new Set(arr)]，es6最常用  //不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉 {} 空对象，后面的高阶方法会添加去掉重复 {} 的方法。 function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {}, {}]   for 循环嵌套，利用 splice 去重，es5最常用  //双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值 function unique(arr){ for(var i=0; i&lt;arr.length; i++){ for(var j=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; } } } return arr; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}] //NaN和{}没有去重，两个null直接消失了   新建数组，利用 indexOf 或者 includes 去重先用sort排序，然后用一个指针从第0位开始，配合 while 循环去重  关于js去重详细内容参考文档  ","version":"Next","tagName":"h2"},{"title":"apply， call ，bind 三者的相同点及区别​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#apply-call-bind-三者的相同点及区别","content":" 相同点: .bind(), .call(), 和 .apply() 是 JavaScript 中用于改变函数执行上下文（即函数内部的 this 值）的方法，第一个参数都是 this 要指向的对象  不同点：  call 和 aplly 的区别只是在与参数不同，call 的第二个参数是目标函数的第一个参数，第三个是目标函数的第二个参数以此类推，apply 的第二个参数是个数组，数组里面的每一项一次是目标函数的参数bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用  .bind() 方法：  .bind() 方法会创建一个新函数，并将指定的对象作为新函数的执行上下文（即绑定 this 值）。.bind() 方法返回一个绑定了指定上下文的新函数，而不会立即执行原函数。可以通过 .bind() 方法绑定上下文，并传递参数给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; const greetPerson = greet.bind(person); greetPerson('Alice'); // 输出: Hello, Alice! I'm John.   .call() 方法：  .call() 方法立即调用原函数，并将指定的对象作为原函数的执行上下文（即绑定 this 值）。可以通过 .call() 方法指定上下文，并传递参数给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; greet.call(person, 'Alice'); // 输出: Hello, Alice! I'm John.   .apply() 方法： .apply() 方法立即调用原函数，并将指定的对象作为原函数的执行上下文（即绑定 this 值）。 与 .call() 方法不同的是，.apply() 方法接受一个数组作为参数，数组中的元素将作为参数传递给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; greet.apply(person, ['Alice']); // 输出: Hello, Alice! I'm John.   总结：  .bind() 方法创建一个新函数并绑定上下文，不立即执行。  .call() 方法立即调用函数并绑定上下文，可以传递参数。  .apply() 方法立即调用函数并绑定上下文，接受一个参数数组。  选择使用哪种方法取决于需要何时绑定上下文以及是否需要传递参数  ","version":"Next","tagName":"h2"},{"title":"说说回流（重排）和重绘？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说说回流重排和重绘","content":" 浏览器渲染机制 浏览器采用流式布局模型（Flow Based Layout） 浏览器会把HTML解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就产生了渲染树（Render Tree）。  有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，合成布局树，最后把节点绘制到页面上。  由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。  注意：上面说的是首先会生成 Render Tree，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成 Render Tree 的过程了。而布局树的信息已经非常完善，完全拥有 Render Tree 的功能。  重绘 由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。 回流 回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流 浏览器优化 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。  offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightwidth、heightgetComputedStyle()getBoundingClientRect()  减少重绘与回流  使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局  避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。  尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。  避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。  将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。  避免使用 CSS 表达式，可能会引发回流。  将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。  CSS3 硬件加速（GPU加速），使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。  JavaScript:  避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。  避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。  避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。  对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。  ","version":"Next","tagName":"h2"},{"title":"深拷贝浅拷贝的区别？如何实现一个深拷贝？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#深拷贝浅拷贝的区别如何实现一个深拷贝","content":" 前面文章我们讲到，JavaScript中存在两大数据类型：  基本类型引用类型  基本类型数据保存在在栈内存中  引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中  浅拷贝  浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝  如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址  即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址  简单实现：  function shallowClone(obj) { const newObj = {}; for(let prop in obj) { if(obj.hasOwnProperty(prop)){ newObj[prop] = obj[prop]; } } return newObj; }   在JavaScript中，存在浅拷贝的现象有：  Object.assign  var obj = { age: 18, nature: ['smart', 'good'], names: { name1: 'fx', name2: 'xka' }, love: function () { console.log('fx is a great girl') } } var newObj = Object.assign({}, fxObj);   Array.prototype.slice(), Array.prototype.concat()  //slice方法 const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = fxArr.slice(0) fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] //concat方法 const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = fxArr.concat() fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]   使用拓展运算符实现的复制  const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = [...fxArr] fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]   ","version":"Next","tagName":"h2"},{"title":"什么是深拷贝？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#什么是深拷贝","content":" 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性.  常见的深拷贝方式有：  _.cloneDeep()。lodash工具的api  const _ = require('lodash'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f);// false   jQuery.extend()。jq的api  const $ = require('jquery'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = $.extend(true, {}, obj1); console.log(obj1.b.f === obj2.b.f); // false   JSON.stringify() 但是这种方式存在弊端，会忽略undefined、symbol和函数  const obj2=JSON.parse(JSON.stringify(obj1)); //函数、undefined、symbol不能深拷贝 const obj = { name: 'A', name1: undefined, name3: function() {}, name4: Symbol('A') } const obj2 = JSON.parse(JSON.stringify(obj)); console.log(obj2); // {name: &quot;A&quot;}   手写循环递归  function deepClone(obj, hash = new WeakMap()) { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; }   ","version":"Next","tagName":"h2"},{"title":"如何正确判断this的指向？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#如何正确判断this的指向","content":" 如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。  但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：  this 的指向可以按照以下顺序判断:  全局环境中的 this  浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window;  node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 ;  是否是 new 绑定  如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:  构造函数返回值是 function 或 object，new Super()是返回的是Super种返回的对象。  构造函数返回值不是 function 或 object。new Super() 返回的是 this 对象。  案例：  function Super(age){ this.age = age } let instance = new Super('26') console.log(instance.age) // 26   function Super(age){ this.age = age let obj = {a:'2'} return obj } let instance = new Super('26') console.log(instance) // {a:'2'} console.log(instance.age) // undefined   function Super(age){ this.age = age } let instance = new Super('26') console.log(instance) // {age:'26'} console.log(instance.age) // 26   函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。  function info(){ console.log(this.age) } var person= { age: 20, info } var age = 28 var info = person.info info.call(person) // 20 info.apply(person) // 20 info.bind(person)() // 20   这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)  function info () { // node 环境中：非严格模式 globao,严格模式 null // 浏览器环境中：非严格模式 window, 严格模式为 null console.log(this) console.log(this.age) } var person = { age: 20, info } var age = 28 var info = person.info // 严格模式抛出错误 // 非严格模式，node 下输出 undefined（因为全局的 age 不会挂在 global 上） // 非严格模式，浏览器环境下输出28（因为全局的 age 回挂在 window 上） info.call(null)   隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()  function info(){ console.log(this.age) } var person= { age: 20, info } var age = 28 person.info() // 20，执行的是隐式绑定 info(); // 28 注意这里直接调用和赋值引用调用结果不同   默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。  非严格模式： node环境，指向全局对象 global，浏览器环境，指向全局对象 window。  严格模式：执行 undefined  function info(){ console.log(this.age) } var age = 28 // 严格模式浏览器环境和node环境都抛错 // 非严格模式：node下输出 undefined（因为全局的 age 不会挂在 global 上） // 非严格模式：浏览器环境下输出 28（因为全局的 age 回挂在 window 上） info()   箭头函数的情况  箭头函数没有自己的this，继承外层上下文绑定的this。  let obj = { age: 20, info: function() { return () =&gt; { console.log(this.age) } } } let person = {age: 28} let info = obj.info() info() // 20 let info2 = obj.info.call(person) info2() // 28   ","version":"Next","tagName":"h2"},{"title":"CommonJS和ES6模块的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#commonjs和es6模块的区别","content":" CommonJS模块是运行时加载，ES6 Modules是编译时输出接口  CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变  CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串  CommonJS this指向当前模块，ES6 Modules this指向undefined  且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname  ","version":"Next","tagName":"h2"},{"title":"说一下es6新特性？平常工作中ES6+主要用到了哪些？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说一下es6新特性平常工作中es6主要用到了哪些","content":" ES6：  Class模块import和export箭头函数函数默认参数...扩展运输符允许展开数组解构字符串模版Promiselet constProxy、Map、Set对象属性同名能简写  ES7：  includes**求幂运算符  ES8：  async/awaitObject.values()和Object.entries()padStart()和padEnd()Object.getOwnPropertyDescriptors()函数参数允许尾部  ES9:  for...await...of...展开符合允许展开对象收集剩余参数Promise.finally()正则中的四个新功能  ES10：  flat()flatMap()fromEntries()trimStart和trimEndmatchAllBigInttry/catch 中报错允许没有err异常参数Symbol.prototype.descriptionFunction.toString() 调用时呈现原本源码的样子  ","version":"Next","tagName":"h2"},{"title":"如何判断一个变量是对象还是数组？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#如何判断一个变量是对象还是数组","content":" 判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好  function isObjArr(value){ if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) { console.log('value是数组'); }else if(Object.prototype.toString.call(value)==='[object Object]'){//这个方法兼容性好一点 console.log('value是对象'); }else{ console.log('value不是数组也不是对象') } }   通常判断是不是为数组，可以使用Array.isArray()判断.千万不能使用 typeof 来判断对象和数组，因为这两种类型都会返回 &quot;object&quot;。  ","version":"Next","tagName":"h2"},{"title":"通过reduce函数来实现简单的数组求和，示例数组[3,4,8,0,9];​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#通过reduce函数来实现简单的数组求和示例数组34809","content":" let result=[3,4,8,0,9].reduce((total,value)=&gt;{ //这两个参数是默认参数不用设置的 return total+value });   ","version":"Next","tagName":"h2"},{"title":"DOM事件中target和currentTarget的区别?​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#dom事件中target和currenttarget的区别","content":" target是事件触发的真实元素currentTarget是事件绑定的元素事件处理函数中的this指向是中为currentTargetcurrentTarget和target，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡） 当事件是子元素触发时，currentTarget为绑定事件的元素，target为子元素事件是元素自身触发时，currentTarget和target为同一个元素。  &lt;body&gt; &lt;ul id=&quot;box&quot;&gt; &lt;Li id=&quot;apple&quot;&gt;苹果&lt;/Li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;桃子&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var box = document.getElementById('box'); var apple = document.getElementById('apple'); //直接绑定在目标元素apple上 apple.onclick = function (e){ console.log(e.target); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.currentTarget); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(this); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.target === e.currentTarget); //true console.log(e.target === this); //true } //绑定在父元素box上（如果点击apple这个li时） box.onclick = function (e){ console.log(e.target); // &lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.currentTarget); //&lt;ul id=&quot;box&quot;&gt;...&lt;/ul&gt; console.log(this); //&lt;ul id=&quot;box&quot;&gt;...&lt;/ul&gt; console.log(e.currentTarget===this); //true console.log(e.target === e.currentTarget); //false console.log(e.target === this); //false } &lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"说一下let、const、var 的区别和let、const的暂时性死区​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说一下letconstvar-的区别和letconst的暂时性死区","content":" 区别：  let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。 相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。 const 声明变量时必须设置初始值 const 声明一个只读的常量，这个常量不可改变。  暂时性死区：let、const 所声明的变量，只在命令所在的代码块内有效。和var不同的还有，let命令不存在变量提升，所以声明前调用变量，都会报错。  ","version":"Next","tagName":"h2"},{"title":"weak-Set、weak-Map 和 Set、Map 区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#weak-setweak-map-和-setmap-区别","content":" 都是es6+新加的数据结构  Set。集合数据结构  类似数组，只有键值，没有键名。成员不可重复可以通过for of \\forEach遍历，方法有add、delete、has  const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4   Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。  Map键值对的集合  类似对象，存储键值对map数据结构键名可以是任意类型，普通object的键名只能是字符串forEach\\for of 可遍历。需要特别注意的是，Map 的遍历顺序就是插入顺序  weakSet  成员都是对象或者symbol，不能是其他类型的值成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。不能遍历，方法有add, delete,has  WeakMap  直接受对象作为健名（null除外），不接受其他类型的值作为健名健名所指向的对象，不计入垃圾回收机制不能遍历，方法同get,set,has,delete  ","version":"Next","tagName":"h2"},{"title":"聊一下作用域、作用域链、执行上下文​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#聊一下作用域作用域链执行上下文","content":" 作用域  作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)  作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)  作用域分为：  全局作用域函数作用域块级作用域  作用域链作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。  JS执行上下文栈(后面简称执行栈)  执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：  首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。  ","version":"Next","tagName":"h2"},{"title":"可迭代对象有哪些特点​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#可迭代对象有哪些特点","content":" ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，换个角度，也可以认为，一个数据结构只要具有 Symbol.iterator 属性(Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。  可迭代对象的特点：  具有 Symbol.iterator 属性，Symbol.iterator() 返回的是一个遍历器对象可以使用 for ... of 进行循环通过被 Array.from 转换为数组  原生具有 Iterator 接口的数据结构：  ArrayMapSetStringTypedArray函数的 arguments 对象NodeList 对象  ","version":"Next","tagName":"h2"},{"title":"for...in 和 for...of的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#forin-和-forof的区别","content":" for...in  用于遍历对象的可枚举属性（包括继承的属性），适用于普通对象、数组等。  示例：遍历对象属性名、数组索引。  //返回对象的键名（key），对数组来说是字符串类型的索引 const obj = { a: 1, b: 2 }; for (const key in obj) { console.log(key); // 输出 &quot;a&quot;, &quot;b&quot; } const arr = [10, 20]; for (const index in arr) { console.log(index); // 输出 &quot;0&quot;, &quot;1&quot;（字符串） }   for...in会遍历所有可枚举属性（包括非数字属性），而for...of只遍历元素值。  const arr = [3, 5, 7]; arr.foo = &quot;bar&quot;; for (const key in arr) { console.log(key); // 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot; } for (const value of arr) { console.log(value); // 输出 3, 5, 7 }   for in 会遍历原型链上的可枚举属性，需用hasOwnProperty过滤。  const parent = { inherited: true }; const child = Object.create(parent); child.own = true; for (const key in child) { console.log(key); // 输出 &quot;inherited&quot;, &quot;own&quot; if (child.hasOwnProperty(key)) { console.log(&quot;Own property:&quot;, key); // 输出 &quot;Own property: own&quot; } }   for...of  用于遍历可迭代对象（Iterable）的值，如数组、字符串、Map、Set等。  示例：遍历数组元素、字符串字符、Map的键值对。  //返回可迭代对象的值（value） const arr = [10, 20]; for (const value of arr) { console.log(value); // 输出 10, 20 } const str = &quot;hi&quot;; for (const char of str) { console.log(char); // 输出 &quot;h&quot;, &quot;i&quot; }   for...of无法直接遍历普通对象（默认不可迭代），但可以通过Object.keys()或实现Symbol.iterator解决  const obj = { a: 1, b: 2 }; // 错误：obj不可迭代 // for (const value of obj) { ... } // 正确：先获取键名再遍历 for (const key of Object.keys(obj)) { console.log(key); // 输出 &quot;a&quot;, &quot;b&quot; }   不涉及原型链，直接通过迭代器获取值，性能更优!!  总结：  特性\tfor...in\tfor...of适用对象\t对象（可枚举属性）\t可迭代对象（数组、Map、Set等） 遍历内容\t键名（字符串类型）\t值 原型链属性\t包含（需过滤）\t不涉及 普通对象遍历\t支持\t需自行实现迭代器 性能\t较慢（需检查原型链）\t较快  ","version":"Next","tagName":"h2"},{"title":"map 和 foreach的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#map-和-foreach的区别","content":" 二者都是遍历数组的方法，用于遍历数组并对每个元素执行特定的操作。区别如下：  返回值的区别  map会返回一个新数组，数组中的每个元素是回调函数的返回值。forEach没有返回值，返回的是undefined。通常不能return或中断，只能抛出报错来中断  const numbers = [1, 2, 3, 4]; // 使用map const doubled = numbers.map(num =&gt; num * 2); console.log(doubled); // [2, 4, 6, 8] // 使用forEach numbers.forEach(num =&gt; console.log(num * 2)); // 输出2, 4, 6, 8，但没有返回数组   用途  map适用于需要对数组中的每个元素进行转换并生成新数组的情况。forEach适用于仅需对数组中的每个元素执行操作而不需要新数组的情况。  const names = ['Alice', 'Bob', 'Charlie']; // 使用map进行转换 const uppercasedNames = names.map(name =&gt; name.toUpperCase()); console.log(uppercasedNames); // ['ALICE', 'BOB', 'CHARLIE'] // 使用forEach进行操作 names.forEach(name =&gt; console.log(name.toLowerCase())); // 输出alice, bob, charlie   链式调用 由于map返回一个新数组，可以与其他数组方法进行链式调用，而forEach不支持链式调用。  const numbers = [1, 2, 3, 4]; // 使用map进行链式调用 const result = numbers.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5); console.log(result); // [6, 8] // 使用forEach不能链式调用 numbers.forEach(num =&gt; num * 2).filter(num =&gt; num &gt; 5); // TypeError: Cannot read property 'filter' of undefined   在性能方面，map和forEach的表现通常相似，但由于map会创建一个新数组，因此在处理大量数据时，map可能会稍慢一些。  ","version":"Next","tagName":"h2"},{"title":"如何判断一个元素是否在可视区域中？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#如何判断一个元素是否在可视区域中","content":" 在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：  图片的懒加载列表的无限滚动计算广告元素的曝光情况可点击链接的预加载  判断一个元素是否在可视区域，我们常用的有三种办法：  offsetTop、scrollTop getBoundingClientRect Intersection Observer  offsetTop、scrollTop  offsetTop，元素的上外边框至包含元素的上内边框之间的像素距离  下面再来了解下clientWidth、clientHeight：  clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + paddingclientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding  这里可以看到client元素都不包括外边距  最后，关于scroll系列的属性如下：  scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小  scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置  垂直滚动 scrollTop &gt; 0水平滚动 scrollLeft &gt; 0将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置  注意：上述属性都是只读的，每次访问都要重新开始  具体实现判断：  el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight function isInViewPortOfOne (el) { // viewPortHeight 兼容所有浏览器写法 const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight const offsetTop = el.offsetTop const scrollTop = document.documentElement.scrollTop const top = offsetTop - scrollTop return top &lt;= viewPortHeight }   getBoundingClientRect返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性  const target = document.querySelector('.target'); const clientRect = target.getBoundingClientRect(); console.log(clientRect); // { // bottom: 556.21875, // height: 393.59375, // left: 333, // right: 1017, // top: 162.625, // width: 684 // }   当页面发生滚动的时候，top与left属性值都会随之改变  如果一个元素在视窗之内的话，那么它一定满足下面四个条件：  top 大于等于 0left 大于等于 0bottom 小于等于视窗高度right 小于等于视窗宽度  代码如下   function isInViewPort(element) { const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const { top, right, bottom, left, } = element.getBoundingClientRect(); return ( top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight ); }   Intersection Observer  Intersection Observer 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多  使用步骤主要分为两步：创建观察者和传入被观察者  首先创建观察者  const options = { // 表示重叠面积占被观察者的比例，从 0 - 1 取值， // 1 表示完全被包含 threshold: 1.0, root:document.querySelector('#scrollArea') // 必须是目标元素的父级元素 }; const callback = (entries, observer) =&gt; { ....} const observer = new IntersectionObserver(callback, options);   通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold 时会被执行`  关于callback回调函数常用属性如下：  // 上段代码中被省略的 callback const callback = function(entries, observer) { entries.forEach(entry =&gt; { entry.time; // 触发的时间 entry.rootBounds; // 根元素的位置矩形，这种情况下为视窗位置 entry.boundingClientRect; // 被观察者的位置举行 entry.intersectionRect; // 重叠区域的位置矩形 entry.intersectionRatio; // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算） entry.target; // 被观察者 }); };   传入被观察者:通过 observer.observe(target) 这一行代码即可简单的注册被观察者  const target = document.querySelector('.target'); observer.observe(target);   具体案例情况分析  实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色  html &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;   css .container { display: flex; flex-wrap: wrap; } .target { margin: 5px; width: 20px; height: 20px; background: red; }   往container插入1000个元素   const $container = $(&quot;.container&quot;); // 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt; function createTargets() { const htmlString = new Array(100000) .fill('&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;') .join(&quot;&quot;); $container.html(htmlString); }   这里，首先使用getBoundingClientRect方法进行判断元素是否在可视区域   function isInViewPort(element) { const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const { top, right, bottom, left } = element.getBoundingClientRect(); return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight; }   然后开始监听scroll事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为yellow  $(window).on(&quot;scroll&quot;, () =&gt; { console.log(&quot;scroll !&quot;); $targets.each((index, element) =&gt; { if (isInViewPort(element)) { $(element).css(&quot;background-color&quot;, &quot;yellow&quot;); } }); });   通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了scroll事件，scroll事件伴随了大量的计算，会造成资源方面的浪费  下面通过Intersection Observer的形式同样实现相同的功能  //创建观察者 const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });   getYellow回调函数实现对背景颜色改变，如下：  function getYellow(entries, observer) { entries.forEach(entry =&gt; { $(entry.target).css(&quot;background-color&quot;, &quot;yellow&quot;); }); } //最后传入观察者，即.target元素 $targets.each((index, element) =&gt; { observer.observe(element); }); 可以看到功能同样完成，并且页面不会出现卡顿的情况  ","version":"Next","tagName":"h2"},{"title":"typescript 学习笔记","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/typescript学习","content":"","keywords":"","version":"Next"},{"title":"简介​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#简介","content":" Typescript 由微软开发，是基于 Javascript 的一个扩展语言。TypeScript 包含了 avaScript 的所有内容，即:TypeScript 是 Javascript 的超集TypeScript 增加了:静态类型检査、接口、泛型等很多现代开发特性，因此更适合大型项目的开发。TypeScript 需要编译为 javaScript ，然后交给浏览器或其他 JavaScript 运行环境执行。  ","version":"Next","tagName":"h2"},{"title":"为何需要 ts？​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#为何需要-ts","content":" JavaScript 当年诞生时的定位是浏览器脚本语言，用于在网页中嵌入一些简单的逻辑，而且代码量很少。  随着时间的推移，JavaScript 变得越来越流行，如今的 JavaScript 已经可以全栈编程了。  现如今的 JavaScript 应用场景比当年丰富的多代码量也比当年大很多，随便一个 JavaScript 项目的代码量，可以轻松的达到几万行，甚至十几万行!  然而 JavaScript 当年“出生简陋”，没考虑到如今的应用场景和代码量，逐渐的就出现了很多困扰：  不清不楚的数据类型有漏洞的逻辑访问不存在的属性低级的拼写错误  所以为了以上问题，ts 推出了静态类型检查！  静态类型检查  在代码运行前进行检查，发现代码的错误或不合理之处，减小运行时异常的出现的几率，此种检查叫『静态类型检查』，TypeScript 和核心就是「静态类型检查』，简言之就是把运行时的错误前置同样的功能，TypeScript 的代码量要大于 JavaScript，但由于 TypeScript 的代码结构更加清晰，在后期代码的维护中 TypeScript 却远胜于 JavaScript。  ","version":"Next","tagName":"h2"},{"title":"编译 typescript​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#编译-typescript","content":" ts 在浏览器端是不能直接编译，浏览器不认 ts，node 也不认 ts 语法。  而是先将 ts 编译转成 js 再交给浏览器或 node 运行。  命令行编译 手动操作，每次都需要自己去编译转 js，然后运行 js  //1. 创建ts文件，编写代码 //demo.ts const person = { name:'xxx', age:18 } console.log(person.name,person.age); //2. 全局安装typescript npm i TypeScript -g //3. 使用命令行编译 tsc demo.ts   自动化编译（推荐）  通过 init 初始化来控制。常用。  //1. 初始化tsconfig编译控制文件 tsc --init //项目工程中会初始化一个 tsconfig.json配置文件，包含着编译的配置。默认编译版本为es7，可以手动调整为其他版本 //2. 监视目录中的.ts文件的变化 tsc --watch //3. 小优化：当编译出错时不生成新js文件 tsc --noEmitOnError --watch // 当然也可以在tsconfig.json中修改 noEmitOnError的配置   ","version":"Next","tagName":"h2"},{"title":"类型声明​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#类型声明","content":" 使用 : 来对变量或函数变量进行类型声明  let a: string; let b: number; let c: boolean; a = 9; // 报错 a = false; // 报错 //只能赋值为string类型的值 //函数中 function foo(x: number, y: number): number { return x + y; //return x+y+'hello' 报错 } let result = foo(1, 2); //x，y必须是number，foo返回值也必须是number，否则报错   ","version":"Next","tagName":"h2"},{"title":"类型推断​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#类型推断","content":" ts 有一个功能，可以根据代码来推断变量的类型  let a = -88; a = &quot;hello&quot;; //error   ","version":"Next","tagName":"h2"},{"title":"类型总览​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#类型总览","content":" JavaScript 中的类型 number\\string\\boolean\\null\\undefined\\symbol\\bigint\\objecttypescript 中的类型 以上 js 八种类型六个新类型 anyunknownevervoidtuple 元祖enum 枚举 两个自定义类型方式 typeinterface 接口  注意点  在 Javascript 中的这些内置构造函数:Number、String、Boolean 的包装对象，他们用于创建包装对象，在日常开发时很少使用，在 TypeScript 中也是同理，所以在 TypeScript 中进行类型声明时，通常都是用小写的 number、stringboolean  let a: String let a: string 这两个string大小写不同，表示的含义也不同 一般开头大写的类型，如Number\\String\\Boolean 会认为创建了包装对象；小写的number、string是普通的类型   原始类型 VS 包装对象 原始类型:如 numberboolean ，在 JavaScript 中是简单数据类型，它们在内存 string 中占用空间少，处理速度快。包装对象:如 Number 对象、String 对象、Boolean 对象，是复杂类型，在内存中占用更多空间，在日常开发时很少由开发人员自己创建包装对象。 自动装箱:JavaScript 在必要时会自动将原始类型包装成对象，以便调用方法或访问属性  ","version":"Next","tagName":"h2"},{"title":"常用类型​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#常用类型","content":" any any含义是：任意类型，一旦用 any 来限制变量，那就意味着放弃了对该变量的类型检查。任意类型都可以用。不建议使用  let a: any; a = 1; a = false; a = &quot;hello&quot;; // 都是可以的 // 还有隐式的声明方式： let a; //什么都不写就也是any   注意： any类型的变量，可以赋值给任意类型的变量，不会报错  let a: any = 1; let b: string; b = a; // 这是可以的 不报错   unknow unknow含义是：未知类型。当前确实不清楚变量的类型，不知道以后会怎么用。也是any的升级版。  区别是，any类型的可以赋值给任意类型限制的变量，但是unknow赋值给其他类型的变量会报错。  读取 any类型数据的任何属性都不会报错，而unknow相反   let str1: string = 'hello' str1.toUpperCase() let str2:any = 'world' str2.toUpperCase() //不报错 let str3:unknow = 'good' str3.toUpperCase() //报错 str的类型是未知 //如果要使unknow不报错，需要强制断言通过as，指定类型 (str3 as string).toUpperCase() //可以   never never 表示从来没有的类型。一般用来限制函数的返回。限制的函数不能顺利调用结束。没有返回值（undefined、null、0、false 都不行）或死循环。  通常用来现在一个抛出报错的函数  function demo(): never { throw new Error(&quot;函数报错了！&quot;); } let r = demo();   void void 表示空。 - 通常用于函数返回值的限制，含义：函数不能返回任何值，返回值为空，调用者也不依赖这个函数的返回值进行任何操作  function foo(): void { const a = 1; console.log(a); } foo(); //该函数没有返回值使用void不报错   编写者没有编写去 return，所以 foo 函数没有显式的返回值，但是有一个隐式的返回值，undefined，即：虽然函数为 void 类型，但是也可以接受 undefined 的，undefined 是 void 可以接受的一种“空”  //以上等价于 function foo(): void { const a = 1; console.log(a); return; // return undefined } foo();   object 实际开发中用的频率极小，object 和 Object 的区别：  object，变量能存储的类型是非原始类型  Object，能存储的类型是可以调用到 Object 方法的类型，除了 undefined 和 null 以外的任何值。  声明对象类型  限制一般对象，通常用以下方式  let person = { name : string, //间隔符号可以是 ， ； 或者回车 age?:number //? 表示可选属性,可以赋值也可以不赋值 } person={ name:'123' }   索引签名：允许定义的对象拥有任意数量的属性，这些属性的键的类型都是可变的，常用来描述类型不确定的属性，具有动态属性的对象  let person = { name: string, age?:number, [key:string]:any //key 用string限制，值用any限制 。 可以不用key这个单词，可以任意更换 } person={ name:'123', age:123, time:'2023', address:'北京' //可以任意赋值 }   声明函数类型  let count: (a: number, b: number) =&gt; number; count = function(x, y) { return x + y; }; //ts中函数声明时使用的=&gt;箭头表示函数类型，描述参数类型和返回类型 //js中=&gt;是一种定义函数的语法，而不是具体的函数实现 //函数类型声明还可以使用：接口、自定义类型等方式...   声明数组类型  let arr1: string[]; let arr2: Array&lt;number&gt;; //使用尖括号 泛型 arr1 = [&quot;a&quot;, &quot;b&quot;]; arr2 = [1, 2, 3];   tuple 元祖 是一种形式，tuple 不是关键字。元祖是一种特殊的数组类型，可存储固定数量的元素，并且每个元素的类型都是已知的且可以不同，元祖用于精确描述一组值的类型，？表示可选元素  let arr1:[string,number] //数组第一个必须是string，第二个必须是number let arr2:[number,boolean] //数组第一个必须是number，第二个必须是boolean let arr3:[number,...string[]] //数组第一个必须是number类型，后面的元素都是string arr1=['123',123] arr2 = [2,3] arr3= [1,'333','hello']   enum 枚举 可以定义一组命名常量，他能增强代码的可读性，也让代码更好的维护。  //数字枚举 enum Direction { Up, Down, Left, Right } console.log(Direction) //数字枚举是有反向映射的，会自动给每个枚举值做从0开始的索引 Direction[0] = Direction.Up //字符串枚举 enum DirectionStr { Up = 'up', Left = 'left', Down = 'down' } //字符串枚举没有反向映射 // 常量枚举： // 官方描述:常量枚举是一种特殊枚举类型，它使用 const 关键字定义，在编译时会被内联，避成一些额外的代码。   type type 可以为任意类型创建别名，让代码更简洁，可读性更强，同时更方便的去进行类型复用和扩展  // 类型别名使用type关键字，可定义新类型，比如 type Num = number; let a: Num; a = 1;   定义联合类型  比如  type Status = number | string; // 表示status新类型可以是number或者string 统一了一下 function foo(data: Status): void { console.log(data); } //还有一种用法 type Gender = &quot;男&quot; | &quot;女&quot;; function foo(data: Gender) {} foo(&quot;男&quot;); foo(&quot;nv&quot;); //报错   定义交叉类型  交叉类型(Intersection Types)允许将多个类型合并为一个类型。合并后的类型将拥有所有被合并类型的成员。交又类型通常用于对象类型。  type House = { width: number, height: number }; type Address = { room: string, addr: string }; type MyHouse = House &amp; Address; let str: Myhouse; str = { width: 123, height: 55, room: &quot;102&quot;, addr: &quot;北京&quot; };   特殊情况  在定义函数时候，限制函数返回值设置 void，那么函数的返回值必须是空  function demo(): void { console.log(1); return undefined; //或者返回undefined //以下都报错 // return false // return 0 // retrun null }   在使用类型声明来限制函数返回为 void 时候，ts 并不会严格要求返回值为空  type func = () =&gt; void; let demo: func = () =&gt; { return 100; // 不会报错，可以允许 };   原因  是为了确保如下代码成立，我们知道 Array.prototype.push 的返回一个数字，而 Array.prototype.forEach 方法期望其回调的返回类型是 void  const str = [1, 2, 3]; const dst = [0]; str.forEach(el =&gt; dst.push(el));   类  class demo { constructor(name:string,age:number){ this.name = name; this.age = age } speak(){ console.log(111) } } class childDemo extends demo { constructor (name:string,age:number,gender:string){ super(name,age) this.gender = gender } override speak(){ //override表示要复写重写父类的方法 console.log(2) } }   属性修饰符  修饰符\t含义\t规则public\t公开的\t可以被：类内部、子类、类外部访问到 private\t私有的\t只能被：类内部访问到 protected\t受保护的\t可以被：类内部、子类 访问到 readonly\t只读\t属性是无法修改  抽象类 概述:抽象类是一种无法被实例化的类，专门用来定义类的结构和行为，类中可以写抽象方法，也可以写具体实现。抽象类主要用来为其派生类提供一个基础结构，要求其派生类必须实现其中的抽象方法。  简记:抽象类不能实例化，其意义是可以被继承，抽象类里可以有普通方法、也可以有抽象方法。  总结:何时使用抽象类?  1.定义通用接口:为一组相关的类定义通用的行为(方法或属性)时。  2.提供基础实现:在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现。  3.确保关键实现 :强制派生类实现一些关键行为。  4.共享代码和逻辑:当多个类需要共享部分代码时，抽象类可以避免代码重复。  interface 接口  interface 是一种定义结构的方式，主要作用是为:类、对象、函数等规定一种契约。代码的一致性和类型安全，但要注 interface 只能定义格式，不能包含任何实现!   &lt;!-- 定义类结构 --&gt; interface PersonInterface { name:string, age:number, speak(x:number):void } class Person implements PersonInterface { constructor( public name:string, public age:number){ } speak(x:number):void{ console.log(1) } } &lt;!-- 定义对象结构 --&gt; interface PersonInterface { name:string, age?:number, readonly address:string, speak(x:number):void } const obj:PersonInterface = { name:&quot;张三&quot;, age:12, //age是可选属性，可以不赋值 address:'beijing', speak:function(){ console.log(1) } } obj.address = '南京' // error ： address 是只读属性 ，不能改 &lt;!-- 定义函数结构 --&gt; interface CounterInterface { (a:number,b:number):number } const count:CounterInterface= (a,b)=&gt;{ return a+b }   总结:何时使用接口?  a. 定义对象的格式: 描述数据模型、API 响应格式、配置对象..等等，是开发中用的最多的场景。  b. 类的契约:规定一个类需要实现哪些属性和方法。  c. 自动合井:一般用于扩展第三方库的类型，这种特性在大型项目中可能会用到。  一些相似概念的区别  interface和type的区别？ 相同点：都用来定义对象结构，两者在许多场景中可以互换不同点：interface更专注于定义对象和类的结构，支持继承、合并； type可以定义类型别名、联合类型、交叉类型，但不支持继承和自动合并。  ","version":"Next","tagName":"h2"},{"title":"泛型​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#泛型","content":" 泛型允许我们在定义函数、类或接口时，使用类型参数来表示未指定的类型这些参数在具体使用时才被指定具体的类型，泛型能让同一段代码适用于多种类型，同时仍然保持类型的安全性。  //使用&lt;T&gt;来表示泛型，对还没指定的类型做限制，在使用的时候再做限制 function logData&lt;T&gt;(data:T){ console.log(data) } logData&lt;number&gt;(1) interface Obj&lt;T&gt;{ name:string, age:number, info:T } let demo:Obj&lt;number&gt;= { name:&quot;123&quot;, age:123, info:32 }   ","version":"Next","tagName":"h2"},{"title":"类型声明文件​","type":1,"pageTitle":"typescript 学习笔记","url":"/docs/notes/JavaScript/typescript学习#类型声明文件","content":" 类型声明文件是 TypeScript 中的一种特殊文件，通常以 .d.ts 作为扩展名。它的主要作用是为现有的 JavaScript 代码提供类型信息，使得 TypeScript 能够在使用这些JavaScript 库或模块时进行类型检查和提示。  declare  declare function add(a: number, b: number): number;declare function mul(a: number,b: number): number; export { add, mul };  ","version":"Next","tagName":"h2"},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet... ...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. For example, use JSX to create an interactive button: &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null}],"options":{"languages":["en","zh"],"indexBaseUrl":true,"id":"default"}}