{"searchDocs":[{"title":"性能优化方案面试题","type":0,"sectionRef":"#","url":"/docs/interview/性能优化方案面试题","content":"性能优化方案面试题","keywords":"","version":"Next"},{"title":"JS代码打印输出题集合","type":0,"sectionRef":"#","url":"/docs/interview/JS代码打印输出题集合","content":"JS代码打印输出题集合","keywords":"","version":"Next"},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/interview/intro","content":"关于 最新的面试题整理","keywords":"","version":"Next"},{"title":"JS手写题集合","type":0,"sectionRef":"#","url":"/docs/interview/JS手写题集合","content":"JS手写题集合","keywords":"","version":"Next"},{"title":"浏览器垃圾回收机制","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/垃圾回收机制","content":"","keywords":"","version":"Next"},{"title":"内存泄露​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存泄露","content":" 内存泄漏是指，应当被回收的对象没有被正常回收，变成常驻老生代的对象，导致内存占用越来越高。内存泄漏会导致应用程序速度变慢、高延时、崩溃等问题。  ","version":"Next","tagName":"h2"},{"title":"内存生命周期​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存生命周期","content":" 分配：按需要去分配一块内存使用：读写已经分配的内存释放回收：释放掉不再使用的内存  ","version":"Next","tagName":"h3"},{"title":"内存泄露原因​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#内存泄露原因","content":" 创建了全局变量并且没有手动回收事件监听、定时器、闭包没有及时销毁使用js对象做缓存，且不设置过期策略和大小的限制  ","version":"Next","tagName":"h3"},{"title":"垃圾回收​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#垃圾回收","content":" ","version":"Next","tagName":"h2"},{"title":"关于引用计数法​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#关于引用计数法","content":" Reference Counting 是常见的垃圾回收算法，其核心思路是：将资源（比如对象）的被引用次数保存起来，当被引用次数为零时释放。该方法的局限性：当出现循环引用时，互相引用的对象不会被回收。  ","version":"Next","tagName":"h3"},{"title":"V8引擎的垃圾回收​","type":1,"pageTitle":"浏览器垃圾回收机制","url":"/docs/notes/浏览器相关/垃圾回收机制#v8引擎的垃圾回收","content":" V8 中有两个垃圾收集器。主要的 GC 使用 Mark-Compact 垃圾回收算法，从整个堆中收集垃圾。小型 GC 使用 Scavenger 垃圾回收算法，收集新生代垃圾。 ","version":"Next","tagName":"h3"},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Here are a few tips you might find useful. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"浏览器端存储","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器的存储","content":"","keywords":"","version":"Next"},{"title":"cookie​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#cookie","content":" 辨别用户身份而存在，主要用于维持用户的状态 加密的 浏览器发送请求时，会自动携带 cookie，将其发送到服务端 浏览器关闭后清除 有大小数量限制4kb 当单个域名下的 cookie 超出限制后，再设置 cookie，浏览器就会清除以前设置的 cookie cookie使用场景  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。个性化设置（如用户自定义设置、主题等）。浏览器行为跟踪（如跟踪分析用户行为等）。  ","version":"Next","tagName":"h2"},{"title":"webStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#webstorage","content":" 主要是分为本地存储和会话存储，主要区别就是存在时间区别。  ","version":"Next","tagName":"h2"},{"title":"localStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#localstorage","content":" 很重要，是不会自动跟随请求携带，需要自行获取添加持久化存储，永不过期，除非手动删除，不会随浏览器关闭就消失通常5m只能存在同域名下，跨域名不可以使用  ","version":"Next","tagName":"h3"},{"title":"sessionStorage​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#sessionstorage","content":" 不常用临时存储，浏览器关闭数据就会过期被清空不会跟随请求发送至服务器  ","version":"Next","tagName":"h3"},{"title":"indexDB​","type":1,"pageTitle":"浏览器端存储","url":"/docs/notes/浏览器相关/浏览器的存储#indexdb","content":" 浏览器端的数据库，跟一般数据库类似，存储大小基本以本地磁盘大小为准  可以使用dexie.js工具库来操作 查看dexie.js官方文档用于大量数据在客户端的存储 ","version":"Next","tagName":"h2"},{"title":"浏览器跨域","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器跨域","content":"","keywords":"","version":"Next"},{"title":"如何解决跨域问题？​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#如何解决跨域问题","content":" ","version":"Next","tagName":"h2"},{"title":"CORS​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#cors","content":" (Cross-Origin Resource Sharing) 最为常见的解决方案，在服务端进行配置，不用前端操作。CORS 将请求分为简单请求（Simple Requests）和需预检请求（Preflighted requests）方案依赖服务端/后端在响应头中添加 Access-Control-Allow-* 头，告知浏览器端通过此请求。  简单请求  不会触发预检请求的称为简单请求。当请求满足以下条件时就是一个简单请求： ● 请求方法：GET、HEAD、POST。 ● 请求头：Accept、Accept-Language、Content-Language、Content-Type。  ○ Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain。  需预检请求  当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个 OPTIONS 请求，通过服务端返回的 Access-Control-Allow-* 判定请求是否被允许。  CORS 引入了以下几个以 Access-Control-Allow-* 开头：  ● Access-Control-Allow-Origin 表示允许的来源  ● Access-Control-Allow-Methods 表示允许的请求方法  ● Access-Control-Allow-Headers 表示允许的请求头  ● Access-Control-Allow-Credentials 表示允许携带认证信息  当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。  ","version":"Next","tagName":"h3"},{"title":"反向代理​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#反向代理","content":" 服务端进行配置，nginx  ","version":"Next","tagName":"h3"},{"title":"JSONP​","type":1,"pageTitle":"浏览器跨域","url":"/docs/notes/浏览器相关/浏览器跨域#jsonp","content":" JSONP 的原理是利用了浏览器加载 JavaScript 资源文件时不受同源策略的限制而实现的 ","version":"Next","tagName":"h3"},{"title":"浏览器渲染原理","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/浏览器渲染原理","content":"","keywords":"","version":"Next"},{"title":"Parse解析阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#parse解析阶段","content":" 主要流程：  Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如 &lt;html&gt;, &lt;body&gt;）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。  解析html文档构建dom树（一个个的dom对象）加载次级的资源，比如img、外部的css文件、js文件、字体文件等。存在预解析器用来下载和加载css去扫描这些文件。 遇到js文件时可能会阻塞解析流程，要停止html解析去下载加载&lt;script&gt;标签的内容，可使用async和defer来优化  ","version":"Next","tagName":"h2"},{"title":"Style样式计算​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#style样式计算","content":" Recalculate Style 计算样式阶段  CSS 引擎处理样式的过程分为三个阶段：  收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。css引擎会遍历dom节点做匹配，将css样式解析出来加到对应的标签上。构建cssom树，与构建dom树并行构建，不会影响dom树的构建，但会阻塞js的执行，因为js可能会操作样式。在进入下一阶段之前，cssom树必须全部构建完毕。所以cssom会阻塞渲染过程。在大型网站中，会存在大量的 CSS 规则，如果为每个节点都保存一份样式值，会导致内存消耗过大。作为替代，CSS 引擎通常会创建共享的样式结构，计算样式对象一般有指针指向相同的共享结构  ","version":"Next","tagName":"h2"},{"title":"Layout构建排列​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#layout构建排列","content":" Layout排列阶段，创建Layout树（RenderObject渲染对象）  有了dom树和对应的样式计算之后，浏览器会将这些信息构建成一个layout树，构建所有可见的dom节点，以及每个节点的所有样式信息  layout树和dom树不一定是一一对应的，构建layout树主要是以下流程  从 DOM 树的根节点开始遍历每个可见节点。 ○ 某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。 ○ 某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。 ○ 为伪元素创建 LayoutObject。 ○ 为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。 dom树+cssom树 = renderTree  构建完之后，浏览器开始做布局计算，计算在浏览器中的位置和大小。计算盒模型的大小和位置；块元素、行类元素、浮动元素等；计算文字的大小位置、滚动区域等；  浏览器的布局计算工作包含以下内容：  根据 CSS 盒模型及视觉格式化模型，计算每个元素的各种生成盒的大小和位置。计算块级元素、行内元素、浮动元素、各种定位元素的大小和位置。计算文字，滚动区域的大小和位置。LayoutObject 有两种类型： ○ 传统的 LayoutObject 节点，会把布局运算的结果重新写回布局树中。 ○ LayoutNG（Chrome 76 开始启用） 节点的输出是不可变的，会保存在 NGLayoutResult 中，这是一个树状的结构，相比之前的 LayoutObject，少了很大回溯计算，提高了性能。  ","version":"Next","tagName":"h2"},{"title":"Paint绘制阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#paint绘制阶段","content":" Paint 阶段将 LayoutObject 树转换成供合成器使用的高效渲染格式 构建PaintLayer 绘制图层 （RenderLayer树）  构建完成的 LayoutObject 树还不能拿去显示，因为它不包含绘制的顺序（z-index）。同时，也为了考虑一些复杂的情况，如 3D 变换、页面滚动等，浏览器会对上一步的节点进行分层处理。这个处理过程被称为建立层叠上下文  浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。 构建 cc::Layer 与 display items  ","version":"Next","tagName":"h2"},{"title":"Composite合成阶段​","type":1,"pageTitle":"浏览器渲染原理","url":"/docs/notes/浏览器相关/浏览器渲染原理#composite合成阶段","content":" 光栅化、draw，绘制生成的图层。利用gpu进行渲染绘图。 raster（光栅化）是将 display item 中的绘制操作转换为位图的过程。 当所有的 tiles 都完成光栅化后，会生成 draw quads（绘制四边形）。每个 draw quads 是包含一个在屏幕特定位置绘制 tile 的命令，该命令同时考虑了所有应用到 layer tree 的变换。每个四边形引用了内存中 tile 的光栅化输出。四边形被包裹在合成帧对象（compositor frame object）中，然后提交（submit）到浏览器进程。  合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。  指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。  变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因  合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 ","version":"Next","tagName":"h2"},{"title":"http1.1和http2.0","type":0,"sectionRef":"#","url":"/docs/notes/浏览器相关/http1.1和http2.0","content":"","keywords":"","version":"Next"},{"title":"http1.1相比于http1.0改进​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http11相比于http10改进","content":" HTTP/1.1 相比于 HTTP/1.0 的改进和优化主要包含：持久连接、HTTP 管道化请求、分块编码传输、新增 host 头字段、缓存支持、更多状态码等。断点续传、并行下载  ","version":"Next","tagName":"h2"},{"title":"http1.1缺点​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http11缺点","content":" 队头阻塞虽然在 HTTP1.1 中增加了持久连接，能在一次 TCP 连接中发送和接收多个 HTTP 请求/响应，但是在一个管道中同一时刻只能处理一个请求，所以如果上一个请求未完成，后续的请求都会被阻塞。头部冗余HTTP 请求每次都会带上请求头，若此时 cookie 也携带大量数据时，就会使得请求头部变得臃肿。TCP 连接数限制浏览器对于同一个域名，只允许同时存在若干个 TCP 连接（根据浏览器内核有所差异），若超过浏览器最大连接数限制，后续请求就会被阻塞。  ","version":"Next","tagName":"h2"},{"title":"http2优化​","type":1,"pageTitle":"http1.1和http2.0","url":"/docs/notes/浏览器相关/http1.1和http2.0#http2优化","content":" header的压缩允许服务端主动推送多路复用二进制分帧层 ","version":"Next","tagName":"h2"},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. For example, use JSX to create an interactive button: &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"性能优化总结","type":0,"sectionRef":"#","url":"/docs/notes/性能优化/性能优化总结","content":"性能优化总结","keywords":"","version":"Next"},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet... ...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/notes/intro","content":"关于 Hi，我是易云，也可以叫我的英文名krysent。一位默默无闻，但热爱技术、热爱生活的95后前端开发。 在这里记录我的日常学习笔记以及项目中的一些思考总结 我的好友 杨 说过一句话很不错，想分享一下 ： “任何东西都是长期的过程，付出时间精力去学习了，才会有回报” 我想说，任何成功不是一蹴而就，都是靠每一份耕耘和不断的自我内驱。要像海绵一样不断的去汲取知识内容，成为自己的一部分。","keywords":"","version":"Next"},{"title":"前端设计模式","type":0,"sectionRef":"#","url":"/docs/notes/设计模式/A设计原则","content":"","keywords":"","version":"Next"},{"title":"设计原则​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#设计原则","content":" 单一职责原则：功能要单一，不能什么功能都往类里面写开放封闭原则：对外扩展开放，对修改进行封闭，可以进行功能扩展，但是不能修改或减少功能里是替换原则依赖倒置原则：非常重要。上层功能不应该依赖下层的实现接口分离原则  ","version":"Next","tagName":"h2"},{"title":"设计模式考量的因素​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#设计模式考量的因素","content":" 有利于代码的复用有利于代码的稳定可拓展有利于代码的可读性的提升  前人给出的一套编写代码的方法论  ","version":"Next","tagName":"h2"},{"title":"掌握程度​","type":1,"pageTitle":"前端设计模式","url":"/docs/notes/设计模式/A设计原则#掌握程度","content":" 上层建筑式的知识，比较抽象，不仅仅是知道概念！  什么是设计模式？ =&gt; 开发过程中有使用设计模式的概念清楚概念本身 =&gt; 去除空洞的概念。了解设计模式的基本分类、常见的设计模式类型适用场景不同的场景下关联到对应的设计模式 =&gt; 不能滥用设计模式，不要硬用设计模式过度设计。在模式和需求关系之间要做取舍 ","version":"Next","tagName":"h2"},{"title":"CSS基础点整理","type":0,"sectionRef":"#","url":"/docs/notes/HTML&CSS/css基础","content":"","keywords":"","version":"Next"},{"title":"盒子模型​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#盒子模型","content":" 所有html元素可以看成一个盒子，它包括：边框 margin，边框 border，填充 padding，和 实际内容 content  ","version":"Next","tagName":"h2"},{"title":"标准盒子模型（W3C模型）​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#标准盒子模型w3c模型","content":" box-sizing: content-box; 盒子的大小会因为设置的内外边距和边框而变化，即：外扩；  标准盒模型宽高 = 内容区域（content）宽高  ","version":"Next","tagName":"h3"},{"title":"怪异盒子模型（IE盒模型）​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#怪异盒子模型ie盒模型","content":" box-sizing: box-border;盒子的实际大小是设置的大小，不会因为内外边距和边框的大小而变化，即：内缩；  怪异盒模型宽高 = border + padding + 内容区宽高（content）  ","version":"Next","tagName":"h3"},{"title":"margin和padding​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#margin和padding","content":" 负值问题  margin可以有负值，left、top如果是负值向反方向移动，right和bottom负值不会有影响padding不能有负值  百分比问题如果设置值为百分比，则是按照父元素的宽度来定  margin纵向重叠问题margin纵向塌陷，分为兄弟盒子之间塌陷问题和父子盒子之间塌陷问题  兄弟盒子之间塌陷问题 元素垂直排列时，第一个元素的下外边距与第二个元素的上外边距会发生合并，合并后的间距就是两者中最大的那个值。 解决办法： 任何一个元素加上 display:inline-block;把外边距只加在其中一个元素上任意一个元素外边距换成对应的 padding 父子盒子之间的穿透问题 当一个元素包含在另一个元素中时,如果父元素没有设置内边距或边框把外边距分隔开，它们的上或下外边距也会发生合并 解决办法： 给父子元素中任一个加上position: absolute;给父元素加上overflow: hidden;给父子元素中任一个加上float: left;给父子元素中任一个加上 display: inline-block;给父元素添加 border 边框给父元素加上 display:table;将子元素的 margin 改成 pading  ","version":"Next","tagName":"h2"},{"title":"Flex布局​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#flex布局","content":" flex 布局又称为弹性布局。  ● 当我们给一个容器元素设置 display:flex; 时，这个容器就变成了 flex 容器，容器中所有直接子元素就成了容器成员（flex 项目）。  ● flex 容器默认存在两根轴：水平的主轴和垂直的交叉轴，flex 布局主要是围绕这两根轴来进行布局的。  ● 所以 flex 布局相对于 grid 网格布局来说，他更适合一维布局（单行或单列布局）  要详细弄懂 flex 布局，我们就要了解 Flex 容器的属性和 Flex 项目的属性。  flex布局知识点掘金笔记整理  ","version":"Next","tagName":"h2"},{"title":"BFC​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc","content":" BFC 全称为块级格式化上下文 (Block Formatting Context) ,可以说BFC就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。在页面上的一个隔离的独立容器，是一个独立的渲染区域。  ","version":"Next","tagName":"h2"},{"title":"BFC特点​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc特点","content":" 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流） 处于同一个BFC中的元素相互影响，可能会发生外边距重叠 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到BFC上  ","version":"Next","tagName":"h3"},{"title":"如何产生BFC？​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#如何产生bfc","content":" 有以下条件可以创建 BFC： ● 方法一：float 的值不是 none  ○ 该方法可以实现效果，但没有意义，不可能随便给盒子设置浮  ● 方法二：display 的值是 inline-block、flex 或 inline-flex  ○ 该方法可以实现效果，但没有意义，不可能随便改变盒子为行内块  ● 方法三：position 的值不是 static 或者 relative  ○ 该方法可以实现效果，但不靠谱  ● 方法四：overflow 的值不为 visible  ○ overflow：hidden； 该方法可以实现效果，是非常好用的让盒子形成 BFC 的方法，但不能满足所有的场景  ","version":"Next","tagName":"h3"},{"title":"BFC的作用？​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#bfc的作用","content":" 解决外边距margin重叠问题：通过给两个元素设置 overflow 属性，从而触发 BFC，解决外部边距重叠问题。盒子margin塌陷问题：当我们需要在一个父元素中需要写一些列表项进行包裹时，然而，使用 float 就会导致对应元素脱离文档流，父元素不能包裹住子元素。可以通过使用overflow来清除浮动。设置overflow:hidden，触发了bfc  ","version":"Next","tagName":"h3"},{"title":"清除浮动的方案​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#清除浮动的方案","content":" 给浮动元素的::after伪类设置clear:both（强烈推荐） 给浮动元素的父元素创建BFC，设置overflow:hidden 给浮动元素后的父元素设置clear:both（不推荐）  ","version":"Next","tagName":"h3"},{"title":"垂直居中的方案​","type":1,"pageTitle":"CSS基础点整理","url":"/docs/notes/HTML&CSS/css基础#垂直居中的方案","content":" 方法\t实现代码\t注意事项行内元素水平垂直居中\tline-height: 35px;``text-align: center;\t这个垂直居中只针对单行文本有效，需保证 line-height 值与容器高度一致 绝对定位 + margin\tposition: absolute;``top: 50%;``margin-top: -元素自身高度一半;``left: 50%;``margin-left: -元素自身宽度一半;\t需要明确指定子元素的宽高 绝对定位 + margin: auto\tposition: absolute;``margin: auto;\t必须指定子元素宽高；未指定宽高时子元素会占满父容器 绝对定位 + translate\tposition: absolute;``left: 50%;``top: 50%;``transform: translate(-50%, -50%);\t无需指定子元素宽高（推荐）translate 百分比基于元素自身宽高动态计算 flex 布局\t父元素添加：display: flex;``justify-content: center;``align-items: center;\t父容器内所有子元素均居中 flex + margin: auto\t父元素：display: flex;子元素：margin: auto;\t可指定单个子元素居中 table-cell\t父元素添加：display: table-cell;``text-align: center;``vertical-align: middle;\t避免同时使用 float 或 position: absolute``margin 在 table-cell 布局中无效 ","version":"Next","tagName":"h2"},{"title":"HTML以及H5新特性","type":0,"sectionRef":"#","url":"/docs/notes/HTML&CSS/Html以及Html5","content":"","keywords":"","version":"Next"},{"title":"HTML​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#html","content":" ","version":"Next","tagName":"h2"},{"title":"标签元素类型​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#标签元素类型","content":" 常见元素类型分为块级和行级  块级元素：  总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列宽度缺少时是它的容器的100%，除非设置一个宽度高度、行高以及外边距和内边距都是可以设置的块级元素可以容纳其它行级元素和块级元素  行内元素：  和其它元素都会在一行显示高、行高以及外边距和内边距可以设置宽度就是文字或者图片的宽度，不能改变行级元素只能容纳文本或者其它行内元素  注意点  行内元素设置宽度width无效行内元素设置height无效，但是可以通过line-height来设置设置margin只有左右有效，上下无效设置padding只有左右有效，上下无效  ","version":"Next","tagName":"h3"},{"title":"scrpit标签的async和defer属性​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#scrpit标签的async和defer属性","content":" 共同点：  异步加载：脚本的下载过程与HTML解析并行进行，不会阻塞页面渲染。仅适用于外部脚本：需要与src属性一起使用（内联脚本无效）。  特性\tasync\tdefer执行时机\t脚本下载完成后立即执行，可能中断HTML解析。\t脚本下载完成后，等待HTML解析完成再执行（在DOMContentLoaded事件之前）。 执行顺序\t不保证顺序（先下载完成的先执行）。\t严格按文档顺序执行。 适用场景\t完全独立、无依赖的脚本（如统计代码）。\t需要依赖DOM或其他脚本的场景。  info 普通脚本: [下载] → [执行] → [继续解析HTML] async脚本: [下载⏳] → [立即执行❗]（可能中断解析） defer脚本: [下载⏳] → [等待HTML解析完成] → [按顺序执行📑]  ","version":"Next","tagName":"h3"},{"title":"href和src区别​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#href和src区别","content":" src是source，外部资源的引用位置。项目内部文件的引用，如 js 脚本，img 图片和 iframe 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 href是网络资源的链接，在服务里的网络资源地址的下载，比如&lt;link&gt;标签里的href就是去下载css样式资源。并行下载资源并且不会停止对当前文档的处理。  ","version":"Next","tagName":"h3"},{"title":"HTML5新特性​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#html5新特性","content":" HTML5主要是关于图像、位置、存储、多任务等功能的增加：  语义化标签，如：article、footer、header、nav等视频video、音频audio画布canvas表单控件，calemdar、date、time、email地理本地离线存储，localStorage长期存储数据，浏览器关闭后数据不丢失，sessionStorage的数据在浏览器关闭后自动删除拖拽释放  ","version":"Next","tagName":"h2"},{"title":"H5语义化​","type":1,"pageTitle":"HTML以及H5新特性","url":"/docs/notes/HTML&CSS/Html以及Html5#h5语义化","content":" 作用：使用英文的语义化标签，方便开发人员的阅读和理解  比如之前是&lt;div&gt;``&lt;span&gt; , h5添加了语义化的&lt;form&gt;``&lt;nav&gt;``&lt;section&gt;``&lt;header&gt;``&lt;footer&gt;等明确其内容的标签 ","version":"Next","tagName":"h3"},{"title":"JavaScript高级知识点整理","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/JavaScrpit高级","content":"","keywords":"","version":"Next"},{"title":"js的异步及事件循环​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#js的异步及事件循环","content":" ","version":"Next","tagName":"h2"},{"title":"浏览器进程模型​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#浏览器进程模型","content":" 什么是进程？  程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程  每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方的同意。  什么是线程？  有了进程之后，可以运行程序代码了。运行代码的环境叫线程，所以一个进程至少要有一个线程，所以在进程开启之后会自动创建一个线程来运行代码，该线程叫主线程。  如果程序要同时执行多个代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。  浏览器的进程和线程  浏览器是一个多进程和多线程的应用程序。  浏览器内部工作及其复杂，为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。  ","version":"Next","tagName":"h3"},{"title":"渲染主线程是如何工作？​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#渲染主线程是如何工作","content":" 渲染线是最重要的一个线程，用来显示页面。渲染主线程是浏览器里最繁忙的线程，需要他处理的任务包括但不限于以下： ● 解析html  ● 解析css  ● 计算样式  ● 布局  ● 处理图层  ● 每秒把页面绘制60次  ● 执行全局的js代码  ● 执行事件处理函数  ● 执行计时器的回调函数  ● 。。。  一个线程要处理这么多的事情，问题来了，要如何调度任务呢？比如  我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗? 我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗? 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢?  为了解决以上的问题。浏览器想到解决方案，利用排队的规则。  ","version":"Next","tagName":"h3"},{"title":"任务队列​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#任务队列","content":" 在W3C里叫做 event loop，谷歌浏览器里叫做message queue 消息队列（循环）  在最开始时候，渲染主线程会进入一个无限循环；每一次循环会检查消息队列里是否有任务存在，如果有，就取出第一个任务执行，执行完一个后进入下一个循环，如果没有，则进入休眠状态；其他所有的线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。再添加新任务时候，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。  以上整个过程称为“消息循环”。也叫事件循环  事件循环概括：  事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列未尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。  ","version":"Next","tagName":"h3"},{"title":"js的异步​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#js的异步","content":" 代码在执行过程里，会遇到一些无法立即处理的任务，比如：  ● 计时完成后需要执行的任务 settimeout，setInterval  ● 网络通信完成后需要执行的任务 ajax fetch  ● 用户操作后需要执行的任务 addeventlistener  如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死：  使用异步的方式：渲染主线程永不阻塞。  ","version":"Next","tagName":"h3"},{"title":"如何理解JS的异步​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#如何理解js的异步","content":" JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现。  所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。  ","version":"Next","tagName":"h3"},{"title":"任务有优先级吗？​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#任务有优先级吗","content":" 任务没有优先级，都是在消息队列中按照先进先出。但消息队列是有优先级的。目前chrome的实现里，至少包含了以下队列：  ● 延时队列：用于存放计时器到达后的任务，优先级 【中】  ● 交互队列：用于存放用户操作后参数的事件处理任务，优先级【高】  ● 微队列：用户存放需要最快执行的任务，优先级【最高】  添加任务到微队列的方式主要是使用Promise，MutationObserver  ","version":"Next","tagName":"h3"},{"title":"垃圾回收机制​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#垃圾回收机制","content":" ","version":"Next","tagName":"h2"},{"title":"防抖、节流​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#防抖节流","content":" ","version":"Next","tagName":"h2"},{"title":"Promise​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#promise","content":" ","version":"Next","tagName":"h2"},{"title":"Ajax、Fetch和Axios​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#ajaxfetch和axios","content":" ","version":"Next","tagName":"h2"},{"title":"Ajax​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#ajax","content":" Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”  Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。  Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。其中 XMLHttpRequest 模块就是实现 Ajax 的一种很好的方式，这也是很多面试官喜欢让面试者手撕的代码之一。ajax != xmlhttprequest  我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。  ","version":"Next","tagName":"h3"},{"title":"Fetch​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#fetch","content":" fetch是在es6出现的，基于es6提出的promise来实现，是xmlhttprequest的替代品，不是ajax的替代品。是用来跟xmlhttprequest进行比较。fetch是一个api。  使用 promise，不使用回调函数。采用模块化设计，比如 rep、res 等对象分散开来，比较友好。通过数据流对象处理数据，可以提高网站性能。解决了xmlhttprequest出现的回掉地狱的情况  ","version":"Next","tagName":"h3"},{"title":"Axios​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#axios","content":" Axios 是一个基于 promise 封装的网络请求库，它是基于 XHR 进行二次封装。  从浏览器中创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求数据和响应数据取消请求自动转换 JSON 数据客户端支持防御 XSRF  ","version":"Next","tagName":"h3"},{"title":"三者对比​","type":1,"pageTitle":"JavaScript高级知识点整理","url":"/docs/notes/JavaScript/JavaScrpit高级#三者对比","content":" Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。其实三者都属于ajax技术  网络请求\t特点Ajax\t一种技术统称，主要利用XHR实现网络请求 Fetch\t具体API，基于promise，实现网络请求 Axios\t一个封装库，基于XHR封装，较为推荐使用 ","version":"Next","tagName":"h3"},{"title":"React源码","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React源码","content":"React源码","keywords":"","version":"Next"},{"title":"React发展","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React发展","content":"React发展","keywords":"","version":"Next"},{"title":"React面试题","type":0,"sectionRef":"#","url":"/docs/interview/React面试题","content":"","keywords":"","version":"Next"},{"title":"react hooks与class组件的区别在于什么？​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react-hooks与class组件的区别在于什么","content":" Hook 增加了函数式组件中 state 的使用，在之前函数式组件是无法拥有自己的状态，只能通过 props 以及 context 来渲染自己的 UI，而在业务逻辑中，有些场景必须要使用到 state，那么我们就只能将函数式组件定义为 class 组件。而现在通过 Hook，我们可以轻松的在函数式组件中维护我们的状态，不需要更改为 class 组件。  类组件的不足:  状态逻辑难以复用缺少复用机制渲染属性和高阶组件会导致层级冗余趋向复杂难以维护生命周期函数混杂不相干逻辑相干逻辑分散在不同生命周期函数中this 指向困扰内联函数过度创建新句柄类成员函数不能保证 this  函数式组件（hooks）的优势：  优化类组件的三大问题函数组件无 this 问题自定义 Hook 方便复用状态逻辑副作用的关注点分离  ","version":"Next","tagName":"h2"},{"title":"setState到底是异步还是同步?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#setstate到底是异步还是同步","content":" setState并不是单纯的异步或同步，这其实与调用时的环境相关  setState只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新  ","version":"Next","tagName":"h2"},{"title":"为什么不能条件使用 react hooks?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#为什么不能条件使用-react-hooks","content":" 确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。  ","version":"Next","tagName":"h2"},{"title":"React组件通信如何实现?​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#react组件通信如何实现","content":" 父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信 跨层级通信: Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,\b对于跨越多层的全局数据通过Context通信再适合不过 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入 event 模块进行通信 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态  ","version":"Next","tagName":"h2"},{"title":"你用过那些hooks？常用的hooks有哪些？​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#你用过那些hooks常用的hooks有哪些","content":" useState: useState 是最常用的 Hook 之一，它允许您在函数组件中使用状态。它返回一个状态值和一个更新状态的函数。您可以使用数组解构来获取这两个值。例如：const [count, setCount] = useState(0); useEffect: useEffect 允许您在组件渲染后执行副作用操作，比如订阅数据、处理 DOM 操作等。它接收一个回调函数和一个依赖数组，用于指定在哪些依赖项发生变化时触发副作用。例如：useEffect(() =&gt; { // 副作用操作 }, [dependency]); useContext: useContext 允许您在函数组件中访问 React 的上下文（context）。它接收一个上下文对象（通过 React.createContext 创建），并返回当前上下文的值。例如：const value = useContext(MyContext); useReducer: useReducer 是 useState 的替代方案，用于管理复杂的状态逻辑。它接收一个 reducer 函数和初始状态，并返回当前状态和一个 dispatch 函数用于触发状态更新。例如：const [state, dispatch] = useReducer(reducer, initialState); useRef: useRef 返回一个可变的 ref 对象，可以在多次渲染之间保持稳定。它通常用于获取 DOM 元素的引用或保存任意可变值。例如：const refContainer = useRef(initialValue); useCallback: useCallback 用于优化函数的性能，它返回一个记忆化的函数。当依赖项发生变化时，它会返回一个新的函数引用，否则会返回之前缓存的函数引用。例如：const memoizedCallback = useCallback(() =&gt; { // 函数体 }, [dependency]); useMemo: useMemo 用于优化计算的性能，它返回一个记忆化的值。当依赖项发生变化时，它会重新计算值，否则会返回之前缓存的值。例如：const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);  ","version":"Next","tagName":"h2"},{"title":"说说你对HOC(高阶组件)的了解​","type":1,"pageTitle":"React面试题","url":"/docs/interview/React面试题#说说你对hoc高阶组件的了解","content":" 高阶组件不是组件，是增强函数，可以输入一个元组件，返回出一个新的增强组件； 高阶组件的主要作用有:  代码重用，逻辑和引导抽象渲染劫持状态抽象和控制Props 控制  用法:  属性代理 (Props Proxy): 返回出一个组件，它基于被包裹组件进行 功能增强；  //默认参数: 可以为组件包裹一层默认参数； function proxyHoc(Comp) { return class extends React.Component { render() { const newProps = { name: 'tayde', age: 1, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } //提取状态: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件: function withOnChange(Comp) { return class extends React.Component { constructor(props) { super(props) this.state = { name: '', } } onChangeName = () =&gt; { this.setState({ name: 'dongdong', }) } render() { const newProps = { value: this.state.name, onChange: this.onChangeName, } return &lt;Comp {...this.props} {...newProps} /&gt; } } } // 使用姿势如下，这样就能非常快速的将一个 Input 组件转化成受控组件。 const NameInput = props =&gt; (&lt;input name=&quot;name&quot; {...props} /&gt;) export default withOnChange(NameInput)   包裹组件: 可以为被包裹元素进行一层包装  function withMask(Comp) { return class extends React.Component { render() { return ( &lt;div&gt; &lt;Comp {...this.props} /&gt; &lt;div style={{ width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, .6)', }} &lt;/div&gt; ) } } }   反向继承：返回出一个组件，继承于被包裹组件，常用于以下操作:  function IIHoc(Comp) { return class extends Comp { render() { return super.render(); } }; }   渲染劫持 (Render Highjacking)，例如条件渲染  function withLoading(Comp) { return class extends Comp { render() { if(this.props.isLoading) { return &lt;Loading /&gt; } else { return super.render() } } }; }   操作状态 (Operate State): 可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用  高阶组件的应用场景：  权限控制，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染  function withAdminAuth(WrappedComponent) { return class extends React.Component { constructor(props){ super(props) this.state = { isAdmin: false, } } async componentWillMount() { const currentRole = await getCurrentUserRole(); this.setState({ isAdmin: currentRole === 'Admin', }); } render() { if (this.state.isAdmin) { return &lt;Comp {...this.props} /&gt;; } else { return (&lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;/div&gt;); } } }; }   性能监控，包裹组件的生命周期，进行统一埋点:  function withTiming(Comp) { return class extends Comp { constructor(props) { super(props); this.start = Date.now(); this.end = 0; } componentDidMount() { super.componentDidMount &amp;&amp; super.componentDidMount(); this.end = Date.now(); console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`); } render() { return super.render(); } }; }   代码复用，可以将重复的逻辑进行抽象。 ","version":"Next","tagName":"h2"},{"title":"React Hooks","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React Hooks","content":"React Hooks","keywords":"","version":"Next"},{"title":"关于","type":0,"sectionRef":"#","url":"/docs/project_issue/intro","content":"关于 在这里整理记录项目中出现的疑难场景及解决方案","keywords":"","version":"Next"},{"title":"大文件上传","type":0,"sectionRef":"#","url":"/docs/project_issue/实战场景/大文件上传","content":"","keywords":"","version":"Next"},{"title":"前端如何将大文件进行分片处理？​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#前端如何将大文件进行分片处理","content":"   ","version":"Next","tagName":"h2"},{"title":"1、对File对象进行切片 slice ，得到一个个 Blob类型的文件​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#1对file对象进行切片-slice-得到一个个-blob类型的文件","content":"     使用Blob对象内置的slice方法进行切片    创建createFileChunks函数，将file流给进去，chunkSize为每一份的文件大小（单位是字节），输出切好的每一份文件result。File文件流或者Blob只是保存了文件的基本信息（如名字、大小、地址信息等），并不是文件本身，所以切片的时候不会很慢    File 对象:它表示一组文件，我们使用&lt;input type=&quot;file&quot;&gt;选择文件时，这些文件被存储在 File 对象中。  Blob对象:Blob对象表示二进制数据，常用来表示大型数据对象(如图片音频等)。File对象是Blob对象的一个子类，它继承了Blob对象的所有属性和方法。  formData对象:前端先将文件存储在formData对象中，才能传给后端。  ","version":"Next","tagName":"h3"},{"title":"2、将切好的一个个chunks逐一上传​","type":1,"pageTitle":"大文件上传","url":"/docs/project_issue/实战场景/大文件上传#2将切好的一个个chunks逐一上传","content":"   上传的时候，将分片进行逐一上传，如果上传过程中中断了（如网络中断、页面关闭等），之前上传过的分片就不用再上传了，则接着从上次传递完的那个分片开始继续上传，这个叫做切片的文件秒传    原理：    重新上传的时，询问服务器之前上传的阶段是在哪里？上传了哪些编号的分片，还需要上传哪些分片，具体已经上传完成的是哪些切片，还要从第几个开始继续上传？ 服务器需要告知这些信息。  此时需要用一个代表文件分片的Id，可以使用hash值来标识每一份切片。  使用hash来标记，hash是一种算法，可以把任何数据来换算成标记的字符串，（不可逆，只能将数据记录成一段字符串），利用hash值来代表文件切片的整个数据，进行id的记录。因此服务端可以使用切片的hash值来记录当前文件有没有上传过。  常见的hash算法有 md5 ，推荐库为【spark-md5】 ","version":"Next","tagName":"h3"},{"title":"低代码平台物料体系与编排引擎设计重难点","type":0,"sectionRef":"#","url":"/docs/project_issue/低代码平台项目/难点亮点问题","content":"","keywords":"","version":"Next"},{"title":"低代码平台的物料（组件）是怎么管理的，远程物料是如何加载？请详细说明核心流程和方案​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#低代码平台的物料组件是怎么管理的远程物料是如何加载请详细说明核心流程和方案","content":" 插件化设计  webpack、eslint、vue、babel、vite都有插件化身影  ","version":"Next","tagName":"h2"},{"title":"前置知识：插件化设计​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#前置知识插件化设计","content":"  { plugins:[ vue(), splitChunk(), react() ] }   插件化基座插件化协议插件生命周期插件开发 Plugin  ","version":"Next","tagName":"h3"},{"title":"具体模块化定义​","type":1,"pageTitle":"低代码平台物料体系与编排引擎设计重难点","url":"/docs/project_issue/低代码平台项目/难点亮点问题#具体模块化定义","content":" 物料取名：Button、Image、Text、Container  核心系统（BlockSuit类）来更改  ButtonPlugin=&gt; ButtonBlockImagePlugin=&gt; ImageBlockTextPlugin=&gt; TextBlock  物料最重要的两个东西是什么？  数据协议 ： json 数据 表示物料的内容物料渲染引擎 ： 组件视图  数据协议​  案例：  //定义一个按钮插件物料的协议 const ButtonBlock = { type:'button', id:'bt1', props:{ text:'xxxx', }, style:{ color:'#ccc', fontSize:16, backgroundColor:'#000' }, events:{} //定义事件协议 } //定义一个文本插件物料的协议 const TextBlock = { type:'text', id:'t1', props:{ text:'xxxx', }, style:{ color:'#red', fontSize:16, backgroundColor:'#000' }, events:{} //定义事件协议 }   渲染引擎​  组件，用来将json 数据渲染成页面  统一设计一个Renderer，通过策略模式负责数据转化加工、数据到组件的传递、组件渲染  &lt;div&gt; &lt;templete :is={...Block}&gt; ....物料渲染内容 &lt;/templete&gt; &lt;/div&gt;  ","version":"Next","tagName":"h3"},{"title":"ES6+","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/ES6+","content":"","keywords":"","version":"Next"},{"title":"ES6+新特性内容整理​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#es6新特性内容整理","content":" ","version":"Next","tagName":"h2"},{"title":"let和const​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#let和const","content":" ","version":"Next","tagName":"h2"},{"title":"关于let​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#关于let","content":" let 是 ES6 引入的一种变量声明方式，主要用于解决 var 声明变量时的一些问题。let 的本质特性包括：  块级作用域  let 声明的变量只在其所在的代码块内有效，这与 var 不同。var 声明的变量是函数作用域或全局作用域。  { let x = 10; var y = 20; } console.log(x); // 报错：ReferenceError: x is not defined console.log(y); // 输出: 20   不允许重复声明  在同一作用域内，使用 let 声明同一个变量会导致错误，而 var 允许重复声明。  let a = 1; // let a = 2; // 报错：Identifier 'a' has already been declared var b = 1; var b = 2; // 合法，b 的值会被更新为 2   提升（Hoisting）  let 声明的变量会被提升到所在作用域的顶部，但在声明之前是不可用的。这种现象称为“暂时性死区”（Temporal Dead Zone, TDZ）。  console.log(c); // 报错：ReferenceError: Cannot access 'c' before initialization let c = 3;   用于循环中的作用域 在循环中使用 let 声明的变量，每次迭代都会创建一个新的作用域，这在处理异步操作时非常有用。  for (let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; { console.log(i); // 输出: 0, 1, 2 }, 1000); } //使用 var 声明的变量会导致所有的回调函数共享同一个 i，输出结果为 3 三次。 for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; { console.log(i); // 输出: 3, 3, 3 }, 1000); }   ","version":"Next","tagName":"h3"},{"title":"关于const​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#关于const","content":" const 的本质是 ES6 引入的一个关键字，用于声明常量。它的本质特性主要体现在以下几个方面：  固定的引用 const 声明的变量指向的内存地址是固定的，这意味着你不能重新赋值给该变量。换句话说，const 确保变量的引用不变，但并不意味着引用的数据本身不可变。  const a = 10; // a = 20; // 报错：Assignment to constant variable.   复合类型的可变性 对于复合类型（如对象和数组），const 变量指向的是一个内存地址，而这个地址保存的是一个指向实际数据的引用。因此，虽然 const 保证了这个引用（指针）不会改变，但它指向的数据结构本身是可以修改的。  const obj = { name: 'Alice' }; obj.name = 'Bob'; // 这是合法的，obj 的内容被修改 console.log(obj); // 输出: { name: 'Bob' } // obj = { name: 'Charlie' }; // 报错：Assignment to constant variable.   块级作用域（同let） 不允许重复声明（在同一作用域） 提升（同let）  let 和 const 的引入使得 JavaScript 的变量管理更加严谨，避免了 var 的一些常见问题，提升了代码的可读性和可维护性。建议在编写现代 JavaScript 时优先使用 let 和 const，以确保更好的代码质量。  ","version":"Next","tagName":"h3"},{"title":"解构​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#解构","content":" ","version":"Next","tagName":"h2"},{"title":"新增的数组方法​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#新增的数组方法","content":" ","version":"Next","tagName":"h2"},{"title":"Class关键字​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#class关键字","content":" ","version":"Next","tagName":"h2"},{"title":"Promise相关​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#promise相关","content":" 可见阮一峰es6教程  promise.all  const p = Promise.all([p1, p2, p3]);   Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。  Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。  p的状态是由p1,p2,p3 决定的，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。  （3）接受一个 Promise 数组，当所有 Promise 成功时返回结果数组；若任意一个失败，立即以该失败原因拒绝。  （4）即使某个 Promise 失败，其他 Promise 仍会继续执行，但结果会被忽略。  es6+引入的解决异步问题的方案，Promise是一个构造函数，可以通过new来创建一个实例的promise对象。  Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的 then 方法和 catch、finally 方法会返回一个新的 Promise 所以可以允许我们链式调用，解决了传统的回调地狱问题。  Promise的状态一经改变就不能再改变  关于 then 以及 catch 方法：  Promise的状态一经改变就不能再改变。.then和.catch都会返回一个新的Promise。catch不管被连接到哪里，都能捕获上层未捕捉过的错误。在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  finally方法：  .finally()方法不管Promise对象最后的状态如何都会执行.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  最后可以说一下all以及race方法：  Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。  缺点是： Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  ","version":"Next","tagName":"h2"},{"title":"迭代器 generater​","type":1,"pageTitle":"ES6+","url":"/docs/notes/JavaScript/ES6+#迭代器-generater","content":"","version":"Next","tagName":"h2"},{"title":"react和vue的区别","type":0,"sectionRef":"#","url":"/docs/notes/React相关/React和Vue区别","content":"","keywords":"","version":"Next"},{"title":"设计差异​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#设计差异","content":" 维度\treact\tvue核心定位\t专注 UI 层的声明式渲染库\t渐进式框架（提供完整解决方案） 设计目标\t强调灵活性和组合性（Learn Once, Write Anywhere）\t强调开发体验和易用性（渐进增强） 技术栈扩展\t需要自主选择路由、状态管理方案（如 Redux、MobX）\t官方提供路由（Vue Router）、状态管理（Pinia/Vuex）  ","version":"Next","tagName":"h2"},{"title":"语法对比​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#语法对比","content":" react使用jsx  // 组件逻辑与模板混合编写 function Button({ onClick }) { return ( &lt;button className=&quot;primary-btn&quot; onClick={onClick}&gt; Click Me &lt;/button&gt; ); }   特点：  用 JavaScript 表达 UI（All in JS） 支持完整的 JavaScript 表达式 需要手动绑定事件（如 onClick={handleClick}）  vue使用单文件组件  &lt;template&gt; &lt;button class=&quot;primary-btn&quot; @click=&quot;handleClick&quot;&gt; {{ buttonText }} &lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; const buttonText = 'Click Me'; const handleClick = () =&gt; { /* ... */ }; &lt;/script&gt; &lt;style scoped&gt; .primary-btn { /* 样式 */ } &lt;/style&gt;   特点：  模板、逻辑、样式分离但集中管理 指令系统简化 DOM 操作（如 v-if, v-for） 自动事件绑定（@click 语法糖）  ","version":"Next","tagName":"h2"},{"title":"数据响应​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#数据响应","content":" React 为单项数据流。基于不可变数据，通过setState、useState来触发重新渲染，需要开发者显示调用apiVue 是双向数据绑定。基于Proxy（Vue2是Object.defineProperty）的数据劫持更新。数据自动触发更新不需要手动去更改。  代码对比：  // React：需要手动触发更新 const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); // Vue：数据修改自动响应 const count = ref(0); const increment = () =&gt; count.value++;   ","version":"Next","tagName":"h2"},{"title":"组件的实现​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#组件的实现","content":" React是函数式组件+hooks（v16.9+），之前是使用class类组件的形式。万物皆组件。  特点：  逻辑复用依赖 Hooks（useState/useEffect） 强调纯函数和副作用分离  function UserList() { const [users, setUsers] = useState([]); useEffect(() =&gt; { fetchUsers().then(data =&gt; setUsers(data)); }, []); return ( &lt;ul&gt; {users.map(user =&gt; &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)} &lt;/ul&gt; ); }   Vue是组合式Api  &lt;script setup&gt; import { ref, onMounted } from 'vue'; const users = ref([]); const fetchData = async () =&gt; { users.value = await fetchUsers(); }; onMounted(fetchData); &lt;/script&gt; &lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt;{{ user.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;   特点：  逻辑组合更灵活（类似 React Hooks） 自动追踪依赖，无需手动声明依赖数组  ","version":"Next","tagName":"h2"},{"title":"性能优化策略​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#性能优化策略","content":" React优化手段：memo函数的记忆组件，结合useMemo、useCallback缓存内容。场景：避免不必要的子组件被渲染Vue优化手段：&lt;KeepAlive/&gt;组件自动缓存，computed组件重新计算。依赖追踪粒度到属性级别  ","version":"Next","tagName":"h2"},{"title":"生态链​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#生态链","content":" React: ReactRouter、Redux、ReactNative、Vue:Cli、Vite、Uniapp  ","version":"Next","tagName":"h2"},{"title":"开发场景​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#开发场景","content":" 选择 React： ✅ 大型复杂应用 ✅ 需要高度定制化架构 ✅ 团队有较强 JavaScript 基础  选择 Vue： ✅ 快速开发中小型项目 ✅ 开发者偏好简洁的模板语法 ✅ 需要开箱即用的完整解决方案  ","version":"Next","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"react和vue的区别","url":"/docs/notes/React相关/React和Vue区别#总结","content":" 两者本质都是优秀的 UI 解决方案，React 更注重灵活性和工程化，Vue 更注重开发体验和渐进性。建议根据团队技术栈、项目规模和长期维护需求做选择。 ","version":"Next","tagName":"h2"},{"title":"常见模式","type":0,"sectionRef":"#","url":"/docs/notes/设计模式/常见设计模式","content":"","keywords":"","version":"Next"},{"title":"1.工厂模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#1工厂模式","content":" 工厂模式（Factory Pattern）：将对象的创建和使用分离，由工厂类负责创建对象并返回。在前端开发中，可以使用工厂模式来动态创建组件。  前端中的工厂模式是一种创建对象的设计模式，它可以让我们封装创建对象的细节，我们使用工厂方法而不是直接调用 new 关键字来创建对象，使得代码更加清晰、简洁和易于维护。在前端开发中，工厂模式通常用于创建多个相似但稍有不同的对象，比如创建一系列具有相同样式和行为的按钮或者表单。  在实现工厂模式时，通常需要创建一个工厂函数（或者叫做工厂类），该函数可以接受一些参数，并根据这些参数来创建对象。例如，我们可以创建一个ButtonFactory函数，它接受一个type参数，用于指定按钮的类型，然后根据type参数创建不同类型的按钮对象。示例代码如下：   function ButtonFactory(type) { switch (type) { case 'primary': return new PrimaryButton(); case 'secondary': return new SecondaryButton(); case 'link': return new LinkButton(); default: throw new Error('Unknown button type: ' + type); } } function PrimaryButton() { this.type = 'primary'; this.text = 'Click me!'; this.onClick = function() { console.log('Primary button clicked!'); }; } function SecondaryButton() { this.type = 'secondary'; this.text = 'Click me too!'; this.onClick = function() { console.log('Secondary button clicked!'); }; } function LinkButton() { this.type = 'link'; this.text = 'Click me as well!'; this.onClick = function() { console.log('Link button clicked!'); }; }   在上面的示例中，ButtonFactory函数接受一个type参数，根据这个参数来创建不同类型的按钮对象。例如，如果type为'primary'，则返回一个PrimaryButton对象，该对象具有type、text和onClick属性，表示一个主要按钮。其他类型的按钮也类似。  使用工厂模式可以让我们将对象创建的过程与具体的业务逻辑分离开来，从而提高代码的可重用性和可维护性。  // 或者可以使用ts 类的方式来创建组件 class Button { type:'primary'| 'secondary'|'link' } class PrimaryButton extends Button{ type:'primary' activeStyle:string } class SecondaryButton extends Button{ type:'secondary' hoverStyle:string } class LinkButton extends Button{ type:'link' href:string }   ","version":"Next","tagName":"h2"},{"title":"2.单例模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#2单例模式","content":" 前端中用的较多（状态管理）  单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问它的全局访问点。在前端开发中，可以使用单例模式来管理全局状态和资源。  在JavaScript中，单例模式可以通过多种方式实现，以下是一些常见的实现方式：  使用对象字面量可以轻松地创建单例对象，例如：  const singleton = { property1: &quot;value1&quot;, property2: &quot;value2&quot;, method1: function () { }, method2: function () { }, };   在JavaScript中，每个构造函数都可以用于创建单例对象，例如：  function Singleton() { if (typeof Singleton.instance === &quot;object&quot;) { return Singleton.instance; } this.property1 = &quot;value1&quot;; this.property2 = &quot;value2&quot;; Singleton.instance = this; } const instance1 = new Singleton(); const instance2 = new Singleton(); console.log(instance1 === instance2);   上述代码中，使用了一个构造函数来创建单例对象。在构造函数中，首先判断是否存在单例实例，如果存在则直接返回该实例，否则创建单例对象并将其保存在 Singleton.instance 属性中。由于JavaScript中每个构造函数本身就是一个单例，因此不需要额外的代码来保证单例。  使用模块模式可以创建一个只有单个实例的对象，例如：  const Singleton = (function () { let instance; function init() { const object = new Object(&quot;I am the instance&quot;); return object; } return { getInstance: function () { if (!instance) { instance = init(); } return instance; }, }; })(); const instance1 = Singleton.getInstance(); const instance2 = Singleton.getInstance(); console.log(instance1 === instance2);   上述代码中，使用了一个立即执行函数来创建单例对象。在该函数中，定义了一个私有变量 instance 用于存储单例实例，而 init 函数则是用于创建单例实例的方法。最后，返回一个对象，该对象包含一个 getInstance 方法，该方法用于获取单例实例。  通过上述方式实现的单例模式，可以确保在程序运行期间，某个类只有一个实例，并且该实例可以在任何地方访问。  ","version":"Next","tagName":"h2"},{"title":"3.发布订阅模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#3发布订阅模式","content":" 前端中用的较多（event, dom event）发布-订阅模式（Publish-Subscribe Pattern）：也叫消息队列模式，它是一种将发布者和订阅者解耦的设计模式。在前端开发中，可以使用发布-订阅模式来实现组件之间的通信。  JavaScript中的发布/订阅模式（Pub/Sub）是一种常用的设计模式。它允许在应用程序中定义对象之间的一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会被通知和更新。  在发布/订阅模式中，有两种类型的对象：发布者和订阅者。发布者是事件的发出者，它通常维护一个事件列表，并且可以向列表中添加或删除事件。当某个事件发生时，它会将这个事件通知给所有订阅者。订阅者则是事件的接收者，它们订阅感兴趣的事件，并且在事件发生时接收通知。。  发布订阅模式可以帮助我们实现松耦合的设计，让对象之间的依赖关系变得更加灵活。它在前端开发中的应用非常广泛，例如 Vue.js 中的事件总线、Redux 中的 store 等。  以下是一个简单的实现发布/订阅模式的示例代码：   var publisher = { events: {}, addEvent: function(event, callback) { if (!this.events[event]) { this.events[event] = []; } this.events[event].push(callback); }, removeEvent: function(event, callback) { if (this.events[event]) { for (var i = 0; i &lt; this.events[event].length; i++) { if (this.events[event][i] === callback) { this.events[event].splice(i, 1); break; } } } }, publishEvent: function(event, data) { if (this.events[event]) { for (var i = 0; i &lt; this.events[event].length; i++) { this.events[event][i](data); } } } }; var subscriber = { handleEvent: function(data) { console.log(data); } }; publisher.addEvent('event1', subscriber.handleEvent); publisher.publishEvent('event1', 'Hello, world!'); publisher.removeEvent('event1', subscriber.handleEvent);   在这个例子中，发布者对象维护了一个事件列表（events），并且提供了添加、删除和发布事件的方法。订阅者对象则提供了一个处理事件的回调函数（handleEvent），它可以被添加到发布者对象的事件列表中。当发布者发布一个事件时，所有订阅了这个事件的订阅者都会收到通知，并执行相应的处理函数。  ","version":"Next","tagName":"h2"},{"title":"4. 观察者模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#4-观察者模式","content":" 前端中用的较多（Rx.js）观察者模式（Observer Pattern）：当对象间存在一对多的关系时，使用观察者模式。当被观察的对象发生变化时，其所有的观察者都会收到通知并进行相应的操作。在JavaScript中，可以使用回调函数或事件监听来实现观察者模式。  在前端开发中，观察者模式常被用来实现组件间的数据传递和事件处理。比如，当一个组件的状态发生改变时，可以通过观察者模式来通知其他组件更新自身的状态或视图。  在观察者模式中，通常会定义两种角色：  以下是一个简单的实现示例：  class Subject { constructor() { this.observers = [] } addObserver(observer) { this.observers.push(observer) } removeObserver(observer) { this.observers = this.observers.filter(obs =&gt; obs !== observer) } notify(data) { this.observers.forEach(obs =&gt; obs.update(data)) } } class Observer { update(data) { console.log(`Received data: ${data}`) } } const subject = new Subject() const observer1 = new Observer() const observer2 = new Observer() subject.addObserver(observer1) subject.addObserver(observer2) subject.notify('Hello, world!') subject.removeObserver(observer1) subject.notify('Goodbye, world!')   在上面的示例中，我们定义了一个 Subject 类和一个 Observer 类。Subject 类有三个方法，addObserver 用于添加观察者，removeObserver 用于移除观察者，notify 用于通知所有观察者。  Observer 类只有一个方法 update，用于接收主题传递的数据。我们创建了两个 Observer 实例并将它们添加到了 Subject 实例中，然后调用了 notify 方法来通知它们更新数据。  在实际开发中，我们通常会使用现成的库或框架来实现观察者模式，比如 React 中的状态管理库 Redux 和事件处理库 EventEmitter。  ","version":"Next","tagName":"h2"},{"title":"5. 装饰器模式​","type":1,"pageTitle":"常见模式","url":"/docs/notes/设计模式/常见设计模式#5-装饰器模式","content":" 前端中用的较多（Nest.js, Angular） 装饰者模式（Decorator Pattern）：动态地给一个对象添加额外的职责。在前端开发中，可以使用装饰者模式来动态修改组件的行为和样式。  JavaScript 中的装饰者模式可以通过以下几种方式实现：  const obj = { foo() { console.log('foo'); } } function barDecorator(obj) { obj.bar = function() { console.log('bar'); } return obj; } const decoratedObj = barDecorator(obj); decoratedObj.foo(); decoratedObj.bar();   在上面的示例中，我们首先定义了一个原始对象 obj，它包含一个方法 foo。然后，我们定义了一个装饰函数 barDecorator，它接收一个对象作为参数，用于为这个对象添加一个新的方法 bar。最后，我们使用 barDecorator 函数来扩展原始对象 obj，并得到了一个新的对象 decoratedObj，它包含了原始对象的方法 foo 和新的方法 bar。  function Foo() {} Foo.prototype.foo = function() { console.log('foo'); } function barDecorator(clazz) { clazz.prototype.bar = function() { console.log('bar'); } } barDecorator(Foo); const obj = new Foo(); obj.foo(); obj.bar();   在上面的示例中，我们首先定义了一个原始对象 Foo，它是一个构造函数，用于创建一个对象。然后，我们在原型上定义了一个方法 foo。接着，我们定义了一个装饰函数 barDecorator，它接收一个构造函数作为参数，用于在原型上添加一个新的方法 bar。最后，我们使用 barDecorator 函数来扩展原始对象的原型，然后创建一个新的对象 obj，并使用扩展后的方法 foo 和 bar。  需要注意的是，装饰者模式可以嵌套使用，也就是说，我们可以通过多个装饰函数来依次为一个组件添加多个不同的功能。同时，装饰者模式也可以用于对已有的组件进行扩展，使得我们可以在不改变原有代码的情况下，给组件添加新的行为和样式。 ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/notes/前端工程化/Webpack学习笔记","content":"","keywords":"","version":"Next"},{"title":"核心工作过程​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#核心工作过程","content":" 在项目中会散落很多文件.js.html.css.less.png.json.jpg 等，webpack cli 启动打包流程，载入核心模块，创建compiler对象，开始进行编译。通过打包入库 index.js 开始解析，每个资源模块需要的依赖模块，形成项目中所有文件间的一个依赖个关系树。有了关系树之后开始递归遍历这个依赖树，然后找到每个模块需要的加载器去加载，加载到结果放到 bundle.js 里面，实现整个项目的打包。其中 loader 机制起到很重要的作用，有了 loader 起到所有资源的加载。    ","version":"Next","tagName":"h2"},{"title":"Loader​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#loader","content":" ","version":"Next","tagName":"h2"},{"title":"Loader 工作原理​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#loader-工作原理","content":" js 代码，将输入的信息转化成新的 js 代码，类似于一个管道。      ","version":"Next","tagName":"h3"},{"title":"手写一个 Loader​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#手写一个-loader","content":" //markdown-loader.js module.exports = source =&gt; { //loader返回结果一定要是js代码，loader是直接将转换的结果塞入bundle.js包中 const html = marked(source); return `module.exports = ${JSON.stringify(html)}`; };   //.... module: { rules: [ { test: /.md$/, use: [&quot;html-loader&quot;, &quot;./markdown-load&quot;] //可以直接使用相对路径来引用编写好的loader } ]; }   use 数组有多个 loader 时候，loader 执行顺序是从后往前，从右往左依次执行。放在后面的 loader 优先级高先执行。  ","version":"Next","tagName":"h3"},{"title":"Plugin​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#plugin","content":" 插件机制，增强 webpack 的自动化能力，loader 实现资源模块的加载和打包，plugin 解决除了资源加载以外的其他自动化工作。例如 清除 dist 目录、拷贝静态文件到静态目录、压缩代码，实现了大多数前端工程化工作。  ","version":"Next","tagName":"h2"},{"title":"使用方法​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#使用方法","content":" const {CleanWebpackPlugin} from 'clean-webpack-plugin' const HtmlWepackPlugin from 'html-webpack-plugin' const CopyWebpackPlugin from 'copy-webpack-plugin' //... plugins:[{ new CleanWebpackPlugin() , //使用 new HtmlWepackPlugin({ title:&quot;页面名称1&quot;， meta:{ viewport:&quot;width=device-width&quot; }, template: resolvePath('../public/index.html'), }), new CopyWebpackPlugin(['public']) //拷贝public下的所有内容 }]   ","version":"Next","tagName":"h3"},{"title":"常用插件​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#常用插件","content":" 仔细过插件的官方说明和文档，了解 api 参数用法，不需要所有的都认识，用的时候再  clean-webpack-plugin : 自动清理 dist 目录插件，可以清空覆盖上一次 dist 内容，方便已经清除的内容积累html-webpack-plugin：通过 webpack 自动生成 bundle.js 的 html 修改 html 的标题、meta 等信息在 src 中新建 index.html 模版，比如一般的 react、vue 项目中就有入口 html，可以使用&lt;%= htmlWebpackPlugin.options.title %&gt;来访问 config 中的插件配置 copy-webpack-plugin ： 用来拷贝需要的静态文件，比如 favicon，直接将静态资源复制到 dist 中  ","version":"Next","tagName":"h3"},{"title":"手写一个 Plugin​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#手写一个-plugin","content":" plugin 通过钩子机制来实现，在 plugin 工作中会有很多环节，每个节点都挂了很多的钩子，可以参考官方文档，自己定义插件往这些钩子上挂  plugin 是一个函数或者包含一个 apply 的方法  class MyPlugin{ apply(compiler){ console.log('myplugin启动') compiler.hooks.emit('MyPlugin',compilation=&gt;{ //compilation 此次打包的上下文 for (let name in compilation.assets){ console.log(name) if(name.endswith('.js')) { const contents =compilation.assetslnamel.source()const withoutComments = contents.replace(/\\/\\*\\*+\\*\\//g,'') compilation.assets[name]={ source:()=withoutComments, size:() withoutComments.length} } } }) } }     const {CleanWebpackPlugin} from 'clean-webpack-plugin' //... plugins:[{ new MyPlugin() , //使用 }]   ","version":"Next","tagName":"h3"},{"title":"开发体验​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#开发体验","content":"   这种方式过于原始，会降低开发效率，设想：理想开发环境，能使用 http server 运行，可以类似生产环境区运行，能自己编译自动刷新，自动构建，及时显示结果，大大减少开发重复，支持 source Map ，出现问题时能直接进入文件进行调试。  ","version":"Next","tagName":"h2"},{"title":"如何增强 webpack 开发体验？​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#如何增强-webpack-开发体验","content":" ","version":"Next","tagName":"h2"},{"title":"watch 工作模式​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#watch-工作模式","content":" 监听文件变化，自动重新打包进行构建。  使用 webpack 命令时，添加yarn webpack --watch,开启监视模式，每次修改文件自动打包，专注编码  ","version":"Next","tagName":"h3"},{"title":"Webpack Dev Server(推荐)​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#webpack-dev-server推荐","content":" 官方推出，结合了 watch 模式，一边编码 自动编译 自动刷新浏览器的功能，集成在一起，使用很简单。  不会生成 dist 模式，只是把打包结果暂时存放内存当中，devserver 从内存中进行读取，减少磁盘读写操作，加快效率- yarn add webpack-dev-server默认只会 serve 打包输出文件  ","version":"Next","tagName":"h3"},{"title":"BrowserSync 自动刷新浏览器更新内容（不推荐）​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#browsersync-自动刷新浏览器更新内容不推荐","content":" 实现自动刷新浏览器进行更新，原理是，dist 内容被 proxy 监听了，直接去刷新浏览器。缺点是太麻烦了，开发效率降低，webpack 会不断的写入 dist 进入磁盘，一直去监听变化也会消耗性能  ","version":"Next","tagName":"h3"},{"title":"热更新​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#热更新","content":" HMR 模块热更新，运行过程中的及时变化，不会重新刷新浏览器，应用运行状态不受影响。  webpack-dev-server --hot  初始配置方法：   //webpack.config.js //... const webpack = require('webpack') devServer:{ hot:true }, plugins:[ new webpack.HotModuleReplacementPlugin() ]   以上基本配置只能影响样式的热更新但是不能影响到 js 文件。  HMR 解惑：webpack 中的 hmr 不是开箱即用，需要进行其他的手动配置，手动处理模块热替换的内容。但一般的 cli 是帮忙进行处理了，框架下的开发，每种文件都是有规律的。脚手架创建的项目内部都继承了 HMR  ","version":"Next","tagName":"h3"},{"title":"source map​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#source-map","content":" source map是编译后代码和原始代码的一个映射关系。在生产环境，sourcemap不能发布到线上，通常做法是上传到异常监控服务，用于解析线上的错误信息  ","version":"Next","tagName":"h3"},{"title":"生产环境优化​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#生产环境优化","content":" ","version":"Next","tagName":"h2"},{"title":"mode（模式）通过为不同的工作环境创建不同的配置​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#mode模式通过为不同的工作环境创建不同的配置","content":" ","version":"Next","tagName":"h3"},{"title":"Tree Shaking​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#tree-shaking","content":" TreeShaking 不是指某个配置选项，是一组功能搭配使用之后的效果。  production 模式下自动启用   //webpack.config.js //... optimization:{ usedExports:true, //会把没用到的包都不打 去除 minimize:true //压缩输出结果 }   Tree Shaking&amp;Babel的关系：  Tree Shaking 前提是ES modules, 由webpack打包的代码必须是ESM ，为了转换es的新特性，使用babel loader转换es6-&gt;js； 最新版本的babel-loader不会导致tree-shaking失效，  合并模块  optimization:{ usedExports:true, //会把没用到的包都不打 去除 minimize:true, concatenateModules:true //尽可能多的把模块打包到同一个函数 }   sideEffects 副作用，开发npm包时候，一般用于npm包标记是否有副作用  生产模式下默认开启，会判断package.json下是否开启了sideEffect  optimization:{ sideEffect:true, //是否存在福泽园 // usedExports:true, //会把没用到的包都不打 去除 // minimize:true, // concatenateModules:true //尽可能多的把模块打包到同一个函数 }    &quot;sideEffects&quot;:false   ","version":"Next","tagName":"h3"},{"title":"Code Splitting（代码分割 ）​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#code-splitting代码分割-","content":" 项目所有代码都打包到一起，如果应用很复杂 模块很多，bundle体积就很大。并不是每个模块都需要在启动时进来就加载的。  把打包结果，按一定规则分离到多个bundle中，根据应用需要按需加载  分包的好处：  提高首屏性能提高缓存效率  两种分包方式：  多入口打包（Multi Entry）：根据业务配置不同的打包入口，此时会输出多个打包结果。 多用于传统的多页应用程序， 一个页面对应一个打包入口。对于公共的部分就提取到公共的结果中  //webpack.config.js .... entry:{ &quot;index&quot;:'./src/index.js', //多人口采用对象的形式，使用 key 为入口文件名，value是路径 &quot;alarm&quot;:'./src/alarm.js' }   但是  采用es module的动态导入，实现模块按需加载。此时也会把动态导入的内容，分到多个bundle中。比如在引入路由的时候使用import就可以将每一个视图所依赖的模块进行分包 使用import('./xxx.js') 将运行时的代码单独分包，但由于运行的代码体积较小，所以优化效果不明显  ###hash文件名（文件指纹） 输出文件名。可以出现缓存现象。生产模式下给文件名hash值，避免文件更新出现缓存的问题。  hash: 项目级别的。只要项目更新，所有hash值都会重新编写改变。且所有的文件都公用同一个hashchunkhash:chunk级别，只要是同一路的打包，chunk都是相同contenthash: 根据文件的内容生成，具有唯一性，只要文件改变就重新生成，这是解决缓存问题最好选择。  fileName:'[name]-[hash].bundle.js' fileName:'[name]-[chunkhash].bundle.js' fileName:'[name]-[contenthash].bundle.js'   ","version":"Next","tagName":"h3"},{"title":"并行处理打包优化​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#并行处理打包优化","content":" happyPack：多进程方式运行资源加载loader逻辑，5.0慢慢去除thread-loader：webpack官方出品，同样以多进程进行处理，后续会优化parallel-webpack：运用于多入口项目terserWebpackPlugin：支持多进程方式代码压缩、uglify功能  ","version":"Next","tagName":"h3"},{"title":"构建优化​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#构建优化","content":" ","version":"Next","tagName":"h2"},{"title":"加快构建速度(打包速度)​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#加快构建速度打包速度","content":" 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)  通过 exclude、include 配置来确保转译尽可能少的文件优化 resolve.modules 配置优化 resolve.mainFields 配置aliasnoParseextensions  在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中使用 happypack 开启多进程打包除了使用 Happypack 外，我们也可以使用 thread-loader 开启多进程打包 loader使用 HardSourceWebpackPlugin 为模块提供中间缓存，第二次构建可大量节约时间使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包使用 webpack-parallel-uglify-plugin 开启 JS 多进程压缩  ","version":"Next","tagName":"h3"},{"title":"减少打包文件体积​","type":1,"pageTitle":"","url":"/docs/notes/前端工程化/Webpack学习笔记#减少打包文件体积","content":" 引入 webpack-bundle-analyzer 分析打包后的文件，判断哪些包还可以拆分和优化  使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间使用 optimization.splitChunks 配置抽离公共代码使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）使用 url-loader 或 image-webpack-loader 对图片进行转化或者压缩处理优化 SourceMap，开发环境推荐： cheap-module-eval-source-map，生产环境推荐：cheap-module-source-map按需加载，项目中的路由懒加载webpack自身的优化：  tree-shaking，在生产环境下，会自动移除没有使用到的代码scope hosting 作用域提升，变量提升，可以减少一些变量声明babel 配置的优化，配置 @babel/plugin-transform-runtime，重复使用 Babel 注入的帮助程序，以节省代码大小的插件 ","version":"Next","tagName":"h3"},{"title":"JavaScript进阶面试题","type":0,"sectionRef":"#","url":"/docs/interview/JS进阶面试题","content":"","keywords":"","version":"Next"},{"title":"实现图片懒加载的思路​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#实现图片懒加载的思路","content":" 判断图片所在位置是否在可视区域内，图片移到可视区域内进行加载，提供三种判断方法：  offsetTop &lt; clientHeight + scrollTopelement.getBoundingClientRect().top &lt; clientHeightIntersectionObserver  方案一:clientHeight、scrollTop 和 offsetTop  首先给图片一个占位资源:   &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://www.xxx.com/target.jpg&quot; /&gt;   接着，通过监听 scroll 事件来判断图片是否到达视口:  let img = document.getElementsByTagName(&quot;img&quot;); let num = img.length; let count = 0;//计数器，从第一张图片开始计 lazyload();//首次加载别忘了显示图片 window.addEventListener('scroll', lazyload); function lazyload() { let viewHeight = document.documentElement.clientHeight;//视口高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度 for(let i = count; i &lt;num; i++) { // 元素现在已经出现在视口中 if(img[i].offsetTop &lt; scrollHeight + viewHeight) { if(img[i].getAttribute(&quot;src&quot;) !== &quot;default.jpg&quot;) continue; img[i].src = img[i].getAttribute(&quot;data-src&quot;); count ++; } } }   当然，最好对 scroll 事件做节流处理，以免频繁触发:  // throttle函数我们上节已经实现 window.addEventListener('scroll', throttle(lazyload, 200));   方案二：getBoundingClientRect  现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。  上述的 lazyload 函数改成下面这样:  function lazyload() { for(let i = count; i &lt;num; i++) { // 元素现在已经出现在视口中 if(img[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight) { if(img[i].getAttribute(&quot;src&quot;) !== &quot;default.jpg&quot;) continue; img[i].src = img[i].getAttribute(&quot;data-src&quot;); count ++; } } }   方案三: IntersectionObserver  这是浏览器内置的一个API，实现了监听window的scroll事件、判断是否在视口中以及节流三大功能。  let img = document.getElementsByTagName(&quot;img&quot;); const observer = new IntersectionObserver(changes =&gt; { //changes 是被观察的元素集合 for(let i = 0, len = changes.length; i &lt; len; i++) { let change = changes[i]; // 通过这个属性判断是否在视口中 if(change.isIntersecting) { const imgElement = change.target; imgElement.src = imgElement.getAttribute(&quot;data-src&quot;); observer.unobserve(imgElement); } } }) Array.from(img).forEach(item =&gt; observer.observe(item));   这样就很方便地实现了图片懒加载，当然这个IntersectionObserver也可以用作其他资源的预加载，功能非常强大。  ","version":"Next","tagName":"h2"},{"title":"以下代码输出结果？涉及异步问题​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#以下代码输出结果涉及异步问题","content":" async function async1() { console.log('async1 start'); await async2(); console.log('async1 end'); } async function async2() { new Promise(function(resolve) { console.log('promise1'); resolve(); console.log(&quot;promiseResolve&quot;) }).then(function() { setTimeout(function() { console.log('setTimeout1'); }) console.log('promise2'); }); } console.log('script start'); setTimeout(function() { console.log('setTimeout2'); }, 0) async1(); process.nextTick(() =&gt; { console.log(&quot;nextTick&quot;); }) new Promise(function(resolve) { console.log('promise3'); resolve(); setTimeout(() =&gt; { console.log('setTimeout3') }) }).then(function() { console.log('promise4'); }) .then(() =&gt; console.log('promise5')) .then(() =&gt; console.log('promise6')) console.log('script end'); /* script start async1 start promise1 promiseResolve promise3 nextTick // nextTick有自己的队列，优先于其它微任务先执行 promise2 script end async1 end promise4 promise5 promise6 setTimeout2 setTimeout3 setTimeout1 */   ","version":"Next","tagName":"h2"},{"title":"说说回流（重排）和重绘​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说说回流重排和重绘","content":" 浏览器渲染机制  浏览器采用流式布局模型（Flow Based Layout）  浏览器会把HTML解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就产生了渲染树（Render Tree）。  有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，合成布局树，最后把节点绘制到页面上。  由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。 注意：上面说的是首先会生成 Render Tree，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成 Render Tree 的过程了。而布局树的信息已经非常完善，完全拥有 Render Tree 的功能。  重绘  由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。  回流  回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流  浏览器优化  现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。  offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。   减少重绘与回流  CSS:  使用 transform 替代 top使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。避免使用 CSS 表达式，可能会引发回流。将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。CSS3 硬件加速（GPU加速），使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。  JavaScript:  避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。  ","version":"Next","tagName":"h2"},{"title":"在移动端中怎样初始化根元素的字体大小？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#在移动端中怎样初始化根元素的字体大小","content":" 一个简易版的初始化根元素字体大小。页面开头处引入下面这段代码，用于动态计算 font-size：(假设你需要的1rem = 20px)  (function () { var html = document.documentElement; function onWindowResize() { html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px'; } window.addEventListener('resize', onWindowResize); onWindowResize(); })();   document.documentElement：获取 document 的根元html.getBoundingClientRect().width：获取 html 的宽度(窗口的宽度)监听 window 的 resize 事件  一般还需要配合一个 meta 头：  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;   ","version":"Next","tagName":"h2"},{"title":"浏览器跨域问题​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#浏览器跨域问题","content":" 浏览器为什么要阻止跨域请求？如何解决跨域？每次跨域请求都需要到达服务端吗？什么是跨域  跨域是针对浏览器的“同源策略”提出的说法。之所以有“同源策略”这种模式是基于网络安全方面的考虑。所谓的同源策略关注三点：  协议 (http:www.baidu.com &amp; https.www.baidu.com http 协议不同，跨域) 域名 (https://www.aliyun.com &amp; https://developer.aliyun.com 域名不同，跨域) 端口 (http://localhost:8080 &amp; http://localhost:8000 端口号不同，跨域)  哪些网络资源涉及到跨域  “同源策略”对于跨域网络资源的设定非常的清晰。这些场景涉及到跨域禁止操作：  无法获取非同源网页的 cookie、localstorage 和 indexedDB。无法访问非同源网页的 DOM （iframe）。 +无法向非同源地址发送 AJAX 请求 或 fetch 请求（可以发送，但浏览器拒绝接受响应）。  为什么要阻止跨域呢？上文我们说过是基于安全策略：比如一个恶意网站的页面通过 iframe 嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的 javascript 脚本就可以在用户登录银行的时候获取用户名和密码。  如何解决跨域  通过 jsonp 跨域document.domain + iframe 跨域location.hash + iframewindow.name + iframe 跨域postMessage 跨域跨域资源共享（CORS）nginx 代理跨域nodejs 中间件代理跨域WebSocket 协议跨域  ","version":"Next","tagName":"h2"},{"title":"JSONP 的原理是什么？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#jsonp-的原理是什么","content":" 尽管浏览器有同源策略，但是 &lt;script&gt; 标签的src属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求  实现原理:  创建 callback 方法插入 script 标签后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法前端执行服务端返回的方法调用  function jsonp ({url, params, callback}) { return new Promise((resolve, reject) =&gt; { // 创建 script 标签 let script = document.createElement('script') // 将函数挂在 window 上 window[callback] = function (data) { resolve(data) // 代码执行后，删除 script 标签 document.body.removeChild(script) } // 回调函数加在请求地址上 params = {...params, callback} // wb=b&amp;callback=show let arrs = [] for (let key in params) { array.push(`${key}=${params[key]}`) } script.src = `${url}?${arrs.join('&amp;')}` document.body.appendChild(script) }) } //具体使用 function show(data) { console.log(data) } jsonp({ url: 'http://localhost:3000/show', params:{ // code 参数 }, callback: 'show' }).then(data =&gt; { console.log(data) })   ","version":"Next","tagName":"h2"},{"title":"如何实现深拷贝？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#如何实现深拷贝","content":" 深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj))  JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷：  对象的属性值是函数时，无法拷贝。原型链上的属性无法拷贝不能正确的处理 Date 类型的数据不能处理 RegExp会忽略 symbol会忽略 undefined  实现一个 deepClone 函数:  如果是基本数据类型，直接返回如果是 RegExp 或者 Date 类型，返回对应类型如果是复杂数据类型，递归。考虑循环引用的问题  手写实现：  // 递归拷贝 function deepClone(obj, hash = new WeakMap()) { if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) if (obj === null || typeof obj !== 'object') { // 如果不是复杂数据类型，直接返回 return obj } if(hash.has(obj)) { // 如果已经处理过相同的对象，直接获取（解决循环引用） return hash.get(obj) } /** * 如果 obj 是数组，那么 obj.constructor 是 [Function: Array] * 如果 obj 是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor() hash.set(obj, t) for (let ikey in obj) { // 递归 if (obj.hasOwnProperty(key)) { // 是否是自身的属性 t[key] = deepClone(obj[key], hash) } } }   ","version":"Next","tagName":"h2"},{"title":"深拷贝怎么解决循环引用问题​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#深拷贝怎么解决循环引用问题","content":" 看个例子：  function deepCopy(obj){ const res = Array.isArray(obj) ? [] : {}; for(let key in obj){ if(typeof obj[key] === 'object'){ res[key] = deepCopy(obj[key]); }else{ res[key] = obj[key]; } } return res } var obj = { a:1, b:2, c:[1,2,3], d:{aa:1,bb:2}, }; obj.e = obj; console.log('obj',obj); // 不会报错 const objCopy = deepCopy(obj); console.log(objCopy); //Uncaught RangeError: Maximum call stack size exceeded   从例子可以看到，当存在循环引用的时候，deepCopy会报错，栈溢出。  obj对象存在循环引用时，打印它时是不会栈溢出  深拷贝obj时，才会导致栈溢出  循环应用问题解决  即：目标对象存在循环应用时报错处理  大家都知道，对象的 key 是不能是对象的。  {{a:1}:2} // Uncaught SyntaxError: Unexpected token ':'   参考解决方式一：使用weekmap:解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系 这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型， 我们可以选择 WeakMap 这种数据结构：  检查 WeakMap 中有无克隆过的对象有，直接返回没有，将当前对象作为key，克隆对象作为value进行存储继续克隆  function isObject(obj) { return (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; obj !== null } function cloneDeep(source, hash = new WeakMap()) { if (!isObject(source)) return source; if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表 var target = Array.isArray(source) ? [] : {}; hash.set(source, target); // 新增代码，哈希表设值 for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (isObject(source[key])) { target[key] = cloneDeep(source[key], hash); // 新增代码，传入哈希表 } else { target[key] = source[key]; } } } return target; }   参考解决方式二：  const o = { a: 1, b: 2 }; o.c = o; function isPrimitive(val) { return Object(val) !== val; } const set = new Set(); function clone(obj) { const copied = {}; for (const [key, value] of Object.entries(obj)) { if (isPrimitive(value)) { copied[key] = value; } else { if (set.has(value)) { copied[key] = { ...value }; } else { set.add(value); copied[key] = clone(value); } } } return copied; }   ","version":"Next","tagName":"h2"},{"title":"聊一下promise？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#聊一下promise","content":" es6+引入的解决异步问题的方案，Promise是一个构造函数，可以通过new来创建一个实例的promise对象。  Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的 then 方法和 catch、finally 方法会返回一个新的 Promise 所以可以允许我们链式调用，解决了传统的回调地狱问题。  Promise的状态一经改变就不能再改变  关于 then 以及 catch 方法：  Promise的状态一经改变就不能再改变。.then和.catch都会返回一个新的Promise。catch不管被连接到哪里，都能捕获上层未捕捉过的错误。在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。.then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。.finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。  finally方法：  .finally()方法不管Promise对象最后的状态如何都会执行.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。  最后可以说一下all以及race方法：  Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。.race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。  缺点是： Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  ","version":"Next","tagName":"h2"},{"title":"说一下promise.all 和 promise.race?​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下promiseall-和-promiserace","content":" promise.all  const p = Promise.all([p1, p2, p3]);   Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。  Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。  p的状态是由p1,p2,p3 决定的，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。  （3）接受一个 Promise 数组，当所有 Promise 成功时返回结果数组；若任意一个失败，立即以该失败原因拒绝。  （4）即使某个 Promise 失败，其他 Promise 仍会继续执行，但结果会被忽略。  ","version":"Next","tagName":"h2"},{"title":"说一下 href 和 src 的区别（字节）?​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下-href-和-src-的区别字节","content":" href 用于建立当前页面与引用资源之间的关系，而 src 会替换当前元素。  遇到 href，页面会并行加载后续内容，而 src 则需要浏览器加载完毕 src 的内容才会继续往下走。  src 是 source 的缩写，指向外部资源的位置  指向的内容将会嵌入到文档中当前标签所在位置或下载并应用到文档内；如 js 脚本，img 图片和 iframe 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 href 是 Hypertext Reference 的缩写，指向网络资源所在位置  建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式  ","version":"Next","tagName":"h2"},{"title":"说一下图片不同格式的区别？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#说一下图片不同格式的区别","content":" 格式\t优点\t缺点\t适用场景gif\t支持动画、透明，无兼容性问题\t仅布尔透明\t色彩简单的 logo、icon、动图 jpg\t色彩丰富，文件小\t有损压缩，反复保存图片质量下降明显\t色彩丰富的图片/渐变图像，照片，复杂 banner png\t无损压缩，支持透明，简单图片尺寸小，高保真\t① 不支持动画，色彩丰富的图片尺寸大；② 对自然照片和复杂色块的图片压缩率不高\tlogo/icon/透明图，适用于 web 所有场景 webp\t文件小，支持有损和无损压缩，支持动画、透明\t浏览器兼容性相对而言不好\t支持 webp 格式的 app 和 webview，产品图片（如：京东） SVG\t① 可伸缩性，矢量图片随意放大缩小，不影响质量；显示效果好，不存在锯齿等情况② 体积小，Svg 平均比 GIF、 JPEG、 PNG 小得多，甚至在极高的分辨率下也是如此；③ 支持动画，更灵活、质量效果好；④ 与 DOM 无缝衔接，Svg 可以直接使用 HTML、 CSS 和 JavaScript （例如动画）来操作\t① 不适合高复杂度的图形，SVG 复杂度高会减慢渲染速度；② 不适合游戏类等高互动动画 图表（echarts），\t图标，logo  ","version":"Next","tagName":"h2"},{"title":"概述从输入 URL 到页面呈现的全过程？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#概述从输入-url-到页面呈现的全过程","content":" URL 解析 → DNS 查询 → TCP 握手 → TLS 握手 → 发送请求 → 服务器响应 → 解析 HTML → 构建 DOM → 解析 CSS → 构建 CSSOM → 执行 JS → 合并渲染树 → 布局 → 绘制 → 合成 → 页面呈现   URL 解析与输入处理 协议补全：浏览器自动补全协议（如 http:// 或 https://）。  安全检查：检查 URL 是否合法，是否触发黑名单（如恶意网站）。  HSTS 检查：若域名在 HSTS 预加载列表中，强制使用 HTTPS。  DNS 解析  本地缓存查询：依次检查浏览器缓存 → 系统（hosts 文件）→ 路由器缓存。  递归查询：若本地无缓存，向 DNS 服务器发起请求（如 8.8.8.8），直到找到域名对应的 IP。  建立网络连接  TCP 三次握手：客户端与服务器通过三次握手建立 TCP 连接。  TLS 握手（HTTPS）：若使用 HTTPS，需额外进行 TLS 握手（协商加密算法、交换密钥等）。  发送 HTTP 请求  构造请求报文：浏览器生成 HTTP 请求，包含请求行（方法、URL）、请求头（Cookie、UA 等）、请求体（POST 数据）。  发送请求：通过 TCP 连接发送到服务器。  服务器处理请求  负载均衡：请求可能被反向代理（如 Nginx）转发到后端服务器集群。  处理请求：服务器解析请求，执行业务逻辑（如查询数据库）。  生成响应：返回 HTTP 响应（状态码、响应头、响应体如 HTML 文件）。  浏览器接收响应  解析状态码：处理 3xx（重定向）、4xx/5xx（错误）等。  缓存策略：根据响应头（Cache-Control、ETag 等）决定是否缓存资源。  Content-Type 处理：根据 Content-Type（如 text/html）选择解析方式。  解析与渲染 加载后续资源  延迟加载：按需加载图片、字体等非关键资源（如 &lt;img loading=&quot;lazy&quot;&gt;）。  异步执行：通过defer/async延迟 JS 执行，避免阻塞渲染。  最终呈现  触发事件：页面触发 DOMContentLoaded（DOM 解析完成）和 load（所有资源加载完成）事件。  持续更新：通过AJAX/WebSocket动态更新内容，触发重排/重绘。  关键点： 减少 DNS 查询：使用 DNS 预解析（&lt;link rel=&quot;dns-prefetch&quot;&gt;）。  复用连接：HTTP/2 多路复用、Keep-Alive 保持 TCP 连接。  资源优化：压缩文件（Gzip/Brotli）、图片懒加载、CDN 加速。  渲染优化：避免强制同步布局、减少重排重绘、使用 requestAnimationFrame。  ","version":"Next","tagName":"h2"},{"title":"浏览器报错状态码304是什么意思？​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#浏览器报错状态码304是什么意思","content":" 当浏览器返回 HTTP 状态码 304 时，表示 资源未修改（Not Modified），这并非错误，而是服务器告知客户端可以直接使用本地缓存的副本，无需重新下载资源。  协商缓存（304 Not Modified）：需向服务器发起验证请求，确认缓存有效性。资源未修改，协商缓存验证通过。  ","version":"Next","tagName":"h2"},{"title":"聊一下浏览器缓存，强缓存和协商缓存的区别?​","type":1,"pageTitle":"JavaScript进阶面试题","url":"/docs/interview/JS进阶面试题#聊一下浏览器缓存强缓存和协商缓存的区别","content":" 说说你知道的浏览器缓存，项目中是如何实践的（叠纸、百度、小米）  浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存主要分为强缓存（也称本地缓存）和协商缓存（也称弱缓存）。  强缓存 当请求资源的时，如果是之前请求过的并使用强缓存，那么在过期时间内将不会发送本次请求向服务器获取资源，而是直接从浏览器缓存中获取（不管资源是否改动）。过期了将重新从服务器获取，并再次强缓存。 协商缓存 当请求资源时，如果是之前请求过的并使用协商缓存，还是发送请求到服务器，服务器通过逻辑判断确认资源没有修改返回304状态码，那么本次的资源则是从缓存中获取；如果经过判断确认资源被修改过，则重新发送资源到客户端，并且客户端更新缓存。 ","version":"Next","tagName":"h2"},{"title":"JavaScript基础整理","type":0,"sectionRef":"#","url":"/docs/notes/JavaScript/JavaScrpit基础","content":"","keywords":"","version":"Next"},{"title":"数据类型、变量和变量提升​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数据类型变量和变量提升","content":" ","version":"Next","tagName":"h2"},{"title":"数据类型​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数据类型","content":" 在 JavaScript 中，我们可以分成两种类型：  基本类型复杂类型 两种类型的区别是：存储位置不同  基本类型主要为以下6种：  Number  // 数值最常⻅的整数类型格式则为⼗进制，还可以设置⼋进制（零开头）、⼗六进制（0x开头） let intNum = 55 // 10进制的55 let num1 = 070 // 8进制的56 let hexNum1 = 0xA //16进制的10 // 浮点类型则在数值汇总必须包含⼩数点，还可通过科学计数法表示 let floatNum1 = 1.1; let floatNum2 = 0.1; let floatNum3 = .1; // 有效，但不推荐 let floatNum = 3.125e7; // 等于 31250000 // 在数值类型中，存在⼀个特殊数值 NaN ，意为“不是数值”，⽤于表示本来要返回数值的操作失败了 // （⽽不是抛出错误） console.log(0/0); // NaN console.log(-0/+0); // NaN   String  字符串可以使⽤双引号（&quot;）、单引号（'）或反引号（`）标示  let firstName = &quot;John&quot;; let lastName = 'Jacob'; let lastName = `Jingleheimerschmidt`   字符串是不可变的，意思是⼀旦创建，它们的值就不能变了  let lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; // 先销毁再创建   Boolean  Boolean （布尔值）类型有两个字⾯值： true 和 false  通过 Boolean 可以将其他类型的数据转化成布尔值  数据类型\t转换为 true 的值\t转换为 false 的值String\t⾮空字符串\t&quot;&quot; Number\t⾮零数值（包括⽆穷值）\t0 、 NaN Object\t任意对象\tnull Undefined\tN/A （不存在）\tundefined  Undefined  Undefined 类型只有⼀个值，就是特殊值 undefined 。当使⽤ var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值  let message; console.log(message == undefined); // true // 包含 undefined 值的变量跟未定义变量是有区别的 let message; // 这个变量被声明了，只是值为 undefined console.log(message); // &quot;undefined&quot; console.log(age); // 没有声明过这个变量，报错   null  Null 类型同样只有⼀个值，即特殊值 null.  只要变量要保存对象，⽽当时⼜没有那个对象可保存，就可⽤ null 来填充该变量  逻辑上讲， null 值表示⼀个空对象指针，这也是给 typeof 传⼀个 null 会返回 &quot;object&quot; 的原因  let car = null; console.log(typeof car); // &quot;object&quot; 所以使用typeof判断null值会出问题   undefined 值是由 null 值派⽣⽽来  console.log(null == undefined); // true   symbol es6+新增  Symbol （符号）是原始值，且符号实例是唯⼀、不可变的。符号的⽤途是确保对象属性使⽤唯⼀标识 符，不会发⽣属性冲突的危险  let genericSymbol = Symbol(); let otherGenericSymbol = Symbol(); console.log(genericSymbol == otherGenericSymbol); // false let fooSymbol = Symbol('foo'); let otherFooSymbol = Symbol('foo'); console.log(fooSymbol == otherFooSymbol); // false   BigInt es6+新增最大安全数字Number.MAX_SAFE_INTEGER =9007199254740991。必须是整数，不能是小数！  var obj=456n;此时obj就是最大数数据类型，而不是数字数据类型了 console.log(Symbol() == Symbol()); //false console.log(Symbol('AA') == Symbol('AA')); //false let n = Symbol('AA'); let m = n; console.log(n == m); //true   复杂数据类型，又成引用数据类型  ObjectArrayFunction  引用类型，栈内存中存储的是引用地址，堆内存中存储的是实际的值  ","version":"Next","tagName":"h3"},{"title":"变量提升​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#变量提升","content":" 提到变量提升，首先要引入一个“预编译的概念”。  预编译是JavaScript中一个重要的概念，经常出现在面试中。JavaScript中的&quot;var&quot;变量提升和预编译是紧密相关的概念，它们在理解JavaScript中变量声明和作用域的工作方式时非常重要。今天我们来深入聊聊预编译，让大家理解预编译和变量提升的底层逻辑。本文会使用简单的例子以及通俗易懂的语言，小白没压力。  关于变量提升，先看代码：   var a = 123 console.log(a); // 很明显，答案输出123.让我们对这串代码改动一下。 console.log(x); // 输出undefined var x = 5;   按正常逻辑来说，这串代码应该会报错，但是我们可以发现实际上输出的是undefined,这是因为使用var声明变量会出现变量提升的效果，就相当于：   var a console.log(a); a = 5 // 这就是变量提升   在JavaScript中，变量声明（使用var关键字）会被&quot;提升&quot;到其作用域的顶部，这意味着在变量声明之前使用变量是合法的，尽管在代码中实际声明变量的位置之前。这是因为JavaScript引擎在执行代码之前会将变量声明提升到作用域的顶部。  又比如：  function example() { console.log(x); // 输出 undefined var x X = 5 console.log(x); // 输出 5 } example(); //以上代码相当于： function example() { var x console.log(x); // 输出 undefined x = 5; console.log(x); // 输出 5 } example();   那为什么会变量提升呢？  JavaScript的编译过程通常分为两个主要步骤：预编译（Compilation）和执行（Execution）。预编译是指JavaScript引擎在实际执行代码之前，对代码进行一些处理，包括变量提升和函数声明。在预编译阶段，JavaScript引擎会扫描代码，找到所有变量声明和函数声明，并将它们提升到适当的作用域。  预编译发生在函数执行之前 预编译发生在全局区  预编译发生在函数执行之前  创建AO对象 （Action Object） 找形参和变量声明，将变量声明和形参作为AO的属性名，值为undefined 将形参和实参值统一 在函数体内找函数声明，将函数名作为AO对象的属性名，值赋予函数体  就拿上述为例：  function example(x) { console.log(x); //输出 2 var x x = 5 console.log(x); //输出 5 } example(2); //1.首先我们先创建一个AO对象 AO:{ //2.开始找变量声明和形参 x : undefined //3.将形参和实参值统一 x :undefined ==&gt; x : 2 //4.由于函数体内没有函数声明，跳过该步骤 }   我们已经完成一次预编译了，现在函数开始执行，由上到下，当函数执行到第一个 console.log(x) 时，它将从AO对象中寻找x的值，输出为2.函数继续向下执行，变量声明，跳过，当发现赋值语句 x = 5时，将AO对象中x的值改变为5. 函数继续向下执行到 第二个console.log(x) 时，输出为 5.  接下来我们一起来看看一道有点难度的题  function foo(a, b) { console.log(a); //输出 1 c = 0 var c; a = 3 // a : undefined ==&gt; 3 函数执行时 b = 2 // b : undefined ==&gt; 2 console.log(b); // 输出 2 function b() { } function d() { } console.log(b); // 输出 2 } foo(1) //那是怎么预编译呢？ AO：{ a : undefined ==&gt; a : 1 //统一值 b : undefined ==&gt; b : function b(){} c : undefined ==&gt; d : function d(){} //函数声明，属性名为函数名，值赋予函数体 } //当编译完成后再去执行函数，这样我们就很容易得出答案啦。   预编译发生在全局区  ①创建GO对象 （Global Object）  ②找变量声明，将变量声明作为GO的属性名，值为undefined  ③在全局找函数声明，将函数名作为GO对象的属性名，值赋予函数体  我们直接上例子看看是怎么个事  var a = 100 function fn() { console.log(a); } //解析 GO：{//找变量声明 a : undefined //找函数声明 fn : function fn() } fn()   但我们可以发现，函数预编译和全局预编译在一段代码中通常一起发生，比如上图，当预编译全局完成时，开始执行，当执行完 a = 100后，准备执行函数fn(),这时预编译发生在函数执行时。  再来一个例子，他们结合在一起时：  a = 100 function fn() { console.log(a); // 输出 100 b = 200 var b // 输出 200 console.log(b) } fn() var global //预编译完成之后 ，我们发现这样GO对象和AO对象都会存在： GO: { a : undefined fn : function fn() } AO: { b : undefined }   AO里面没有a，为什么当console.log(a)时会输出呢？而我们发现，GO函数里有a,是不是用了GO里面的a呢？这里我们就要引出调用栈的概念了  上面所说的AO、GO对象其实是属于执行上下文的一部分，便于我们理解  调用栈用于跟踪函数的调用顺序和执行上下文的管理。每当函数被调用，一个新的执行上下文会被推入调用栈，表示该函数的执行。  全局预编译和函数预编译的结果在执行上下文中存储，然后被推入调用栈。调用栈的顶部始终包含当前正在执行的函数的上下文。  全局执行上下文分为变量环境和词法环境，而我们用var声明的变量存在变量环境中。我们都知道栈是先进后出，为什么这里全局执行上下文在栈底部呢，也就是比fn执行上下文先进来，因为在调用栈中，全局预编译通常会在函数预编译之前完成，因此全局预编译的结果位于调用栈的底部，而函数的预编译结果则根据函数调用的顺序依次位于调用栈中。  当函数执行时，需要输出a，但是在fn执行上下文里面并没有找到a这个东西，如果变量在当前函数的执行上下文找不到，JavaScript引擎会在全局执行上下文中寻找变量  详细可参考文章var为什么会变量提升？一盏茶的功夫让你彻底熟悉预编译  ","version":"Next","tagName":"h3"},{"title":"作用域、作用域链、执行上下文​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#作用域作用域链执行上下文","content":" 作用域  作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)  作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)  作用域分为：  全局作用域函数作用域块级作用域  作用域链作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。  JS执行上下文栈(后面简称执行栈)  执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：  首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。  ","version":"Next","tagName":"h2"},{"title":"闭包​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#闭包","content":" ","version":"Next","tagName":"h2"},{"title":"原型和原型链​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#原型和原型链","content":" ","version":"Next","tagName":"h2"},{"title":"深拷贝和浅拷贝​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#深拷贝和浅拷贝","content":" ","version":"Next","tagName":"h2"},{"title":"对象​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#对象","content":" ","version":"Next","tagName":"h2"},{"title":"数组​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#数组","content":" ","version":"Next","tagName":"h2"},{"title":"字符串​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#字符串","content":" ","version":"Next","tagName":"h2"},{"title":"dom操作​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#dom操作","content":" ","version":"Next","tagName":"h2"},{"title":"bom​","type":1,"pageTitle":"JavaScript基础整理","url":"/docs/notes/JavaScript/JavaScrpit基础#bom","content":"","version":"Next","tagName":"h2"},{"title":"JavaScript基础面试题","type":0,"sectionRef":"#","url":"/docs/interview/JS基础面试题","content":"","keywords":"","version":"Next"},{"title":"document load 和 document ready 的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#document-load-和-document-ready-的区别","content":" Document.onload 是在结构和样式加载完才执⾏ js。 window.onload：不仅仅要在结构和样式加载完，还要执⾏完所有的样式、图片这些资源文件，全部 加载完才会触发window.onload事件。 Document.ready 原⽣种没有这个⽅法，jquery 中有$().ready(function)。  ","version":"Next","tagName":"h2"},{"title":"undefined 的三种情况​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#undefined-的三种情况","content":" ⼀个变量定义了却没有被赋值。⼀个对象上不存在的属性或者⽅法。⼀个数组中没有被赋值的元素。  ","version":"Next","tagName":"h2"},{"title":"生成随机数的写法​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#生成随机数的写法","content":" Math.round(Math.random()*差值)+最小的值   ","version":"Next","tagName":"h2"},{"title":"link 与 import 的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#link-与-import-的区别","content":" link 不仅仅可以加载css，import 只能加载css。link 同时加载，import 先载入页面内容。link 无兼容问题。link ⽀持使⽤Javascript控制DOM去改变样式；⽽@import不⽀持。  ","version":"Next","tagName":"h2"},{"title":"null和undefined的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#null和undefined的区别","content":" null 表示一个&quot;无&quot;的对象，也就是该处不应该有值；而 undefined 表示未定义。 在转换为数字时结果不同，Number(null) 为 0，而 undefined 为 NaN。  使用场景上：  null： 作为函数的参数，表示该函数的参数不是对象作为对象原型链的终点undefined: 变量被声明了，但没有赋值时，就等于 undefined 调用函数时，应该提供的参数没有提供，该参数等于 undefined对象没有赋值属性，该属性的值为 undefined函数没有返回值时，默认返回 undefined  ","version":"Next","tagName":"h2"},{"title":"js数组去重？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#js数组去重","content":" filter 过滤去重[...new Set(arr)]，es6最常用  //不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉 {} 空对象，后面的高阶方法会添加去掉重复 {} 的方法。 function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {}, {}]   for 循环嵌套，利用 splice 去重，es5最常用  //双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值 function unique(arr){ for(var i=0; i&lt;arr.length; i++){ for(var j=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; } } } return arr; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}] //NaN和{}没有去重，两个null直接消失了   新建数组，利用 indexOf 或者 includes 去重先用sort排序，然后用一个指针从第0位开始，配合 while 循环去重  关于js去重详细内容参考文档  ","version":"Next","tagName":"h2"},{"title":"apply， call ，bind 三者的相同点及区别​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#apply-call-bind-三者的相同点及区别","content":" 相同点: .bind(), .call(), 和 .apply() 是 JavaScript 中用于改变函数执行上下文（即函数内部的 this 值）的方法，第一个参数都是 this 要指向的对象  不同点：  call 和 aplly 的区别只是在与参数不同，call 的第二个参数是目标函数的第一个参数，第三个是目标函数的第二个参数以此类推，apply 的第二个参数是个数组，数组里面的每一项一次是目标函数的参数bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用  .bind() 方法：  .bind() 方法会创建一个新函数，并将指定的对象作为新函数的执行上下文（即绑定 this 值）。.bind() 方法返回一个绑定了指定上下文的新函数，而不会立即执行原函数。可以通过 .bind() 方法绑定上下文，并传递参数给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; const greetPerson = greet.bind(person); greetPerson('Alice'); // 输出: Hello, Alice! I'm John.   .call() 方法：  .call() 方法立即调用原函数，并将指定的对象作为原函数的执行上下文（即绑定 this 值）。可以通过 .call() 方法指定上下文，并传递参数给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; greet.call(person, 'Alice'); // 输出: Hello, Alice! I'm John.   .apply() 方法： .apply() 方法立即调用原函数，并将指定的对象作为原函数的执行上下文（即绑定 this 值）。 与 .call() 方法不同的是，.apply() 方法接受一个数组作为参数，数组中的元素将作为参数传递给原函数。  function greet(name) { console.log(`Hello, ${name}! I'm ${this.name}.`); } const person = { name: 'John' }; greet.apply(person, ['Alice']); // 输出: Hello, Alice! I'm John.   总结：  .bind() 方法创建一个新函数并绑定上下文，不立即执行。  .call() 方法立即调用函数并绑定上下文，可以传递参数。  .apply() 方法立即调用函数并绑定上下文，接受一个参数数组。  选择使用哪种方法取决于需要何时绑定上下文以及是否需要传递参数  ","version":"Next","tagName":"h2"},{"title":"说说回流（重排）和重绘？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说说回流重排和重绘","content":" 浏览器渲染机制 浏览器采用流式布局模型（Flow Based Layout） 浏览器会把HTML解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就产生了渲染树（Render Tree）。  有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，合成布局树，最后把节点绘制到页面上。  由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。  注意：上面说的是首先会生成 Render Tree，也就是渲染树，其实这还是 16 年之前的事情，现在 Chrome 团队已经做了大量的重构，已经没有生成 Render Tree 的过程了。而布局树的信息已经非常完善，完全拥有 Render Tree 的功能。  重绘 由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。 回流 回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流 浏览器优化 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。  offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightwidth、heightgetComputedStyle()getBoundingClientRect()  减少重绘与回流  使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局  避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。  尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。  避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。  将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。  避免使用 CSS 表达式，可能会引发回流。  将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。  CSS3 硬件加速（GPU加速），使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。  JavaScript:  避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。  避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。  避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。  对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。  ","version":"Next","tagName":"h2"},{"title":"深拷贝浅拷贝的区别？如何实现一个深拷贝？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#深拷贝浅拷贝的区别如何实现一个深拷贝","content":" 前面文章我们讲到，JavaScript中存在两大数据类型：  基本类型引用类型  基本类型数据保存在在栈内存中  引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中  浅拷贝  浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝  如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址  即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址  简单实现：  function shallowClone(obj) { const newObj = {}; for(let prop in obj) { if(obj.hasOwnProperty(prop)){ newObj[prop] = obj[prop]; } } return newObj; }   在JavaScript中，存在浅拷贝的现象有：  Object.assign  var obj = { age: 18, nature: ['smart', 'good'], names: { name1: 'fx', name2: 'xka' }, love: function () { console.log('fx is a great girl') } } var newObj = Object.assign({}, fxObj);   Array.prototype.slice(), Array.prototype.concat()  //slice方法 const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = fxArr.slice(0) fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] //concat方法 const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = fxArr.concat() fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]   使用拓展运算符实现的复制  const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] const fxArrs = [...fxArr] fxArrs[1] = &quot;love&quot;; console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]   ","version":"Next","tagName":"h2"},{"title":"深拷贝​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#深拷贝","content":" 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性.  常见的深拷贝方式有：  _.cloneDeep()。lodash工具的api  const _ = require('lodash'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f);// false   jQuery.extend()。jq的api  const $ = require('jquery'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = $.extend(true, {}, obj1); console.log(obj1.b.f === obj2.b.f); // false   JSON.stringify() 但是这种方式存在弊端，会忽略undefined、symbol和函数  const obj2=JSON.parse(JSON.stringify(obj1)); //函数、undefined、symbol不能深拷贝 const obj = { name: 'A', name1: undefined, name3: function() {}, name4: Symbol('A') } const obj2 = JSON.parse(JSON.stringify(obj)); console.log(obj2); // {name: &quot;A&quot;}   手写循环递归  function deepClone(obj, hash = new WeakMap()) { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; }   ","version":"Next","tagName":"h2"},{"title":"如何正确判断this的指向？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#如何正确判断this的指向","content":" 如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。  但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：  this 的指向可以按照以下顺序判断:  全局环境中的 this  浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window;  node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 ;  是否是 new 绑定  如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:  构造函数返回值是 function 或 object，new Super()是返回的是Super种返回的对象。  构造函数返回值不是 function 或 object。new Super() 返回的是 this 对象。  案例：  function Super(age){ this.age = age } let instance = new Super('26') console.log(instance.age) // 26   function Super(age){ this.age = age let obj = {a:'2'} return obj } let instance = new Super('26') console.log(instance) // {a:'2'} console.log(instance.age) // undefined   function Super(age){ this.age = age } let instance = new Super('26') console.log(instance) // {age:'26'} console.log(instance.age) // 26   函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。  function info(){ console.log(this.age) } var person= { age: 20, info } var age = 28 var info = person.info info.call(person) // 20 info.apply(person) // 20 info.bind(person)() // 20   这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)  function info () { // node 环境中：非严格模式 globao,严格模式 null // 浏览器环境中：非严格模式 window, 严格模式为 null console.log(this) console.log(this.age) } var person = { age: 20, info } var age = 28 var info = person.info // 严格模式抛出错误 // 非严格模式，node 下输出 undefined（因为全局的 age 不会挂在 global 上） // 非严格模式，浏览器环境下输出28（因为全局的 age 回挂在 window 上） info.call(null)   隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()  function info(){ console.log(this.age) } var person= { age: 20, info } var age = 28 person.info() // 20，执行的是隐式绑定 info(); // 28 注意这里直接调用和赋值引用调用结果不同   默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。  非严格模式： node环境，指向全局对象 global，浏览器环境，指向全局对象 window。  严格模式：执行 undefined  function info(){ console.log(this.age) } var age = 28 // 严格模式浏览器环境和node环境都抛错 // 非严格模式：node下输出 undefined（因为全局的 age 不会挂在 global 上） // 非严格模式：浏览器环境下输出 28（因为全局的 age 回挂在 window 上） info()   箭头函数的情况  箭头函数没有自己的this，继承外层上下文绑定的this。  let obj = { age: 20, info: function() { return () =&gt; { console.log(this.age) } } } let person = {age: 28} let info = obj.info() info() // 20 let info2 = obj.info.call(person) info2() // 28   ","version":"Next","tagName":"h2"},{"title":"CommonJS和ES6模块的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#commonjs和es6模块的区别","content":" CommonJS模块是运行时加载，ES6 Modules是编译时输出接口  CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变  CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串  CommonJS this指向当前模块，ES6 Modules this指向undefined  且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname  ","version":"Next","tagName":"h2"},{"title":"说一下es6新特性？平常工作中ES6+主要用到了哪些？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说一下es6新特性平常工作中es6主要用到了哪些","content":" ES6：  Class模块import和export箭头函数函数默认参数...扩展运输符允许展开数组解构字符串模版Promiselet constProxy、Map、Set对象属性同名能简写  ES7：  includes**求幂运算符  ES8：  async/awaitObject.values()和Object.entries()padStart()和padEnd()Object.getOwnPropertyDescriptors()函数参数允许尾部  ES9:  for...await...of...展开符合允许展开对象收集剩余参数Promise.finally()正则中的四个新功能  ES10：  flat()flatMap()fromEntries()trimStart和trimEndmatchAllBigInttry/catch 中报错允许没有err异常参数Symbol.prototype.descriptionFunction.toString() 调用时呈现原本源码的样子  ","version":"Next","tagName":"h2"},{"title":"如何判断一个变量是对象还是数组？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#如何判断一个变量是对象还是数组","content":" 判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好  function isObjArr(value){ if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) { console.log('value是数组'); }else if(Object.prototype.toString.call(value)==='[object Object]'){//这个方法兼容性好一点 console.log('value是对象'); }else{ console.log('value不是数组也不是对象') } }   通常判断是不是为数组，可以使用Array.isArray()判断.千万不能使用 typeof 来判断对象和数组，因为这两种类型都会返回 &quot;object&quot;。  ","version":"Next","tagName":"h2"},{"title":"通过reduce函数来实现简单的数组求和，示例数组[3,4,8,0,9];​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#通过reduce函数来实现简单的数组求和示例数组34809","content":" let result=[3,4,8,0,9].reduce((total,value)=&gt;{ //这两个参数是默认参数不用设置的 return total+value });   ","version":"Next","tagName":"h2"},{"title":"DOM事件中target和currentTarget的区别?​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#dom事件中target和currenttarget的区别","content":" target是事件触发的真实元素currentTarget是事件绑定的元素事件处理函数中的this指向是中为currentTargetcurrentTarget和target，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡） 当事件是子元素触发时，currentTarget为绑定事件的元素，target为子元素事件是元素自身触发时，currentTarget和target为同一个元素。  &lt;body&gt; &lt;ul id=&quot;box&quot;&gt; &lt;Li id=&quot;apple&quot;&gt;苹果&lt;/Li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;桃子&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var box = document.getElementById('box'); var apple = document.getElementById('apple'); //直接绑定在目标元素apple上 apple.onclick = function (e){ console.log(e.target); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.currentTarget); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(this); //&lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.target === e.currentTarget); //true console.log(e.target === this); //true } //绑定在父元素box上（如果点击apple这个li时） box.onclick = function (e){ console.log(e.target); // &lt;li id=&quot;apple&quot;&gt;苹果&lt;/li&gt; console.log(e.currentTarget); //&lt;ul id=&quot;box&quot;&gt;...&lt;/ul&gt; console.log(this); //&lt;ul id=&quot;box&quot;&gt;...&lt;/ul&gt; console.log(e.currentTarget===this); //true console.log(e.target === e.currentTarget); //false console.log(e.target === this); //false } &lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"说一下let、const、var 的区别和let、const的暂时性死区​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#说一下letconstvar-的区别和letconst的暂时性死区","content":" 区别：  let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。 相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。 const 声明变量时必须设置初始值 const 声明一个只读的常量，这个常量不可改变。  暂时性死区：let、const 所声明的变量，只在命令所在的代码块内有效。和var不同的还有，let命令不存在变量提升，所以声明前调用变量，都会报错。  ","version":"Next","tagName":"h2"},{"title":"weak-Set、weak-Map 和 Set、Map 区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#weak-setweak-map-和-setmap-区别","content":" 都是es6+新加的数据结构  Set。集合数据结构  类似数组，只有键值，没有键名。成员不可重复可以通过for of \\forEach遍历，方法有add、delete、has  const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4   Set()函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。  Map键值对的集合  类似对象，存储键值对map数据结构键名可以是任意类型，普通object的键名只能是字符串forEach\\for of 可遍历。需要特别注意的是，Map 的遍历顺序就是插入顺序  weakSet  成员都是对象或者symbol，不能是其他类型的值成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。不能遍历，方法有add, delete,has  WeakMap  直接受对象作为健名（null除外），不接受其他类型的值作为健名健名所指向的对象，不计入垃圾回收机制不能遍历，方法同get,set,has,delete  ","version":"Next","tagName":"h2"},{"title":"聊一下作用域、作用域链、执行上下文​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#聊一下作用域作用域链执行上下文","content":" 作用域  作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)  作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)  作用域分为：  全局作用域函数作用域块级作用域  作用域链作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。  JS执行上下文栈(后面简称执行栈)  执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：  首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。  ","version":"Next","tagName":"h2"},{"title":"可迭代对象有哪些特点​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#可迭代对象有哪些特点","content":" ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，换个角度，也可以认为，一个数据结构只要具有 Symbol.iterator 属性(Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。  可迭代对象的特点：  具有 Symbol.iterator 属性，Symbol.iterator() 返回的是一个遍历器对象可以使用 for ... of 进行循环通过被 Array.from 转换为数组  原生具有 Iterator 接口的数据结构：  ArrayMapSetStringTypedArray函数的 arguments 对象NodeList 对象  ","version":"Next","tagName":"h2"},{"title":"for...in 和 for...of的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#forin-和-forof的区别","content":" for...in  用于遍历对象的可枚举属性（包括继承的属性），适用于普通对象、数组等。  示例：遍历对象属性名、数组索引。  //返回对象的键名（key），对数组来说是字符串类型的索引 const obj = { a: 1, b: 2 }; for (const key in obj) { console.log(key); // 输出 &quot;a&quot;, &quot;b&quot; } const arr = [10, 20]; for (const index in arr) { console.log(index); // 输出 &quot;0&quot;, &quot;1&quot;（字符串） }   for...in会遍历所有可枚举属性（包括非数字属性），而for...of只遍历元素值。  const arr = [3, 5, 7]; arr.foo = &quot;bar&quot;; for (const key in arr) { console.log(key); // 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot; } for (const value of arr) { console.log(value); // 输出 3, 5, 7 }   for in 会遍历原型链上的可枚举属性，需用hasOwnProperty过滤。  const parent = { inherited: true }; const child = Object.create(parent); child.own = true; for (const key in child) { console.log(key); // 输出 &quot;inherited&quot;, &quot;own&quot; if (child.hasOwnProperty(key)) { console.log(&quot;Own property:&quot;, key); // 输出 &quot;Own property: own&quot; } }   for...of  用于遍历可迭代对象（Iterable）的值，如数组、字符串、Map、Set等。  示例：遍历数组元素、字符串字符、Map的键值对。  //返回可迭代对象的值（value） const arr = [10, 20]; for (const value of arr) { console.log(value); // 输出 10, 20 } const str = &quot;hi&quot;; for (const char of str) { console.log(char); // 输出 &quot;h&quot;, &quot;i&quot; }   for...of无法直接遍历普通对象（默认不可迭代），但可以通过Object.keys()或实现Symbol.iterator解决  const obj = { a: 1, b: 2 }; // 错误：obj不可迭代 // for (const value of obj) { ... } // 正确：先获取键名再遍历 for (const key of Object.keys(obj)) { console.log(key); // 输出 &quot;a&quot;, &quot;b&quot; }   不涉及原型链，直接通过迭代器获取值，性能更优!!  总结：  特性\tfor...in\tfor...of适用对象\t对象（可枚举属性）\t可迭代对象（数组、Map、Set等） 遍历内容\t键名（字符串类型）\t值 原型链属性\t包含（需过滤）\t不涉及 普通对象遍历\t支持\t需自行实现迭代器 性能\t较慢（需检查原型链）\t较快  ","version":"Next","tagName":"h2"},{"title":"map 和 foreach的区别？​","type":1,"pageTitle":"JavaScript基础面试题","url":"/docs/interview/JS基础面试题#map-和-foreach的区别","content":" 二者都是遍历数组的方法，用于遍历数组并对每个元素执行特定的操作。区别如下：  返回值的区别  map会返回一个新数组，数组中的每个元素是回调函数的返回值。forEach没有返回值，返回的是undefined。通常不能return或中断，只能抛出报错来中断  const numbers = [1, 2, 3, 4]; // 使用map const doubled = numbers.map(num =&gt; num * 2); console.log(doubled); // [2, 4, 6, 8] // 使用forEach numbers.forEach(num =&gt; console.log(num * 2)); // 输出2, 4, 6, 8，但没有返回数组   用途  map适用于需要对数组中的每个元素进行转换并生成新数组的情况。forEach适用于仅需对数组中的每个元素执行操作而不需要新数组的情况。  const names = ['Alice', 'Bob', 'Charlie']; // 使用map进行转换 const uppercasedNames = names.map(name =&gt; name.toUpperCase()); console.log(uppercasedNames); // ['ALICE', 'BOB', 'CHARLIE'] // 使用forEach进行操作 names.forEach(name =&gt; console.log(name.toLowerCase())); // 输出alice, bob, charlie   链式调用 由于map返回一个新数组，可以与其他数组方法进行链式调用，而forEach不支持链式调用。  const numbers = [1, 2, 3, 4]; // 使用map进行链式调用 const result = numbers.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5); console.log(result); // [6, 8] // 使用forEach不能链式调用 numbers.forEach(num =&gt; num * 2).filter(num =&gt; num &gt; 5); // TypeError: Cannot read property 'filter' of undefined   在性能方面，map和forEach的表现通常相似，但由于map会创建一个新数组，因此在处理大量数据时，map可能会稍慢一些。 ","version":"Next","tagName":"h2"}],"options":{"languages":["en","zh"],"indexBaseUrl":true,"id":"default"}}