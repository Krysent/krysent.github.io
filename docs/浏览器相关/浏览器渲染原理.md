# 浏览器渲染原理

浏览器有一个渲染进程的主线程，专门用来进行浏览器渲染的解析。当浏览器接收到一个html文档时，会产生一个渲染任务，在事件循环机制下从消息队列里面取出任务依次执行。渲染流程主要分以下这几个步骤：

当网络线程收到html文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。
在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

输入HTML后，整个渲染流程分为多个阶段，分别是：
HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画
每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。这样，整个渲染流程就形成了一套组织严密的生产流水线

## Parse解析阶段
主要流程：
1. Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。
2. Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如 `<html>`, `<body>`）。
3. Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。
4. DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。


 **解析html文档构建dom树（一个个的dom对象）** 
 **加载次级的资源，比如img、外部的css文件、js文件、字体文件等。存在预解析器用来下载和加载css去扫描这些文件。**  
 **遇到js文件时可能会阻塞解析流程，要停止html解析去下载加载`<script>`标签的内容，可使用async和defer来优化**

 ## Style样式计算

 Recalculate Style 计算样式阶段

CSS 引擎处理样式的过程分为三个阶段：
1. 收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。
2. 访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。
3. 结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。
**css引擎会遍历dom节点做匹配，将css样式解析出来加到对应的标签上。构建cssom树，与构建dom树并行构建，不会影响dom树的构建，但会阻塞js的执行，因为js可能会操作样式。在进入下一阶段之前，cssom树必须全部构建完毕。所以cssom会阻塞渲染过程。**
**在大型网站中，会存在大量的 CSS 规则，如果为每个节点都保存一份样式值，会导致内存消耗过大。作为替代，CSS 引擎通常会创建共享的样式结构，计算样式对象一般有指针指向相同的共享结构** 

## Layout构建排列

Layout排列阶段，创建Layout树（RenderObject渲染对象）

**有了dom树和对应的样式计算之后，浏览器会将这些信息构建成一个layout树，构建所有可见的dom节点，以及每个节点的所有样式信息**

layout树和dom树不一定是一一对应的，构建layout树主要是以下流程

1. 从 DOM 树的根节点开始遍历每个可见节点。
  ○ 某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。
  ○ 某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。
  ○ 为伪元素创建 LayoutObject。
  ○ 为行内元素创建匿名包含块对应的 LayoutObject。
2. 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
3. 产出可见节点，包含其内容和计算的样式。
dom树+cssom树 = renderTree

**构建完之后，浏览器开始做布局计算，计算在浏览器中的位置和大小。**
**计算盒模型的大小和位置；块元素、行类元素、浮动元素等；计算文字的大小位置、滚动区域等；**

浏览器的布局计算工作包含以下内容：
1. 根据 CSS 盒模型及视觉格式化模型，计算每个元素的各种生成盒的大小和位置。
2. 计算块级元素、行内元素、浮动元素、各种定位元素的大小和位置。
3. 计算文字，滚动区域的大小和位置。
4. LayoutObject 有两种类型：
  ○ 传统的 LayoutObject 节点，会把布局运算的结果重新写回布局树中。
  ○ LayoutNG（Chrome 76 开始启用） 节点的输出是不可变的，会保存在 NGLayoutResult 中，这是一个树状的结构，相比之前的 LayoutObject，少了很大回溯计算，提高了性能。

## Paint绘制阶段
Paint 阶段将 LayoutObject 树转换成供合成器使用的高效渲染格式
构建PaintLayer 绘制图层 （RenderLayer树）

构建完成的 LayoutObject 树还不能拿去显示，因为它不包含绘制的顺序（z-index）。同时，也为了考虑一些复杂的情况，如 3D 变换、页面滚动等，浏览器会对上一步的节点进行分层处理。这个处理过程被称为建立层叠上下文


浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。
构建 cc::Layer 与 display items

## Composite合成阶段
光栅化、draw，绘制生成的图层。利用gpu进行渲染绘图。
raster（光栅化）是将 display item 中的绘制操作转换为位图的过程。
当所有的 tiles 都完成光栅化后，会生成 draw quads（绘制四边形）。每个 draw quads 是包含一个在屏幕特定位置绘制 tile 的命令，该命令同时考虑了所有应用到 layer tree 的变换。每个四边形引用了内存中 tile 的光栅化输出。四边形被包裹在合成帧对象（compositor frame object）中，然后提交（submit）到浏览器进程